SCRIPT  /home/francois/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/sign.vim
Sourced 1 time
Total time:   0.000090
 Self time:   0.000090

count  total (s)   self (s)
                            " For older Vims without sign_place() the plugin has to manaage the sign ids.
    1              0.000003 let s:first_sign_id = 3000
    1              0.000002 let s:next_sign_id  = s:first_sign_id
                            " Remove-all-signs optimisation requires Vim 7.3.596+.
    1              0.000003 let s:supports_star = v:version > 703 || (v:version == 703 && has("patch596"))
                            
                            
    1              0.000001 function! gitgutter#sign#enable() abort
                              let old_signs = g:gitgutter_signs
                            
                              let g:gitgutter_signs = 1
                              call gitgutter#highlight#define_sign_text_highlights()
                            
                              if !old_signs && !g:gitgutter_highlight_lines && !g:gitgutter_highlight_linenrs
                                call gitgutter#all(1)
                              endif
                            endfunction
                            
    1              0.000001 function! gitgutter#sign#disable() abort
                              let g:gitgutter_signs = 0
                              call gitgutter#highlight#define_sign_text_highlights()
                            
                              if !g:gitgutter_highlight_lines && !g:gitgutter_highlight_linenrs
                                call gitgutter#sign#clear_signs(bufnr(''))
                              endif
                            endfunction
                            
    1              0.000001 function! gitgutter#sign#toggle() abort
                              if g:gitgutter_signs
                                call gitgutter#sign#disable()
                              else
                                call gitgutter#sign#enable()
                              endif
                            endfunction
                            
                            
                            " Removes gitgutter's signs from the buffer being processed.
    1              0.000001 function! gitgutter#sign#clear_signs(bufnr) abort
                              if exists('*sign_unplace')
                                call sign_unplace('gitgutter', {'buffer': a:bufnr})
                                return
                              endif
                            
                            
                              call s:find_current_signs(a:bufnr)
                            
                              let sign_ids = map(values(gitgutter#utility#getbufvar(a:bufnr, 'gitgutter_signs')), 'v:val.id')
                              call s:remove_signs(a:bufnr, sign_ids, 1)
                              call gitgutter#utility#setbufvar(a:bufnr, 'gitgutter_signs', {})
                            endfunction
                            
                            
                            " Updates gitgutter's signs in the buffer being processed.
                            "
                            " modified_lines: list of [<line_number (number)>, <name (string)>]
                            " where name = 'added|removed|modified|modified_removed'
    1              0.000001 function! gitgutter#sign#update_signs(bufnr, modified_lines) abort
                              if exists('*sign_unplace')
                                " Vim is (hopefully) now quick enough to remove all signs then place new ones.
                                call sign_unplace('gitgutter', {'buffer': a:bufnr})
                            
                                let modified_lines = s:handle_double_hunk(a:modified_lines)
                                let signs = map(copy(modified_lines), '{'.
                                      \ '"buffer":   a:bufnr,'.
                                      \ '"group":    "gitgutter",'.
                                      \ '"name":     s:highlight_name_for_change(v:val[1]),'.
                                      \ '"lnum":     v:val[0],'.
                                      \ '"priority": g:gitgutter_sign_priority'.
                                      \ '}')
                            
                                if exists('*sign_placelist')
                                  call sign_placelist(signs)
                                  return
                                endif
                            
                                for sign in signs
                                  call sign_place(0, sign.group, sign.name, sign.buffer, {'lnum': sign.lnum, 'priority': sign.priority})
                                endfor
                                return
                              endif
                            
                            
                              " Derive a delta between the current signs and the ones we want.
                              " Remove signs from lines that no longer need a sign.
                              " Upsert the remaining signs.
                            
                              call s:find_current_signs(a:bufnr)
                            
                              let new_gitgutter_signs_line_numbers = map(copy(a:modified_lines), 'v:val[0]')
                              let obsolete_signs = s:obsolete_gitgutter_signs_to_remove(a:bufnr, new_gitgutter_signs_line_numbers)
                            
                              call s:remove_signs(a:bufnr, obsolete_signs, s:remove_all_old_signs)
                              call s:upsert_new_gitgutter_signs(a:bufnr, a:modified_lines)
                            endfunction
                            
                            
                            "
                            " Internal functions
                            "
                            
                            
    1              0.000001 function! s:find_current_signs(bufnr) abort
                              let gitgutter_signs = {}  " <line_number (string)>: {'id': <id (number)>, 'name': <name (string)>}
                              if !g:gitgutter_sign_allow_clobber
                                let other_signs = []      " [<line_number (number),...]
                              endif
                            
                              if exists('*getbufinfo')
                                let bufinfo = getbufinfo(a:bufnr)[0]
                                let signs = has_key(bufinfo, 'signs') ? bufinfo.signs : []
                              else
                                let signs = []
                            
                                redir => signlines
                                  silent execute "sign place buffer=" . a:bufnr
                                redir END
                            
                                for signline in filter(split(signlines, '\n')[2:], 'v:val =~# "="')
                                  " Typical sign line before v8.1.0614:  line=88 id=1234 name=GitGutterLineAdded
                                  " We assume splitting is faster than a regexp.
                                  let components = split(signline)
                                  call add(signs, {
                                        \ 'lnum': str2nr(split(components[0], '=')[1]),
                                        \ 'id':   str2nr(split(components[1], '=')[1]),
                                        \ 'name':        split(components[2], '=')[1]
                                        \ })
                                endfor
                              endif
                            
                              for sign in signs
                                if sign.name =~# 'GitGutter'
                                  " Remove orphaned signs (signs placed on lines which have been deleted).
                                  " (When a line is deleted its sign lingers.  Subsequent lines' signs'
                                  " line numbers are decremented appropriately.)
                                  if has_key(gitgutter_signs, sign.lnum)
                                    execute "sign unplace" gitgutter_signs[sign.lnum].id
                                  endif
                                  let gitgutter_signs[sign.lnum] = {'id': sign.id, 'name': sign.name}
                                else
                                  if !g:gitgutter_sign_allow_clobber
                                    call add(other_signs, sign.lnum)
                                  endif
                                endif
                              endfor
                            
                              call gitgutter#utility#setbufvar(a:bufnr, 'gitgutter_signs', gitgutter_signs)
                              if !g:gitgutter_sign_allow_clobber
                                call gitgutter#utility#setbufvar(a:bufnr, 'other_signs', other_signs)
                              endif
                            endfunction
                            
                            
                            " Returns a list of [<id (number)>, ...]
                            " Sets `s:remove_all_old_signs` as a side-effect.
    1              0.000001 function! s:obsolete_gitgutter_signs_to_remove(bufnr, new_gitgutter_signs_line_numbers) abort
                              let signs_to_remove = []  " list of [<id (number)>, ...]
                              let remove_all_signs = 1
                              let old_gitgutter_signs = gitgutter#utility#getbufvar(a:bufnr, 'gitgutter_signs')
                              for line_number in keys(old_gitgutter_signs)
                                if index(a:new_gitgutter_signs_line_numbers, str2nr(line_number)) == -1
                                  call add(signs_to_remove, old_gitgutter_signs[line_number].id)
                                else
                                  let remove_all_signs = 0
                                endif
                              endfor
                              let s:remove_all_old_signs = remove_all_signs
                              return signs_to_remove
                            endfunction
                            
                            
    1              0.000001 function! s:remove_signs(bufnr, sign_ids, all_signs) abort
                              if a:all_signs && s:supports_star && (g:gitgutter_sign_allow_clobber || empty(gitgutter#utility#getbufvar(a:bufnr, 'other_signs')))
                                execute "sign unplace * buffer=" . a:bufnr
                              else
                                for id in a:sign_ids
                                  execute "sign unplace" id
                                endfor
                              endif
                            endfunction
                            
                            
    1              0.000001 function! s:upsert_new_gitgutter_signs(bufnr, modified_lines) abort
                              if !g:gitgutter_sign_allow_clobber
                                let other_signs = gitgutter#utility#getbufvar(a:bufnr, 'other_signs')
                              endif
                              let old_gitgutter_signs = gitgutter#utility#getbufvar(a:bufnr, 'gitgutter_signs')
                            
                              let modified_lines = s:handle_double_hunk(a:modified_lines)
                            
                              for line in modified_lines
                                let line_number = line[0]  " <number>
                                if g:gitgutter_sign_allow_clobber || index(other_signs, line_number) == -1  " don't clobber others' signs
                                  let name = s:highlight_name_for_change(line[1])
                                  if !has_key(old_gitgutter_signs, line_number)  " insert
                                    let id = s:next_sign_id()
                                    execute "sign place" id "line=" . line_number "name=" . name "buffer=" . a:bufnr
                                  else  " update if sign has changed
                                    let old_sign = old_gitgutter_signs[line_number]
                                    if old_sign.name !=# name
                                      execute "sign place" old_sign.id "name=" . name "buffer=" . a:bufnr
                                    end
                                  endif
                                endif
                              endfor
                              " At this point b:gitgutter_gitgutter_signs is out of date.
                            endfunction
                            
                            
                            " Handle special case where the first line is the site of two hunks:
                            " lines deleted above at the start of the file, and lines deleted
                            " immediately below.
    1              0.000001 function! s:handle_double_hunk(modified_lines)
                              if a:modified_lines[0:1] == [[1, 'removed_first_line'], [1, 'removed']]
                                return [[1, 'removed_above_and_below']] + a:modified_lines[2:]
                              endif
                            
                              return a:modified_lines
                            endfunction
                            
                            
    1              0.000001 function! s:next_sign_id() abort
                              let next_id = s:next_sign_id
                              let s:next_sign_id += 1
                              return next_id
                            endfunction
                            
                            
                            " Only for testing.
    1              0.000001 function! gitgutter#sign#reset()
                              let s:next_sign_id  = s:first_sign_id
                            endfunction
                            
                            
    1              0.000001 function! s:highlight_name_for_change(text) abort
                              if a:text ==# 'added'
                                return 'GitGutterLineAdded'
                              elseif a:text ==# 'removed'
                                return 'GitGutterLineRemoved'
                              elseif a:text ==# 'removed_first_line'
                                return 'GitGutterLineRemovedFirstLine'
                              elseif a:text ==# 'modified'
                                return 'GitGutterLineModified'
                              elseif a:text ==# 'modified_removed'
                                return 'GitGutterLineModifiedRemoved'
                              elseif a:text ==# 'removed_above_and_below'
                                return 'GitGutterLineRemovedAboveAndBelow'
                              endif
                            endfunction
                            
                            

SCRIPT  /home/francois/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/hunk.vim
Sourced 1 time
Total time:   0.000164
 Self time:   0.000164

count  total (s)   self (s)
    1              0.000001 let s:winid = 0
    1              0.000001 let s:preview_bufnr = 0
    1              0.000002 let s:nomodeline = (v:version > 703 || (v:version == 703 && has('patch442'))) ? '<nomodeline>' : ''
                            
    1              0.000001 function! gitgutter#hunk#set_hunks(bufnr, hunks) abort
                              call gitgutter#utility#setbufvar(a:bufnr, 'hunks', a:hunks)
                              call s:reset_summary(a:bufnr)
                            endfunction
                            
    1              0.000001 function! gitgutter#hunk#hunks(bufnr) abort
                              return gitgutter#utility#getbufvar(a:bufnr, 'hunks', [])
                            endfunction
                            
    1              0.000001 function! gitgutter#hunk#reset(bufnr) abort
                              call gitgutter#utility#setbufvar(a:bufnr, 'hunks', [])
                              call s:reset_summary(a:bufnr)
                            endfunction
                            
                            
    1              0.000001 function! gitgutter#hunk#summary(bufnr) abort
                              return gitgutter#utility#getbufvar(a:bufnr, 'summary', [0,0,0])
                            endfunction
                            
    1              0.000001 function! s:reset_summary(bufnr) abort
                              call gitgutter#utility#setbufvar(a:bufnr, 'summary', [0,0,0])
                            endfunction
                            
    1              0.000001 function! gitgutter#hunk#increment_lines_added(bufnr, count) abort
                              let summary = gitgutter#hunk#summary(a:bufnr)
                              let summary[0] += a:count
                              call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)
                            endfunction
                            
    1              0.000001 function! gitgutter#hunk#increment_lines_modified(bufnr, count) abort
                              let summary = gitgutter#hunk#summary(a:bufnr)
                              let summary[1] += a:count
                              call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)
                            endfunction
                            
    1              0.000001 function! gitgutter#hunk#increment_lines_removed(bufnr, count) abort
                              let summary = gitgutter#hunk#summary(a:bufnr)
                              let summary[2] += a:count
                              call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)
                            endfunction
                            
                            
    1              0.000002 function! gitgutter#hunk#next_hunk(count) abort
                              let bufnr = bufnr('')
                              if !gitgutter#utility#is_active(bufnr) | return | endif
                            
                              let hunks = gitgutter#hunk#hunks(bufnr)
                              if empty(hunks)
                                call gitgutter#utility#warn('No hunks in file')
                                return
                              endif
                            
                              let current_line = line('.')
                              let hunk_count = 0
                              for hunk in hunks
                                if hunk[2] > current_line
                                  let hunk_count += 1
                                  if hunk_count == a:count
                                    let keys = &foldopen =~# '\<block\>' ? 'zv' : ''
                                    execute 'normal!' hunk[2] . 'G' . keys
                                    if g:gitgutter_show_msg_on_hunk_jumping
                                      redraw | echo printf('Hunk %d of %d', index(hunks, hunk) + 1, len(hunks))
                                    endif
                                    if gitgutter#hunk#is_preview_window_open()
                                      call gitgutter#hunk#preview()
                                    endif
                                    return
                                  endif
                                endif
                              endfor
                              call gitgutter#utility#warn('No more hunks')
                            endfunction
                            
    1              0.000001 function! gitgutter#hunk#prev_hunk(count) abort
                              let bufnr = bufnr('')
                              if !gitgutter#utility#is_active(bufnr) | return | endif
                            
                              let hunks = gitgutter#hunk#hunks(bufnr)
                              if empty(hunks)
                                call gitgutter#utility#warn('No hunks in file')
                                return
                              endif
                            
                              let current_line = line('.')
                              let hunk_count = 0
                              for hunk in reverse(copy(hunks))
                                if hunk[2] < current_line
                                  let hunk_count += 1
                                  if hunk_count == a:count
                                    let keys = &foldopen =~# '\<block\>' ? 'zv' : ''
                                    let target = hunk[2] == 0 ? 1 : hunk[2]
                                    execute 'normal!' target . 'G' . keys
                                    if g:gitgutter_show_msg_on_hunk_jumping
                                      redraw | echo printf('Hunk %d of %d', index(hunks, hunk) + 1, len(hunks))
                                    endif
                                    if gitgutter#hunk#is_preview_window_open()
                                      call gitgutter#hunk#preview()
                                    endif
                                    return
                                  endif
                                endif
                              endfor
                              call gitgutter#utility#warn('No previous hunks')
                            endfunction
                            
                            " Returns the hunk the cursor is currently in or an empty list if the cursor
                            " isn't in a hunk.
    1              0.000001 function! s:current_hunk() abort
                              let bufnr = bufnr('')
                              let current_hunk = []
                            
                              for hunk in gitgutter#hunk#hunks(bufnr)
                                if gitgutter#hunk#cursor_in_hunk(hunk)
                                  let current_hunk = hunk
                                  break
                                endif
                              endfor
                            
                              return current_hunk
                            endfunction
                            
                            " Returns truthy if the cursor is in two hunks (which can only happen if the
                            " cursor is on the first line and lines above have been deleted and lines
                            " immediately below have been deleted) or falsey otherwise.
    1              0.000001 function! s:cursor_in_two_hunks()
                              let hunks = gitgutter#hunk#hunks(bufnr(''))
                            
                              if line('.') == 1 && len(hunks) > 1 && hunks[0][2:3] == [0, 0] && hunks[1][2:3] == [1, 0]
                                return 1
                              endif
                            
                              return 0
                            endfunction
                            
                            " A line can be in 0 or 1 hunks, with the following exception: when the first
                            " line(s) of a file has been deleted, and the new second line (and
                            " optionally below) has been deleted, the new first line is in two hunks.
    1              0.000001 function! gitgutter#hunk#cursor_in_hunk(hunk) abort
                              let current_line = line('.')
                            
                              if current_line == 1 && a:hunk[2] == 0
                                return 1
                              endif
                            
                              if current_line >= a:hunk[2] && current_line < a:hunk[2] + (a:hunk[3] == 0 ? 1 : a:hunk[3])
                                return 1
                              endif
                            
                              return 0
                            endfunction
                            
                            
    1              0.000001 function! gitgutter#hunk#in_hunk(lnum)
                              " Hunks are sorted in the order they appear in the buffer.
                              for hunk in gitgutter#hunk#hunks(bufnr(''))
                                " if in a hunk on first line of buffer
                                if a:lnum == 1 && hunk[2] == 0
                                  return 1
                                endif
                            
                                " if in a hunk generally
                                if a:lnum >= hunk[2] && a:lnum < hunk[2] + (hunk[3] == 0 ? 1 : hunk[3])
                                  return 1
                                endif
                            
                                " if hunk starts after the given line
                                if a:lnum < hunk[2]
                                  return 0
                                endif
                              endfor
                            
                              return 0
                            endfunction
                            
                            
    1              0.000001 function! gitgutter#hunk#text_object(inner) abort
                              let hunk = s:current_hunk()
                            
                              if empty(hunk)
                                return
                              endif
                            
                              let [first_line, last_line] = [hunk[2], hunk[2] + hunk[3] - 1]
                            
                              if ! a:inner
                                let lnum = last_line
                                let eof = line('$')
                                while lnum < eof && empty(getline(lnum + 1))
                                  let lnum +=1
                                endwhile
                                let last_line = lnum
                              endif
                            
                              execute 'normal! 'first_line.'GV'.last_line.'G'
                            endfunction
                            
                            
    1              0.000001 function! gitgutter#hunk#stage(...) abort
                              if !s:in_hunk_preview_window() && !gitgutter#utility#has_repo_path(bufnr('')) | return | endif
                            
                              if a:0 && (a:1 != 1 || a:2 != line('$'))
                                call s:hunk_op(function('s:stage'), a:1, a:2)
                              else
                                call s:hunk_op(function('s:stage'))
                              endif
                              silent! call repeat#set("\<Plug>(GitGutterStageHunk)", -1)
                            endfunction
                            
    1              0.000000 function! gitgutter#hunk#undo() abort
                              if !gitgutter#utility#has_repo_path(bufnr('')) | return | endif
                            
                              call s:hunk_op(function('s:undo'))
                              silent! call repeat#set("\<Plug>(GitGutterUndoHunk)", -1)
                            endfunction
                            
    1              0.000001 function! gitgutter#hunk#preview() abort
                              if !gitgutter#utility#has_repo_path(bufnr('')) | return | endif
                            
                              call s:hunk_op(function('s:preview'))
                              silent! call repeat#set("\<Plug>(GitGutterPreviewHunk)", -1)
                            endfunction
                            
                            
    1              0.000001 function! s:hunk_op(op, ...)
                              let bufnr = bufnr('')
                            
                              if s:in_hunk_preview_window()
                                if string(a:op) =~ '_stage'
                                  " combine hunk-body in preview window with updated hunk-header
                                  let hunk_body = getline(1, '$')
                            
                                  let [removed, added] = [0, 0]
                                  for line in hunk_body
                                    if line[0] == '-'
                                      let removed += 1
                                    elseif line[0] == '+'
                                      let added += 1
                                    endif
                                  endfor
                            
                                  let hunk_header = b:hunk_header
                                  " from count
                                  let hunk_header[4] = substitute(hunk_header[4], '\(-\d\+\)\(,\d\+\)\?', '\=submatch(1).",".removed', '')
                                  " to count
                                  let hunk_header[4] = substitute(hunk_header[4], '\(+\d\+\)\(,\d\+\)\?', '\=submatch(1).",".added', '')
                            
                                  let hunk_diff = join(hunk_header + hunk_body, "\n")."\n"
                            
                                  if &previewwindow
                                    call s:goto_original_window()
                                  endif
                                  call gitgutter#hunk#close_hunk_preview_window()
                                  call s:stage(hunk_diff)
                                endif
                            
                                return
                              endif
                            
                              if gitgutter#utility#is_active(bufnr)
                                " Get a (synchronous) diff.
                                let [async, g:gitgutter_async] = [g:gitgutter_async, 0]
                                let diff = gitgutter#diff#run_diff(bufnr, g:gitgutter_diff_relative_to, 1)
                                let g:gitgutter_async = async
                            
                                call gitgutter#hunk#set_hunks(bufnr, gitgutter#diff#parse_diff(diff))
                                call gitgutter#diff#process_hunks(bufnr, gitgutter#hunk#hunks(bufnr))  " so the hunk summary is updated
                            
                                if empty(s:current_hunk())
                                  call gitgutter#utility#warn('Cursor is not in a hunk')
                                elseif s:cursor_in_two_hunks()
                                  let choice = input('Choose hunk: upper or lower (u/l)? ')
                                  " Clear input
                                  normal! :<ESC>
                                  if choice =~ 'u'
                                    call a:op(gitgutter#diff#hunk_diff(bufnr, diff, 0))
                                  elseif choice =~ 'l'
                                    call a:op(gitgutter#diff#hunk_diff(bufnr, diff, 1))
                                  else
                                    call gitgutter#utility#warn('Did not recognise your choice')
                                  endif
                                else
                                  let hunk_diff = gitgutter#diff#hunk_diff(bufnr, diff)
                            
                                  if a:0
                                    let hunk_first_line = s:current_hunk()[2]
                                    let hunk_diff = s:part_of_diff(hunk_diff, a:1-hunk_first_line, a:2-hunk_first_line)
                                  endif
                            
                                  call a:op(hunk_diff)
                                endif
                              endif
                            endfunction
                            
                            
    1              0.000001 function! s:stage(hunk_diff)
                              let bufnr = bufnr('')
                            
                              if gitgutter#utility#clean_smudge_filter_applies(bufnr)
                                let choice = input('File uses clean/smudge filter. Stage entire file (y/n)? ')
                                normal! :<ESC>
                                if choice =~ 'y'
                                  " We are about to add the file to the index so write the buffer to
                                  " ensure the file on disk matches it (the buffer).
                                  write
                                  let path = gitgutter#utility#repo_path(bufnr, 1)
                                  " Add file to index.
                                  let cmd = gitgutter#git(bufnr).' add '.
                                        \ gitgutter#utility#shellescape(gitgutter#utility#filename(bufnr))
                                  let [_, error_code] = gitgutter#utility#system(cmd)
                                else
                                  return
                                endif
                            
                              else
                                let diff = s:adjust_header(bufnr, a:hunk_diff)
                                " Apply patch to index.
                                let [_, error_code] = gitgutter#utility#system(
                                      \ gitgutter#git(bufnr).' apply --cached --unidiff-zero - ',
                                      \ diff)
                              endif
                            
                              if error_code
                                call gitgutter#utility#warn('Patch does not apply')
                              else
                                if exists('#User#GitGutterStage')
                                  execute 'doautocmd' s:nomodeline 'User GitGutterStage'
                                endif
                              endif
                            
                              " Refresh gitgutter's view of buffer.
                              call gitgutter#process_buffer(bufnr, 1)
                            endfunction
                            
                            
    1              0.000001 function! s:undo(hunk_diff)
                              " Apply reverse patch to buffer.
                              let hunk  = gitgutter#diff#parse_hunk(split(a:hunk_diff, '\n')[4])
                              let lines = map(split(a:hunk_diff, '\r\?\n')[5:], 'v:val[1:]')
                              let lnum  = hunk[2]
                              let added_only   = hunk[1] == 0 && hunk[3]  > 0
                              let removed_only = hunk[1]  > 0 && hunk[3] == 0
                            
                              if removed_only
                                call append(lnum, lines)
                              elseif added_only
                                execute lnum .','. (lnum+len(lines)-1) .'d _'
                              else
                                call append(lnum-1, lines[0:hunk[1]])
                                execute (lnum+hunk[1]) .','. (lnum+hunk[1]+hunk[3]) .'d _'
                              endif
                            
                              " Refresh gitgutter's view of buffer.
                              call gitgutter#process_buffer(bufnr(''), 1)
                            endfunction
                            
                            
    1              0.000001 function! s:preview(hunk_diff)
                              if g:gitgutter_preview_win_floating && exists('*nvim_set_current_win') && s:winid != 0
                                call nvim_set_current_win(s:winid)
                                return
                              endif
                            
                              let lines = split(a:hunk_diff, '\r\?\n')
                              let header = lines[0:4]
                              let body = lines[5:]
                            
                              call s:open_hunk_preview_window()
                              call s:populate_hunk_preview_window(header, body)
                              call s:enable_staging_from_hunk_preview_window()
                              if &previewwindow
                                call s:goto_original_window()
                              endif
                            endfunction
                            
                            
                            " Returns a new hunk diff using the specified lines from the given one.
                            " Assumes all lines are additions.
                            " a:first, a:last - 0-based indexes into the body of the hunk.
    1              0.000001 function! s:part_of_diff(hunk_diff, first, last)
                              let diff_lines = split(a:hunk_diff, '\n', 1)
                            
                              " adjust 'to' line count in header
                              let diff_lines[4] = substitute(diff_lines[4], '\(+\d\+\)\(,\d\+\)\?', '\=submatch(1).",".(a:last-a:first+1)', '')
                            
                              return join(diff_lines[0:4] + diff_lines[5+a:first:5+a:last], "\n")."\n"
                            endfunction
                            
                            
    1              0.000001 function! s:adjust_header(bufnr, hunk_diff)
                              let filepath = gitgutter#utility#repo_path(a:bufnr, 0)
                              return s:adjust_hunk_summary(s:fix_file_references(filepath, a:hunk_diff))
                            endfunction
                            
                            
                            " Replaces references to temp files with the actual file.
    1              0.000001 function! s:fix_file_references(filepath, hunk_diff)
                              let lines = split(a:hunk_diff, '\n')
                            
                              let left_prefix  = matchstr(lines[2], '[abciow12]').'/'
                              let right_prefix = matchstr(lines[3], '[abciow12]').'/'
                              let quote        = lines[0][11] == '"' ? '"' : ''
                            
                              let left_file  = quote.left_prefix.a:filepath.quote
                              let right_file = quote.right_prefix.a:filepath.quote
                            
                              let lines[0] = 'diff --git '.left_file.' '.right_file
                              let lines[2] = '--- '.left_file
                              let lines[3] = '+++ '.right_file
                            
                              return join(lines, "\n")."\n"
                            endfunction
                            
                            
    1              0.000002 function! s:adjust_hunk_summary(hunk_diff) abort
                              let line_adjustment = s:line_adjustment_for_current_hunk()
                              let diff = split(a:hunk_diff, '\n', 1)
                              let diff[4] = substitute(diff[4], '+\zs\(\d\+\)', '\=submatch(1)+line_adjustment', '')
                              return join(diff, "\n")
                            endfunction
                            
                            
                            " Returns the number of lines the current hunk is offset from where it would
                            " be if any changes above it in the file didn't exist.
    1              0.000001 function! s:line_adjustment_for_current_hunk() abort
                              let bufnr = bufnr('')
                              let adj = 0
                              for hunk in gitgutter#hunk#hunks(bufnr)
                                if gitgutter#hunk#cursor_in_hunk(hunk)
                                  break
                                else
                                  let adj += hunk[1] - hunk[3]
                                endif
                              endfor
                              return adj
                            endfunction
                            
                            
    1              0.000001 function! s:in_hunk_preview_window()
                              if g:gitgutter_preview_win_floating
                                return win_id2win(s:winid) == winnr()
                              else
                                return &previewwindow
                              endif
                            endfunction
                            
                            
                            " Floating window: does not move cursor to floating window.
                            " Preview window: moves cursor to preview window.
    1              0.000001 function! s:open_hunk_preview_window()
                              let source_wrap = &wrap
                              let source_window = winnr()
                            
                              if g:gitgutter_preview_win_floating
                                if exists('*nvim_open_win')
                                  call gitgutter#hunk#close_hunk_preview_window()
                            
                                  let buf = nvim_create_buf(v:false, v:false)
                                  " Set default width and height for now.
                                  let s:winid = nvim_open_win(buf, v:false, g:gitgutter_floating_window_options)
                                  call nvim_win_set_option(s:winid, 'wrap', source_wrap ? v:true : v:false)
                                  call nvim_buf_set_option(buf, 'filetype',  'diff')
                                  call nvim_buf_set_option(buf, 'buftype',   'acwrite')
                                  call nvim_buf_set_option(buf, 'bufhidden', 'delete')
                                  call nvim_buf_set_option(buf, 'swapfile',  v:false)
                                  call nvim_buf_set_name(buf, 'gitgutter://hunk-preview')
                            
                                  if g:gitgutter_close_preview_on_escape
                                    let winnr = nvim_win_get_number(s:winid)
                                    execute winnr.'wincmd w'
                                    nnoremap <buffer> <silent> <Esc> :<C-U>call gitgutter#hunk#close_hunk_preview_window()<CR>
                                    wincmd w
                                  endif
                            
                                  " Assumes cursor is in original window.
                                  autocmd CursorMoved,TabLeave <buffer> ++once call gitgutter#hunk#close_hunk_preview_window()
                            
                                  return
                                endif
                            
                                if exists('*popup_create')
                                  if g:gitgutter_close_preview_on_escape
                                    let g:gitgutter_floating_window_options.filter = function('s:close_popup_on_escape')
                                  endif
                            
                                  let s:winid = popup_create('', g:gitgutter_floating_window_options)
                            
                                  call setbufvar(winbufnr(s:winid), '&filetype', 'diff')
                                  call setwinvar(s:winid, '&wrap', source_wrap)
                            
                                  return
                                endif
                              endif
                            
                              if exists('&previewpopup')
                                let [previewpopup, &previewpopup] = [&previewpopup, '']
                              endif
                            
                              " Specifying where to open the preview window can lead to the cursor going
                              " to an unexpected window when the preview window is closed (#769).
                              silent! noautocmd execute g:gitgutter_preview_win_location 'pedit gitgutter://hunk-preview'
                              silent! wincmd P
                              setlocal statusline=%{''}
                              doautocmd WinEnter
                              if exists('*win_getid')
                                let s:winid = win_getid()
                              else
                                let s:preview_bufnr = bufnr('')
                              endif
                              setlocal filetype=diff buftype=acwrite bufhidden=delete
                              let &l:wrap = source_wrap
                              let b:source_window = source_window
                              " Reset some defaults in case someone else has changed them.
                              setlocal noreadonly modifiable noswapfile
                              if g:gitgutter_close_preview_on_escape
                                " Ensure cursor goes to the expected window.
                                nnoremap <buffer> <silent> <Esc> :<C-U>execute b:source_window . "wincmd w"<Bar>pclose<CR>
                              endif
                            
                              if exists('&previewpopup')
                                let &previewpopup=previewpopup
                              endif
                            endfunction
                            
                            
    1              0.000001 function! s:close_popup_on_escape(winid, key)
                              if a:key == "\<Esc>"
                                call popup_close(a:winid)
                                return 1
                              endif
                              return 0
                            endfunction
                            
                            
                            " Floating window: does not care where cursor is.
                            " Preview window: assumes cursor is in preview window.
    1              0.000001 function! s:populate_hunk_preview_window(header, body)
                              if g:gitgutter_preview_win_floating
                                if exists('*nvim_open_win')
                                  " Assumes cursor is not in previewing window.
                                  call nvim_buf_set_var(winbufnr(s:winid), 'hunk_header', a:header)
                            
                                  let [_scrolloff, &scrolloff] = [&scrolloff, 0]
                            
                                  let [width, height] = s:screen_lines(a:body)
                                  let height = min([height, g:gitgutter_floating_window_options.height])
                                  call nvim_win_set_width(s:winid, width)
                                  call nvim_win_set_height(s:winid, height)
                            
                                  let &scrolloff=_scrolloff
                            
                                  call nvim_buf_set_lines(winbufnr(s:winid), 0, -1, v:false, [])
                                  call nvim_buf_set_lines(winbufnr(s:winid), 0, -1, v:false, a:body)
                                  call nvim_buf_set_option(winbufnr(s:winid), 'modified', v:false)
                            
                                  let ns_id = nvim_create_namespace('GitGutter')
                                  call nvim_buf_clear_namespace(winbufnr(s:winid), ns_id, 0, -1)
                                  for region in gitgutter#diff_highlight#process(a:body)
                                    let group = region[1] == '+' ? 'GitGutterAddIntraLine' : 'GitGutterDeleteIntraLine'
                                    call nvim_buf_add_highlight(winbufnr(s:winid), ns_id, group, region[0]-1, region[2]-1, region[3])
                                  endfor
                            
                                  call nvim_win_set_cursor(s:winid, [1,0])
                                endif
                            
                                if exists('*popup_create')
                                  call popup_settext(s:winid, a:body)
                            
                                  for region in gitgutter#diff_highlight#process(a:body)
                                    let group = region[1] == '+' ? 'GitGutterAddIntraLine' : 'GitGutterDeleteIntraLine'
                                    call win_execute(s:winid, "call matchaddpos('".group."', [[".region[0].", ".region[2].", ".(region[3]-region[2]+1)."]])")
                                  endfor
                                endif
                            
                              else
                                let b:hunk_header = a:header
                            
                                %delete _
                                call setline(1, a:body)
                                setlocal nomodified
                            
                                let [_, height] = s:screen_lines(a:body)
                                execute 'resize' height
                                1
                            
                                call clearmatches()
                                for region in gitgutter#diff_highlight#process(a:body)
                                  let group = region[1] == '+' ? 'GitGutterAddIntraLine' : 'GitGutterDeleteIntraLine'
                                  call matchaddpos(group, [[region[0], region[2], region[3]-region[2]+1]])
                                endfor
                            
                                1
                              endif
                            endfunction
                            
                            
                            " Calculates the number of columns and the number of screen lines the given
                            " array of lines will take up, taking account of wrapping.
    1              0.000001 function! s:screen_lines(lines)
                              let [_virtualedit, &virtualedit]=[&virtualedit, 'all']
                              let cursor = getcurpos()
                              normal! 0g$
                              let available_width = virtcol('.')
                              call setpos('.', cursor)
                              let &virtualedit=_virtualedit
                              let width = min([max(map(copy(a:lines), 'strdisplaywidth(v:val)')), available_width])
                            
                              if exists('*reduce')
                                let height = reduce(a:lines, { acc, val -> acc + strdisplaywidth(val) / width + (strdisplaywidth(val) % width == 0 ? 0 : 1) }, 0)
                              else
                                let height = eval(join(map(copy(a:lines), 'strdisplaywidth(v:val) / width + (strdisplaywidth(v:val) % width == 0 ? 0 : 1)'), '+'))
                              endif
                            
                              return [width, height]
                            endfunction
                            
                            
    1              0.000001 function! s:enable_staging_from_hunk_preview_window()
                              augroup gitgutter_hunk_preview
                                autocmd!
                                let bufnr = s:winid != 0 ? winbufnr(s:winid) : s:preview_bufnr
                                execute 'autocmd BufWriteCmd <buffer='.bufnr.'> GitGutterStageHunk'
                              augroup END
                            endfunction
                            
                            
    1              0.000001 function! s:goto_original_window()
                              noautocmd execute b:source_window . "wincmd w"
                              doautocmd WinEnter
                            endfunction
                            
                            
    1              0.000001 function! gitgutter#hunk#close_hunk_preview_window()
                              let bufnr = s:winid != 0 ? winbufnr(s:winid) : s:preview_bufnr
                              call setbufvar(bufnr, '&modified', 0)
                            
                              if g:gitgutter_preview_win_floating
                                if win_id2win(s:winid) > 0
                                  execute win_id2win(s:winid).'wincmd c'
                                endif
                              else
                                pclose
                              endif
                            
                              let s:winid = 0
                              let s:preview_bufnr = 0
                            endfunction
                            
                            
    1              0.000001 function gitgutter#hunk#is_preview_window_open()
                              if g:gitgutter_preview_win_floating
                                if win_id2win(s:winid) > 0
                                  execute win_id2win(s:winid).'wincmd c'
                                endif
                              else
                                for i in range(1, winnr('$'))
                                  if getwinvar(i, '&previewwindow')
                                    return 1
                                  endif
                                endfor
                              endif
                              return 0
                            endfunction

SCRIPT  /home/francois/.config/nvim/.nvim-session/default
Sourced 1 time
Total time:   0.065276
 Self time:   0.002459

count  total (s)   self (s)
    1              0.000003 let SessionLoad = 1
    1   0.000056   0.000009 let s:so_save = &g:so | let s:siso_save = &g:siso | setg so=0 siso=0 | setl so=-1 siso=-1
    1              0.000004 let v:this_session=expand("<sfile>:p")
    1              0.000002 let VimuxOpenExtraArgs = ""
    1              0.000002 let VimuxRunnerType = "pane"
    1              0.000001 let VimuxHeight = "20%"
    1              0.000001 let VimuxTmuxCommand = "tmux"
    1              0.000001 let VimuxResetSequence = "C-u"
    1              0.000001 let NvimTreeSetup =  1 
    1              0.000001 let VimuxPromptString = "Command? "
    1              0.000001 let AnsiEsc_Enabled =  1 
    1              0.000001 let VimuxOrientation = "v"
    1              0.000001 let VimuxRunnerName = ""
    1              0.000001 let NvimTreeRequired =  1 
    1              0.000006 let ScopeState = "{\"last_tab\":2,\"cache\":[[\"\\/home\\/francois\\/.config\\/nvim\\/lua\\/core\\/plugin_config\\/lsp_config.lua\",\"\\/home\\/francois\\/.config\\/nvim\\/lua\\/core\\/plugin_config\\/___init.lua\",\"\\/home\\/francois\\/.config\\/nvim\\/lua\\/core\\/plugin_config\\/alpha_basic.lua\",\"\\/home\\/francois\\/.config\\/nvim\\/lua\\/core\\/plugin_config\\/copilot.lua\",\"\\/home\\/francois\\/.config\\/nvim\\/lua\\/core\\/plugin_config\\/alpha.lua\",\"\\/home\\/francois\\/.config\\/nvim\\/lua\\/core\\/plugin_config\\/lualine.lua\"],[\"\\/home\\/francois\\/Documents\\/University (Real)\\/Semester 10\\/Comp 303\\/AutomakeJava\\/mysrc\\/MainFile.java\",\"\\/home\\/francois\\/Documents\\/University (Real)\\/Semester 10\\/Comp 303\\/AutomakeJava\\/mysrc\\/find_dependancy_tree.py\"]]}"
    1              0.000004 silent only
    1              0.000002 silent tabonly
    1              0.000003 if expand('%') == '' && !&modified && line('$') <= 1 && getline(1) == ''
                              let s:wipebuf = bufnr('%')
    1              0.000000 endif
    1              0.000001 let s:shortmess_save = &shortmess
    1              0.000002 if &shortmess =~ 'A'
                              set shortmess=aoOA
    1              0.000000 else
    1   0.000009   0.000002   set shortmess=aoO
    1              0.000000 endif
    1   0.000105   0.000038 badd +1 ~/Documents/University\ (Real)/Semester\ 10/Comp\ 303/AutomakeJava/mysrc/MainFile.java
    1   0.000077   0.000024 badd +1 ~/Documents/University\ (Real)/Semester\ 10/Comp\ 303/AutomakeJava/mysrc/find_dependancy_tree.py
    1              0.000001 argglobal
    1              0.000002 %argdel
    1   0.002230   0.000056 tabnew +setlocal\ bufhidden=wipe
    1   0.001811   0.000009 tabrewind
    1   0.022414   0.001062 edit ~/.config/nvim/lua/core/plugin_config/lualine.lua
    1              0.000002 argglobal
    1              0.000004 let s:l = 1 - ((0 * winheight(0) + 16) / 33)
    1              0.000002 if s:l < 1 | let s:l = 1 | endif
    1              0.000004 keepjumps exe s:l
    1   0.003359   0.000039 normal! zt
    1              0.000002 keepjumps 1
    1   0.000103   0.000011 normal! 0
    1   0.001430   0.000009 tabnext
    1   0.029091   0.000991 edit ~/Documents/University\ (Real)/Semester\ 10/Comp\ 303/AutomakeJava/mysrc/find_dependancy_tree.py
    1              0.000002 argglobal
    1   0.000139   0.000028 balt ~/Documents/University\ (Real)/Semester\ 10/Comp\ 303/AutomakeJava/mysrc/MainFile.java
    1              0.000005 let s:l = 1 - ((0 * winheight(0) + 16) / 33)
    1              0.000002 if s:l < 1 | let s:l = 1 | endif
    1              0.000004 keepjumps exe s:l
    1   0.004022   0.000020 normal! zt
    1              0.000002 keepjumps 1
    1   0.000053   0.000010 normal! 0
    1              0.000003 tabnext 2
    1              0.000006 if exists('s:wipebuf') && len(win_findbuf(s:wipebuf)) == 0 && getbufvar(s:wipebuf, '&buftype') isnot# 'terminal'
                              silent exe 'bwipe ' . s:wipebuf
    1              0.000000 endif
    1              0.000001 unlet! s:wipebuf
    1   0.000049   0.000006 set winheight=1 winwidth=20
    1   0.000058   0.000005 let &shortmess = s:shortmess_save
    1              0.000008 let s:sx = expand("<sfile>:p:r")."x.vim"
    1              0.000004 if filereadable(s:sx)
                              exe "source " . fnameescape(s:sx)
    1              0.000000 endif
    1   0.000057   0.000006 let &g:so = s:so_save | let &g:siso = s:siso_save
    1   0.000024   0.000003 set hlsearch
    1              0.000001 nohlsearch
    1   0.000081   0.000024 doautoall SessionLoadPost
    1              0.000002 unlet SessionLoad
                            " vim: set ft=vim :

SCRIPT  /usr/share/nvim/runtime/ftplugin/lua.vim
Sourced 1 time
Total time:   0.000046
 Self time:   0.000046

count  total (s)   self (s)
                            " Vim filetype plugin file.
                            " Language:		Lua
                            " Maintainer:		Doug Kearns <dougkearns@gmail.com>
                            " Previous Maintainer:	Max Ischenko <mfi@ukr.net>
                            " Contributor:		Dorai Sitaram <ds26@gte.com>
                            "			C.D. MacEachern <craig.daniel.maceachern@gmail.com>
                            "			Tyler Miller <tmillr@proton.me>
                            " Last Change:		2024 Jan 14
                            
    1              0.000002 if exists("b:did_ftplugin")
                              finish
    1              0.000000 endif
    1              0.000001 let b:did_ftplugin = 1
                            
    1              0.000001 let s:cpo_save = &cpo
    1              0.000004 set cpo&vim
                            
    1              0.000002 setlocal comments=:---,:--
    1              0.000002 setlocal commentstring=--\ %s
    1              0.000002 setlocal formatoptions-=t formatoptions+=croql
                            
    1              0.000003 let &l:define = '\<function\|\<local\%(\s\+function\)\='
                            
                            " TODO: handle init.lua
    1              0.000002 setlocal includeexpr=tr(v:fname,'.','/')
    1              0.000001 setlocal suffixesadd=.lua
                            
    1              0.000001 let b:undo_ftplugin = "setlocal cms< com< def< fo< inex< sua<"
                            
    1              0.000002 if exists("loaded_matchit") && !exists("b:match_words")
    1              0.000001   let b:match_ignorecase = 0
    1              0.000003   let b:match_words =
                            	\ '\<\%(do\|function\|if\)\>:' ..
                            	\ '\<\%(return\|else\|elseif\)\>:' ..
                            	\ '\<end\>,' ..
                            	\ '\<repeat\>:\<until\>,' ..
                            	\ '\%(--\)\=\[\(=*\)\[:]\1]'
    1              0.000001   let b:undo_ftplugin ..= " | unlet! b:match_words b:match_ignorecase"
    1              0.000000 endif
                            
    1              0.000003 if (has("gui_win32") || has("gui_gtk")) && !exists("b:browsefilter")
                              let b:browsefilter = "Lua Source Files (*.lua)\t*.lua\n"
                              if has("win32")
                                let b:browsefilter ..= "All Files (*.*)\t*\n"
                              else
                                let b:browsefilter ..= "All Files (*)\t*\n"
                              endif
                              let b:undo_ftplugin ..= " | unlet! b:browsefilter"
    1              0.000000 endif
                            
    1              0.000002 let &cpo = s:cpo_save
    1              0.000001 unlet s:cpo_save
                            
                            " vim: nowrap sw=2 sts=2 ts=8 noet:

SCRIPT  /usr/share/nvim/runtime/ftplugin/lua.lua
Sourced 1 time
Total time:   0.002884
 Self time:   0.002884

count  total (s)   self (s)
                            -- use treesitter over syntax
                            vim.treesitter.start()

SCRIPT  /usr/share/nvim/runtime/indent/lua.vim
Sourced 1 time
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
                            " Vim indent file
                            " Language:	Lua script
                            " Maintainer:	Marcus Aurelius Farias <marcus.cf 'at' bol.com.br>
                            " First Author:	Max Ischenko <mfi 'at' ukr.net>
                            " Last Change:	2017 Jun 13
                            "		2022 Sep 07: b:undo_indent added by Doug Kearns
                            
                            " Only load this indent file when no other was loaded.
    1              0.000001 if exists("b:did_indent")
                              finish
    1              0.000000 endif
    1              0.000001 let b:did_indent = 1
                            
    1              0.000003 setlocal indentexpr=GetLuaIndent()
                            
                            " To make Vim call GetLuaIndent() when it finds '\s*end' or '\s*until'
                            " on the current line ('else' is default and includes 'elseif').
    1              0.000002 setlocal indentkeys+=0=end,0=until
                            
    1              0.000001 setlocal autoindent
                            
    1              0.000001 let b:undo_indent = "setlocal autoindent< indentexpr< indentkeys<"
                            
                            " Only define the function once.
    1              0.000001 if exists("*GetLuaIndent")
                              finish
    1              0.000000 endif
                            
    1              0.000001 function! GetLuaIndent()
                                let ignorecase_save = &ignorecase
                              try
                                let &ignorecase = 0
                                return GetLuaIndentIntern()
                              finally
                                let &ignorecase = ignorecase_save
                              endtry
                            endfunction
                            
    1              0.000001 function! GetLuaIndentIntern()
                              " Find a non-blank line above the current line.
                              let prevlnum = prevnonblank(v:lnum - 1)
                            
                              " Hit the start of the file, use zero indent.
                              if prevlnum == 0
                                return 0
                              endif
                            
                              " Add a 'shiftwidth' after lines that start a block:
                              " 'function', 'if', 'for', 'while', 'repeat', 'else', 'elseif', '{'
                              let ind = indent(prevlnum)
                              let prevline = getline(prevlnum)
                              let midx = match(prevline, '^\s*\%(if\>\|for\>\|while\>\|repeat\>\|else\>\|elseif\>\|do\>\|then\>\)')
                              if midx == -1
                                let midx = match(prevline, '{\s*\%(--\%([^[].*\)\?\)\?$')
                                if midx == -1
                                  let midx = match(prevline, '\<function\>\s*\%(\k\|[.:]\)\{-}\s*(')
                                endif
                              endif
                            
                              if midx != -1
                                " Add 'shiftwidth' if what we found previously is not in a comment and
                                " an "end" or "until" is not present on the same line.
                                if synIDattr(synID(prevlnum, midx + 1, 1), "name") != "luaComment" && prevline !~ '\<end\>\|\<until\>'
                                  let ind = ind + shiftwidth()
                                endif
                              endif
                            
                              " Subtract a 'shiftwidth' on end, else, elseif, until and '}'
                              " This is the part that requires 'indentkeys'.
                              let midx = match(getline(v:lnum), '^\s*\%(end\>\|else\>\|elseif\>\|until\>\|}\)')
                              if midx != -1 && synIDattr(synID(v:lnum, midx + 1, 1), "name") != "luaComment"
                                let ind = ind - shiftwidth()
                              endif
                            
                              return ind
                            endfunction

SCRIPT  /home/francois/.local/share/nvim/lazy/vim-plugin-AnsiEsc/autoload/AnsiEsc.vim
Sourced 1 time
Total time:   0.000372
 Self time:   0.000372

count  total (s)   self (s)
                            " AnsiEsc.vim: Uses vim 7.0 syntax highlighting
                            " Language:		Text with ansi escape sequences
                            " Maintainer:	Charles E. Campbell <NdrOchipS@PcampbellAfamily.Mbiz>
                            " Version:		13i	ASTRO-ONLY
                            " Date:		Apr 02, 2015
                            "
                            " Usage: :AnsiEsc  (toggles)
                            " Note:   This plugin requires +conceal
                            "
                            " GetLatestVimScripts: 302 1 :AutoInstall: AnsiEsc.vim
                            "redraw!|call DechoSep()|call inputsave()|call input("Press <cr> to continue")|call inputrestore()
                            " ---------------------------------------------------------------------
                            "DechoRemOn
                            "  Load Once: {{{1
    1              0.000002 if exists("g:loaded_AnsiEsc")
                             finish
    1              0.000000 endif
    1              0.000002 let g:loaded_AnsiEsc = "v13i"
    1              0.000001 if v:version < 700
                             echohl WarningMsg
                             echo "***warning*** this version of AnsiEsc needs vim 7.0"
                             echohl Normal
                             finish
    1              0.000000 endif
    1              0.000001 let s:keepcpo= &cpo
    1              0.000004 set cpo&vim
                            
                            " ---------------------------------------------------------------------
                            " AnsiEsc#AnsiEsc: toggles ansi-escape code visualization {{{2
    1              0.000001 fun! AnsiEsc#AnsiEsc(rebuild)
                            "  call Dfunc("AnsiEsc#AnsiEsc(rebuild=".a:rebuild.")")
                              if a:rebuild
                            "   call Decho("rebuilding AnsiEsc tables")
                               call AnsiEsc#AnsiEsc(0)
                               call AnsiEsc#AnsiEsc(0)
                            "   call Dret("AnsiEsc#AnsiEsc")
                               return
                              endif
                              let bn= bufnr("%")
                              if !exists("s:AnsiEsc_enabled_{bn}")
                               let s:AnsiEsc_enabled_{bn}= 0
                              endif
                              if s:AnsiEsc_enabled_{bn}
                               " disable AnsiEsc highlighting
                            "   call Decho("disable AnsiEsc highlighting: s:AnsiEsc_ft_".bn."<".s:AnsiEsc_ft_{bn}."> bn#".bn)
                               if exists("g:colors_name")|let colorname= g:colors_name|endif
                               if exists("s:conckeep_{bufnr('%')}")|let &l:conc= s:conckeep_{bufnr('%')}|unlet s:conckeep_{bufnr('%')}|endif
                               if exists("s:colekeep_{bufnr('%')}")|let &l:cole= s:colekeep_{bufnr('%')}|unlet s:colekeep_{bufnr('%')}|endif
                               if exists("s:cocukeep_{bufnr('%')}")|let &l:cocu= s:cocukeep_{bufnr('%')}|unlet s:cocukeep_{bufnr('%')}|endif
                               hi! link ansiStop NONE
                               syn clear
                               hi  clear
                               syn reset
                               exe "set ft=".s:AnsiEsc_ft_{bn}
                               if exists("colorname")|exe "colors ".colorname|endif
                               let s:AnsiEsc_enabled_{bn}= 0
                               if !exists('g:no_drchip_menu') && !exists('g:no_ansiesc_menu')
                                if has("gui_running") && has("menu") && &go =~# 'm'
                                 " menu support
                                 exe 'silent! unmenu '.g:DrChipTopLvlMenu.'AnsiEsc'
                                 exe 'menu '.g:DrChipTopLvlMenu.'AnsiEsc.Start<tab>:AnsiEsc		:AnsiEsc<cr>'
                                endif
                               endif
                               if !has('conceal')
                                let &l:hl= s:hlkeep_{bufnr("%")}
                               endif
                            "   call Dret("AnsiEsc#AnsiEsc")
                               return
                              else
                               let s:AnsiEsc_ft_{bn}      = &ft
                               let s:AnsiEsc_enabled_{bn} = 1
                            "   call Decho("enable AnsiEsc highlighting: s:AnsiEsc_ft_".bn."<".s:AnsiEsc_ft_{bn}."> bn#".bn)
                               if !exists('g:no_drchip_menu') && !exists('g:no_ansiesc_menu')
                                if has("gui_running") && has("menu") && &go =~# 'm'
                                 " menu support
                                 exe 'sil! unmenu '.g:DrChipTopLvlMenu.'AnsiEsc'
                                 exe 'menu '.g:DrChipTopLvlMenu.'AnsiEsc.Stop<tab>:AnsiEsc		:AnsiEsc<cr>'
                                endif
                               endif
                            
                               " -----------------
                               "  Conceal Support: {{{2
                               " -----------------
                               if has("conceal")
                                if v:version < 703
                                 if &l:conc != 3
                                  let s:conckeep_{bufnr('%')}= &cole
                                  setlocal conc=3
                            "      call Decho("l:conc=".&l:conc)
                                 endif
                                else
                                 if &l:cole != 3 || &l:cocu != "nv"
                                  let s:colekeep_{bufnr('%')}= &l:cole
                                  let s:cocukeep_{bufnr('%')}= &l:cocu
                                  setlocal cole=3 cocu=nv
                            "      call Decho("l:cole=".&l:cole." l:cocu=".&l:cocu)
                                 endif
                                endif
                               endif
                              endif
                            
                              syn clear
                            
                              if has("conceal")
                               syn match ansiConceal		contained conceal	"\e\[\(\d*;\)*\d*[A-Za-z]"
                              else
                               syn match ansiConceal		contained		"\e\[\(\d*;\)*\d*[A-Za-z]"
                              endif
                            
                              " suppress escaped sequences that we don't handle (which may or may not be ansi-compliant)
                              if has("conceal")
                               syn match ansiSuppress	conceal	'\e\[[0-9;]*[A-Za-z]'
                               syn match ansiSuppress	conceal	'\e\[?\d*[A-Za-z]'
                               syn match ansiSuppress	conceal	'\b'
                              else
                               syn match ansiSuppress		'\e\[[0-9;]*[A-Za-z]'
                               syn match ansiSuppress		'\e\[?\d*[A-Za-z]'
                               syn match ansiSuppress		'\b'
                              endif
                            
                              " ------------------------------
                              " Ansi Escape Sequence Handling: {{{2
                              " ------------------------------
                              syn region ansiNone		start="\e\[[01;]m"           skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiNone		start="\e\[m"                skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiNone		start="\e\[\%(0;\)\=39;49m"  skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiNone		start="\e\[\%(0;\)\=49;39m"  skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiNone		start="\e\[\%(0;\)\=39m"     skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiNone		start="\e\[\%(0;\)\=49m"     skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiNone		start="\e\[\%(0;\)\=22m"     skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              " disable bold/italic/etc. - no way to disable one attribute, so disable them all
                              syn region ansiNone		start="\e\[\%(0;\)\=23m"     skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiNone		start="\e\[\%(0;\)\=24m"     skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiNone		start="\e\[\%(0;\)\=27m"     skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiNone		start="\e\[\%(0;\)\=29m"     skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                            
                              syn region ansiBlack		start="\e\[;\=0\{0,2};\=30m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiRed		start="\e\[;\=0\{0,2};\=31m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiGreen		start="\e\[;\=0\{0,2};\=32m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiYellow		start="\e\[;\=0\{0,2};\=33m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiBlue		start="\e\[;\=0\{0,2};\=34m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiMagenta	start="\e\[;\=0\{0,2};\=35m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiCyan		start="\e\[;\=0\{0,2};\=36m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiWhite		start="\e\[;\=0\{0,2};\=37m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiGray		start="\e\[;\=0\{0,2};\=90m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              " set default ansi to white
                              syn region ansiWhite		start="\e\[;\=0\{0,2};\=39m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                            
                              syn region ansiBold     	start="\e\[;\=0\{0,2};\=1m"                      skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiBoldBlack	start="\e\[;\=0\{0,2};\=\%(1;30\|30;0\{0,2}1\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              " this is supposed to be bold-black, ie, dark grey, but it doesn't work well
                              " on a lot of displays. We'll settle for non-bold white
                              syn region ansiWhite	        start="\e\[;\=0\{0,2};\=90m"                     skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiBoldRed	start="\e\[;\=0\{0,2};\=\%(1;31\|31;0\{0,2}1\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiBoldRed        start="\e\[;\=0\{0,2};\=91m"                     skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiBoldGreen	start="\e\[;\=0\{0,2};\=\%(1;32\|32;0\{0,2}1\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiBoldGreen      start="\e\[;\=0\{0,2};\=92m"                     skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiBoldYellow	start="\e\[;\=0\{0,2};\=\%(1;33\|33;0\{0,2}1\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiBoldYellow     start="\e\[;\=0\{0,2};\=93m"                     skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiBoldBlue	start="\e\[;\=0\{0,2};\=\%(1;34\|34;0\{0,2}1\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiBoldBlue       start="\e\[;\=0\{0,2};\=94m"                     skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiBoldMagenta	start="\e\[;\=0\{0,2};\=\%(1;35\|35;0\{0,2}1\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiBoldMagenta    start="\e\[;\=0\{0,2};\=95m"                     skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiBoldCyan	start="\e\[;\=0\{0,2};\=\%(1;36\|36;0\{0,2}1\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiBoldCyan       start="\e\[;\=0\{0,2};\=96m"                     skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiBoldWhite	start="\e\[;\=0\{0,2};\=\%(1;37\|37;0\{0,2}1\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiBoldWhite	start="\e\[;\=0\{0,2};\=\%(1;39\|39;0\{0,2}1\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiBoldWhite      start="\e\[;\=0\{0,2};\=97m"                     skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiBoldGray	start="\e\[;\=0\{0,2};\=\%(1;90\|90;0\{0,2}1\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                            
                              syn region ansiStandout     	        start="\e\[;\=0\{0,2};\=\%(1;\)\=3m"                      skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiStandoutBlack	        start="\e\[;\=0\{0,2};\=\%(1;\)\=\%(3;30\|30;0\{0,2}3\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiStandoutRed	        start="\e\[;\=0\{0,2};\=\%(1;\)\=\%(3;31\|31;0\{0,2}3\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiStandoutGreen	        start="\e\[;\=0\{0,2};\=\%(1;\)\=\%(3;32\|32;0\{0,2}3\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiStandoutYellow	        start="\e\[;\=0\{0,2};\=\%(1;\)\=\%(3;33\|33;0\{0,2}3\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiStandoutBlue	        start="\e\[;\=0\{0,2};\=\%(1;\)\=\%(3;34\|34;0\{0,2}3\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiStandoutMagenta	start="\e\[;\=0\{0,2};\=\%(1;\)\=\%(3;35\|35;0\{0,2}3\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiStandoutCyan	        start="\e\[;\=0\{0,2};\=\%(1;\)\=\%(3;36\|36;0\{0,2}3\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiStandoutWhite	        start="\e\[;\=0\{0,2};\=\%(1;\)\=\%(3;37\|37;0\{0,2}3\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiStandoutGray	        start="\e\[;\=0\{0,2};\=\%(1;\)\=\%(3;90\|90;0\{0,2}3\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                            
                              syn region ansiItalic     	start="\e\[;\=0\{0,2};\=\%(1;\)\=2m"                      skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiItalicBlack	start="\e\[;\=0\{0,2};\=\%(1;\)\=\%(2;30\|30;0\{0,2}2\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiItalicRed	start="\e\[;\=0\{0,2};\=\%(1;\)\=\%(2;31\|31;0\{0,2}2\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiItalicGreen	start="\e\[;\=0\{0,2};\=\%(1;\)\=\%(2;32\|32;0\{0,2}2\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiItalicYellow	start="\e\[;\=0\{0,2};\=\%(1;\)\=\%(2;33\|33;0\{0,2}2\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiItalicBlue	start="\e\[;\=0\{0,2};\=\%(1;\)\=\%(2;34\|34;0\{0,2}2\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiItalicMagenta	start="\e\[;\=0\{0,2};\=\%(1;\)\=\%(2;35\|35;0\{0,2}2\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiItalicCyan	start="\e\[;\=0\{0,2};\=\%(1;\)\=\%(2;36\|36;0\{0,2}2\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiItalicWhite	start="\e\[;\=0\{0,2};\=\%(1;\)\=\%(2;37\|37;0\{0,2}2\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiItalicGray	start="\e\[;\=0\{0,2};\=\%(1;\)\=\%(2;90\|90;0\{0,2}2\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                            
                              syn region ansiUnderline	        start="\e\[;\=0\{0,2};\=\%(1;\)\=4m"                      skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiUnderlineBlack	        start="\e\[;\=0\{0,2};\=\%(1;\)\=\%(4;30\|30;0\{0,2}4\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiUnderlineRed	        start="\e\[;\=0\{0,2};\=\%(1;\)\=\%(4;31\|31;0\{0,2}4\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiUnderlineGreen	        start="\e\[;\=0\{0,2};\=\%(1;\)\=\%(4;32\|32;0\{0,2}4\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiUnderlineYellow	start="\e\[;\=0\{0,2};\=\%(1;\)\=\%(4;33\|33;0\{0,2}4\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiUnderlineBlue	        start="\e\[;\=0\{0,2};\=\%(1;\)\=\%(4;34\|34;0\{0,2}4\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiUnderlineMagenta	start="\e\[;\=0\{0,2};\=\%(1;\)\=\%(4;35\|35;0\{0,2}4\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiUnderlineCyan	        start="\e\[;\=0\{0,2};\=\%(1;\)\=\%(4;36\|36;0\{0,2}4\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiUnderlineWhite	        start="\e\[;\=0\{0,2};\=\%(1;\)\=\%(4;37\|37;0\{0,2}4\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiUnderlineGray	        start="\e\[;\=0\{0,2};\=\%(1;\)\=\%(4;90\|90;0\{0,2}4\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                            
                              syn region ansiBlink          start="\e\[;\=0\{0,2};\=\%(1;\)\=5m"                      skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiBlinkBlack	start="\e\[;\=0\{0,2};\=\%(1;\)\=\%(5;30\|30;0\{0,2}5\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiBlinkRed	start="\e\[;\=0\{0,2};\=\%(1;\)\=\%(5;31\|31;0\{0,2}5\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiBlinkGreen	start="\e\[;\=0\{0,2};\=\%(1;\)\=\%(5;32\|32;0\{0,2}5\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiBlinkYellow	start="\e\[;\=0\{0,2};\=\%(1;\)\=\%(5;33\|33;0\{0,2}5\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiBlinkBlue	start="\e\[;\=0\{0,2};\=\%(1;\)\=\%(5;34\|34;0\{0,2}5\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiBlinkMagenta	start="\e\[;\=0\{0,2};\=\%(1;\)\=\%(5;35\|35;0\{0,2}5\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiBlinkCyan	start="\e\[;\=0\{0,2};\=\%(1;\)\=\%(5;36\|36;0\{0,2}5\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiBlinkWhite	start="\e\[;\=0\{0,2};\=\%(1;\)\=\%(5;37\|37;0\{0,2}5\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiBlinkGray	start="\e\[;\=0\{0,2};\=\%(1;\)\=\%(5;90\|90;0\{0,2}5\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                            
                              syn region ansiRapidBlink	        start="\e\[;\=0\{0,2};\=\%(1;\)\=6m"                      skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiRapidBlinkBlack	start="\e\[;\=0\{0,2};\=\%(1;\)\=\%(6;30\|30;0\{0,2}6\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiRapidBlinkRed	        start="\e\[;\=0\{0,2};\=\%(1;\)\=\%(6;31\|31;0\{0,2}6\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiRapidBlinkGreen	start="\e\[;\=0\{0,2};\=\%(1;\)\=\%(6;32\|32;0\{0,2}6\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiRapidBlinkYellow	start="\e\[;\=0\{0,2};\=\%(1;\)\=\%(6;33\|33;0\{0,2}6\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiRapidBlinkBlue	        start="\e\[;\=0\{0,2};\=\%(1;\)\=\%(6;34\|34;0\{0,2}6\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiRapidBlinkMagenta	start="\e\[;\=0\{0,2};\=\%(1;\)\=\%(6;35\|35;0\{0,2}6\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiRapidBlinkCyan	        start="\e\[;\=0\{0,2};\=\%(1;\)\=\%(6;36\|36;0\{0,2}6\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiRapidBlinkWhite	start="\e\[;\=0\{0,2};\=\%(1;\)\=\%(6;37\|37;0\{0,2}6\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiRapidBlinkGray	        start="\e\[;\=0\{0,2};\=\%(1;\)\=\%(6;90\|90;0\{0,2}6\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                            
                              syn region ansiRV	        start="\e\[;\=0\{0,2};\=\%(1;\)\=7m"                      skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiRVBlack	start="\e\[;\=0\{0,2};\=\%(1;\)\=\%(7;30\|30;0\{0,2}7\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiRVRed		start="\e\[;\=0\{0,2};\=\%(1;\)\=\%(7;31\|31;0\{0,2}7\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiRVGreen	start="\e\[;\=0\{0,2};\=\%(1;\)\=\%(7;32\|32;0\{0,2}7\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiRVYellow	start="\e\[;\=0\{0,2};\=\%(1;\)\=\%(7;33\|33;0\{0,2}7\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiRVBlue		start="\e\[;\=0\{0,2};\=\%(1;\)\=\%(7;34\|34;0\{0,2}7\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiRVMagenta	start="\e\[;\=0\{0,2};\=\%(1;\)\=\%(7;35\|35;0\{0,2}7\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiRVCyan		start="\e\[;\=0\{0,2};\=\%(1;\)\=\%(7;36\|36;0\{0,2}7\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiRVWhite	start="\e\[;\=0\{0,2};\=\%(1;\)\=\%(7;37\|37;0\{0,2}7\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiRVGray		start="\e\[;\=0\{0,2};\=\%(1;\)\=\%(7;90\|90;0\{0,2}7\)m" skip='\e\[K' end="\e\["me=e-2 contains=ansiConceal
                            
                              if v:version >= 703
                            "   "-----------------------------------------
                            "   " handles implicit background highlighting
                            "   "-----------------------------------------
                            "   call Decho("installing implicit background highlighting")
                            
                               syn cluster AnsiDefaultBgGroup contains=ansiBgBoldDefault,ansiBgUnderlineDefault,ansiBgDefaultDefault,ansiBgBlackDefault,ansiBgRedDefault,ansiBgGreenDefault,ansiBgYellowDefault,ansiBgBlueDefault,ansiBgMagentaDefault,ansiBgCyanDefault,ansiBgWhiteDefault,ansiBgGrayDefault
                               syn region ansiDefaultBg	concealends	matchgroup=ansiNone start="\e\[;\=0\{0,2};\=\%(0\{0,2};\)\=49\%(0\{0,2};\)\=m" skip='\e\[K' end="\e\[[04m]"me=e-3  contains=@AnsiDefaultBgGroup,ansiConceal
                               syn region ansiBgBoldDefault     contained	start="\e\[1m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(22\|0*\)\=m"  contains=ansiConceal
                               syn region ansiBgUnderlineDefault contained	start="\e\[4m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(24\|0*\)\=m"  contains=ansiConceal
                               syn region ansiBgDefaultDefault	contained	start="\e\[39m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiBgBlackDefault	contained	start="\e\[30m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiBgRedDefault	contained	start="\e\[31m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiBgGreenDefault	contained	start="\e\[32m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiBgYellowDefault	contained	start="\e\[33m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiBgBlueDefault	contained	start="\e\[34m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiBgMagentaDefault	contained	start="\e\[35m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiBgCyanDefault	contained	start="\e\[36m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiBgWhiteDefault	contained	start="\e\[37m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiBgGrayDefault	contained	start="\e\[90m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               hi link ansiBgBoldDefault        ansiBold
                               hi link ansiBgUnderlineDefault   ansiUnderline
                               hi link ansiBgDefaultDefault	ansiDefaultDefault
                               hi link ansiBgBlackDefault	ansiBlackDefault
                               hi link ansiBgRedDefault	ansiRedDefault
                               hi link ansiBgGreenDefault	ansiGreenDefault
                               hi link ansiBgYellowDefault	ansiYellowDefault
                               hi link ansiBgBlueDefault	ansiBlueDefault
                               hi link ansiBgMagentaDefault	ansiMagentaDefault
                               hi link ansiBgCyanDefault	ansiCyanDefault
                               hi link ansiBgWhiteDefault	ansiWhiteDefault
                               hi link ansiBgGrayDefault	ansiGrayDefault
                            
                               syn cluster AnsiBlackBgGroup contains=ansiBgBoldBlack,ansiBgUnderlineBlack,ansiBgDefaultBlack,ansiBgBlackBlack,ansiBgRedBlack,ansiBgGreenBlack,ansiBgYellowBlack,ansiBgBlueBlack,ansiBgMagentaBlack,ansiBgCyanBlack,ansiBgWhiteBlack,ansiBgGrayBlack
                               syn region ansiBlackBg	concealends	matchgroup=ansiNone start="\e\[;\=0\{0,2};\=\%(1;\)\=40\%(;1\)\=m" skip='\e\[K' end="\e\[\%(0*;*\)\=49m\|\ze\e\[[04m]"  contains=@AnsiBlackBgGroup,ansiConceal
                               syn region ansiBgBoldBlack	contained	start="\e\[1m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(22\|0*\)\=m"  contains=ansiConceal
                               syn region ansiBgUnderlineBlack	contained	start="\e\[4m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(24\|0*\)\=m"  contains=ansiConceal
                               syn region ansiBgDefaultBlack	contained	start="\e\[39m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiBgBlackBlack	contained	start="\e\[30m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiBgRedBlack	contained	start="\e\[31m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiBgGreenBlack	contained	start="\e\[32m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiBgYellowBlack	contained	start="\e\[33m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiBgBlueBlack	contained	start="\e\[34m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiBgMagentaBlack	contained	start="\e\[35m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiBgCyanBlack	contained	start="\e\[36m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiBgWhiteBlack	contained	start="\e\[37m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiBgGrayBlack	contained	start="\e\[90m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               hi link ansiBgBoldBlack          ansiBoldBlack
                               hi link ansiBgUnderlineBlack     ansiUnderlineBlack
                               hi link ansiBgDefaultBlack       ansiDefaultBlack
                               hi link ansiBgBlackBlack	ansiBlackBlack
                               hi link ansiBgRedBlack	ansiRedBlack
                               hi link ansiBgGreenBlack	ansiGreenBlack
                               hi link ansiBgYellowBlack	ansiYellowBlack
                               hi link ansiBgBlueBlack	ansiBlueBlack
                               hi link ansiBgMagentaBlack	ansiMagentaBlack
                               hi link ansiBgCyanBlack	ansiCyanBlack
                               hi link ansiBgWhiteBlack	ansiWhiteBlack
                               hi link ansiBgGrayBlack	ansiGrayBlack
                            
                               syn cluster AnsiRedBgGroup contains=ansiBgBoldRed,ansiBgUnderlineRed,ansiBgDefaultRed,ansiBgBlackRed,ansiBgRedRed,ansiBgGreenRed,ansiBgYellowRed,ansiBgBlueRed,ansiBgMagentaRed,ansiBgCyanRed,ansiBgWhiteRed,ansiBgGrayRed
                               syn region ansiRedBg		concealends matchgroup=ansiNone start="\e\[;\=0\{0,2};\=\%(1;\)\=41\%(;1\)\=m" skip='\e\[K' end="\e\[\%(0*;*\)\=49m\|\ze\e\[[04m]"  contains=@AnsiRedBgGroup,ansiConceal
                               syn region ansiBgBoldRed	contained	start="\e\[1m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(22\|0*\)\=m"  contains=ansiConceal
                               syn region ansiBgUnderlineRed	contained	start="\e\[4m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(24\|0*\)\=m"  contains=ansiConceal
                               syn region ansiBgDefaultRed	contained	start="\e\[39m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiBgBlackRed	contained	start="\e\[30m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgRedRed	contained	start="\e\[31m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgGreenRed	contained	start="\e\[32m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgYellowRed	contained	start="\e\[33m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgBlueRed	contained	start="\e\[34m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgMagentaRed	contained	start="\e\[35m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgCyanRed	contained	start="\e\[36m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgWhiteRed	contained	start="\e\[37m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgGrayRed	contained	start="\e\[90m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               hi link ansiBgBoldRed            ansiBoldRed
                               hi link ansiBgUnderlineRed       ansiUnderlineRed
                               hi link ansiBgDefaultRed         ansiDefaultRed
                               hi link ansiBgBlackRed	ansiBlackRed
                               hi link ansiBgRedRed		ansiRedRed
                               hi link ansiBgGreenRed	ansiGreenRed
                               hi link ansiBgYellowRed	ansiYellowRed
                               hi link ansiBgBlueRed	ansiBlueRed
                               hi link ansiBgMagentaRed	ansiMagentaRed
                               hi link ansiBgCyanRed	ansiCyanRed
                               hi link ansiBgWhiteRed	ansiWhiteRed
                               hi link ansiBgGrayRed	ansiGrayRed
                            
                               syn cluster AnsiGreenBgGroup contains=ansiBgBoldGreen,ansiBgUnderlineGreen,ansiBgDefaultGreen,ansiBgBlackGreen,ansiBgRedGreen,ansiBgGreenGreen,ansiBgYellowGreen,ansiBgBlueGreen,ansiBgMagentaGreen,ansiBgCyanGreen,ansiBgWhiteGreen,ansiBgGrayGreen
                               syn region ansiGreenBg	concealends matchgroup=ansiNone start="\e\[;\=0\{0,2};\=\%(1;\)\=42\%(;1\)\=m" skip='\e\[K' end="\e\[\%(0*;*\)\=49m\|\ze\e\[[04m]"  contains=@AnsiGreenBgGroup,ansiConceal
                               syn region ansiBgBoldGreen	contained	start="\e\[1m"  skip='\e\[K'  end="\ze\e\[\%(0*;*\)\=\%(22\|0*\)\=m" contains=ansiConceal
                               syn region ansiBgUnderlineGreen	contained	start="\e\[4m"  skip='\e\[K'  end="\ze\e\[\%(0*;*\)\=\%(24\|0*\)\=m" contains=ansiConceal
                               syn region ansiBgDefaultGreen	contained	start="\e\[39m" skip='\e\[K'  end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgBlackGreen	contained	start="\e\[30m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgRedGreen	contained	start="\e\[31m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgGreenGreen	contained	start="\e\[32m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgYellowGreen	contained	start="\e\[33m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgBlueGreen	contained	start="\e\[34m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgMagentaGreen	contained	start="\e\[35m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgCyanGreen	contained	start="\e\[36m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgWhiteGreen	contained	start="\e\[37m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgGrayGreen	contained	start="\e\[90m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               hi link ansiBgBoldGreen          ansiBoldGreen
                               hi link ansiBgUnderlineGreen     ansiUnderlineGreen
                               hi link ansiBgDefaultGreen       ansiDefaultGreen
                               hi link ansiBgBlackGreen	ansiBlackGreen
                               hi link ansiBgGreenGreen	ansiGreenGreen
                               hi link ansiBgRedGreen	ansiRedGreen
                               hi link ansiBgYellowGreen	ansiYellowGreen
                               hi link ansiBgBlueGreen	ansiBlueGreen
                               hi link ansiBgMagentaGreen	ansiMagentaGreen
                               hi link ansiBgCyanGreen	ansiCyanGreen
                               hi link ansiBgWhiteGreen	ansiWhiteGreen
                               hi link ansiBgGrayGreen	ansiGrayGreen
                            
                               syn cluster AnsiYellowBgGroup contains=ansiBgBoldYellow,ansiBgUnderlineYellow,ansiBgDefaultYellow,ansiBgBlackYellow,ansiBgRedYellow,ansiBgGreenYellow,ansiBgYellowYellow,ansiBgBlueYellow,ansiBgMagentaYellow,ansiBgCyanYellow,ansiBgWhiteYellow,ansiBgGrayYellow
                               syn region ansiYellowBg	concealends matchgroup=ansiNone start="\e\[;\=0\{0,2};\=\%(1;\)\=43\%(;1\)\=m" skip='\e\[K' end="\e\[\%(0*;*\)\=49m\|\ze\e\[[04m]"  contains=@AnsiYellowBgGroup,ansiConceal
                               syn region ansiBgBoldYellow	contained	start="\e\[1m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(22\|0*\)\=m" contains=ansiConceal
                               syn region ansiBgUnderlineYellow	contained	start="\e\[4m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(24\|0*\)\=m" contains=ansiConceal
                               syn region ansiBgDefaultYellow	contained	start="\e\[39m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgBlackYellow	contained	start="\e\[30m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgRedYellow	contained	start="\e\[31m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgGreenYellow	contained	start="\e\[32m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgYellowYellow	contained	start="\e\[33m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgBlueYellow	contained	start="\e\[34m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgMagentaYellow	contained	start="\e\[35m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgCyanYellow	contained	start="\e\[36m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgWhiteYellow	contained	start="\e\[37m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgGrayYellow	contained	start="\e\[90m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               hi link ansiBgBoldYellow         ansiBoldYellow
                               hi link ansiBgUnderlineYellow    ansiUnderlineYellow
                               hi link ansiBgDefaultYellow      ansiDefaultYellow
                               hi link ansiBgBlackYellow	ansiBlackYellow
                               hi link ansiBgRedYellow	ansiRedYellow
                               hi link ansiBgGreenYellow	ansiGreenYellow
                               hi link ansiBgYellowYellow	ansiYellowYellow
                               hi link ansiBgBlueYellow	ansiBlueYellow
                               hi link ansiBgMagentaYellow	ansiMagentaYellow
                               hi link ansiBgCyanYellow	ansiCyanYellow
                               hi link ansiBgWhiteYellow	ansiWhiteYellow
                               hi link ansiBgGrayYellow	ansiGrayYellow
                            
                               syn cluster AnsiBlueBgGroup contains=ansiBgBoldBlue,ansiBgUnderlineBlue,ansiBgDefaultBlue,ansiBgBlackBlue,ansiBgRedBlue,ansiBgGreenBlue,ansiBgYellowBlue,ansiBgBlueBlue,ansiBgMagentaBlue,ansiBgCyanBlue,ansiBgWhiteBlue,ansiBgGrayBlue
                               syn region ansiBlueBg	concealends matchgroup=ansiNone start="\e\[;\=0\{0,2};\=\%(1;\)\=44\%(;1\)\=m" skip='\e\[K' end="\e\[\%(0*;*\)\=49m\|\ze\e\[[04m]"  contains=@AnsiBlueBgGroup,ansiConceal
                               syn region ansiBgBoldBlue	contained	start="\e\[1m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(22\|0*\)\=m" contains=ansiConceal
                               syn region ansiBgUnderlineBlue	contained	start="\e\[4m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(24\|0*\)\=m" contains=ansiConceal
                               syn region ansiBgDefaultBlue	contained	start="\e\[39m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgBlackBlue	contained	start="\e\[30m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgRedBlue	contained	start="\e\[31m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgGreenBlue	contained	start="\e\[32m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgYellowBlue	contained	start="\e\[33m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgBlueBlue	contained	start="\e\[34m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgMagentaBlue	contained	start="\e\[35m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgCyanBlue	contained	start="\e\[36m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgWhiteBlue	contained	start="\e\[37m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgGrayBlue	contained	start="\e\[90m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               hi link ansiBgBoldBlue           ansiBoldBlue
                               hi link ansiBgUnderlineBlue      ansiUnderlineBlue
                               hi link ansiBgDefaultBlue	ansiDefaultBlue
                               hi link ansiBgBlackBlue	ansiBlackBlue
                               hi link ansiBgRedBlue	ansiRedBlue
                               hi link ansiBgGreenBlue	ansiGreenBlue
                               hi link ansiBgYellowBlue	ansiYellowBlue
                               hi link ansiBgBlueBlue	ansiBlueBlue
                               hi link ansiBgMagentaBlue	ansiMagentaBlue
                               hi link ansiBgCyanBlue	ansiCyanBlue
                               hi link ansiBgWhiteBlue	ansiWhiteBlue
                               hi link ansiBgGrayBlue	ansiGrayBlue
                            
                               syn cluster AnsiMagentaBgGroup contains=ansiBgBoldMagenta,ansiBgUnderlineMagenta,ansiBgDefaultMagenta,ansiBgBlackMagenta,ansiBgRedMagenta,ansiBgGreenMagenta,ansiBgYellowMagenta,ansiBgBlueMagenta,ansiBgMagentaMagenta,ansiBgCyanMagenta,ansiBgWhiteMagenta,ansiBgGrayMagenta
                               syn region ansiMagentaBg	concealends matchgroup=ansiNone start="\e\[;\=0\{0,2};\=\%(1;\)\=45\%(;1\)\=m" skip='\e\[K' end="\e\[\%(0*;*\)\=49m\|\ze\e\[[04m]"  contains=@AnsiMagentaBgGroup,ansiConceal
                               syn region ansiBgBoldMagenta      contained	start="\e\[1m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(22\|0*\)\=m" contains=ansiConceal
                               syn region ansiBgUnderlineMagenta contained	start="\e\[4m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(24\|0*\)\=m" contains=ansiConceal
                               syn region ansiBgDefaultMagenta	contained	start="\e\[39m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgBlackMagenta	contained	start="\e\[30m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgRedMagenta	contained	start="\e\[31m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgGreenMagenta	contained	start="\e\[32m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgYellowMagenta	contained	start="\e\[33m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgBlueMagenta	contained	start="\e\[34m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgMagentaMagenta	contained	start="\e\[35m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgCyanMagenta	contained	start="\e\[36m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgWhiteMagenta	contained	start="\e\[37m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgGrayMagenta	contained	start="\e\[90m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               hi link ansiBgBoldMagenta        ansiBoldMagenta
                               hi link ansiBgUnderlineMagenta   ansiUnderlineMagenta
                               hi link ansiBgDefaultMagenta	ansiDefaultMagenta
                               hi link ansiBgBlackMagenta	ansiBlackMagenta
                               hi link ansiBgRedMagenta	ansiRedMagenta
                               hi link ansiBgGreenMagenta	ansiGreenMagenta
                               hi link ansiBgYellowMagenta	ansiYellowMagenta
                               hi link ansiBgBlueMagenta	ansiBlueMagenta
                               hi link ansiBgMagentaMagenta	ansiMagentaMagenta
                               hi link ansiBgCyanMagenta	ansiCyanMagenta
                               hi link ansiBgWhiteMagenta	ansiWhiteMagenta
                               hi link ansiBgGrayMagenta	ansiGrayMagenta
                            
                               syn cluster AnsiCyanBgGroup contains=ansiBgBoldCyan,ansiBgUnderlineCyan,ansiBgDefaultCyan,ansiBgBlackCyan,ansiBgRedCyan,ansiBgGreenCyan,ansiBgYellowCyan,ansiBgBlueCyan,ansiBgMagentaCyan,ansiBgCyanCyan,ansiBgWhiteCyan,ansiBgGrayCyan
                               syn region ansiCyanBg	concealends matchgroup=ansiNone start="\e\[;\=0\{0,2};\=\%(1;\)\=46\%(;1\)\=m" skip='\e\[K' end="\e\[\%(0*;*\)\=49m\|\ze\e\[[04m]"  contains=@AnsiCyanBgGroup,ansiConceal
                               syn region ansiBgBoldCyan        contained	start="\e\[1m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(22\|0*\)\=m" contains=ansiConceal
                               syn region ansiBgUnderlineCyan   contained	start="\e\[4m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(24\|0*\)\=m" contains=ansiConceal
                               syn region ansiBgDefaultCyan	contained	start="\e\[39m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgBlackCyan	contained	start="\e\[30m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgRedCyan	contained	start="\e\[31m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgGreenCyan	contained	start="\e\[32m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgYellowCyan	contained	start="\e\[33m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgBlueCyan	contained	start="\e\[34m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgMagentaCyan	contained	start="\e\[35m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgCyanCyan	contained	start="\e\[36m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgWhiteCyan	contained	start="\e\[37m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgGrayCyan	contained	start="\e\[90m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               hi link ansiBgBoldCyan           ansiBoldCyan
                               hi link ansiBgUnderlineCyan      ansiUnderlineCyan
                               hi link ansiBgDefaultCyan	ansiDefaultCyan
                               hi link ansiBgBlackCyan	ansiBlackCyan
                               hi link ansiBgRedCyan	ansiRedCyan
                               hi link ansiBgGreenCyan	ansiGreenCyan
                               hi link ansiBgYellowCyan	ansiYellowCyan
                               hi link ansiBgBlueCyan	ansiBlueCyan
                               hi link ansiBgMagentaCyan	ansiMagentaCyan
                               hi link ansiBgCyanCyan	ansiCyanCyan
                               hi link ansiBgWhiteCyan	ansiWhiteCyan
                               hi link ansiBgGrayCyan	ansiGrayCyan
                            
                               syn cluster AnsiWhiteBgGroup contains=ansiBgBoldWhite,ansiBgUnderlineWhite,ansiBgDefaultWhite,ansiBgBlackWhite,ansiBgRedWhite,ansiBgGreenWhite,ansiBgYellowWhite,ansiBgBlueWhite,ansiBgMagentaWhite,ansiBgCyanWhite,ansiBgWhiteWhite,ansiBgGrayWhite
                               syn region ansiWhiteBg	concealends matchgroup=ansiNone start="\e\[;\=0\{0,2};\=\%(1;\)\=47\%(;1\)\=m" skip='\e\[K' end="\e\[\%(0*;*\)\=49m\|\ze\e\[[04m]"  contains=@AnsiWhiteBgGroup,ansiConceal
                               syn region ansiBgBoldWhite       contained	start="\e\[1m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(22\|0*\)\=m" contains=ansiConceal
                               syn region ansiBgUnderlineWhite  contained	start="\e\[4m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(24\|0*\)\=m" contains=ansiConceal
                               syn region ansiBgDefaultWhite	contained	start="\e\[39m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgBlackWhite	contained	start="\e\[30m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgRedWhite	contained	start="\e\[31m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgGreenWhite	contained	start="\e\[32m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgYellowWhite	contained	start="\e\[33m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgBlueWhite	contained	start="\e\[34m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgMagentaWhite	contained	start="\e\[35m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgCyanWhite	contained	start="\e\[36m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgWhiteWhite	contained	start="\e\[37m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               syn region ansiBgGrayWhite	contained	start="\e\[90m" skip='\e\[K' end="\e\[[03m]"me=e-3 contains=ansiConceal
                               hi link ansiBgBoldWhite          ansiBoldWhite
                               hi link ansiBgUnderlineWhite     ansiUnderlineWhite
                               hi link ansiBgDefaultWhite	ansiDefaultWhite
                               hi link ansiBgBlackWhite	ansiBlackWhite
                               hi link ansiBgRedWhite	ansiRedWhite
                               hi link ansiBgGreenWhite	ansiGreenWhite
                               hi link ansiBgYellowWhite	ansiYellowWhite
                               hi link ansiBgBlueWhite	ansiBlueWhite
                               hi link ansiBgMagentaWhite	ansiMagentaWhite
                               hi link ansiBgCyanWhite	ansiCyanWhite
                               hi link ansiBgWhiteWhite	ansiWhiteWhite
                               hi link ansiBgGrayWhite	ansiGrayWhite
                            
                               "-----------------------------------------
                               " handles implicit foreground highlighting
                               "-----------------------------------------
                            "   call Decho("installing implicit foreground highlighting")
                            
                               syn cluster AnsiDefaultFgGroup contains=ansiFgDefaultBold,ansiFgDefaultUnderline,ansiFgDefaultDefault,ansiFgDefaultBlack,ansiFgDefaultRed,ansiFgDefaultGreen,ansiFgDefaultYellow,ansiFgDefaultBlue,ansiFgDefaultMagenta,ansiFgDefaultCyan,ansiFgDefaultWhite
                               syn region ansiDefaultFg		concealends matchgroup=ansiNone start="\e\[;\=0\{0,2};\=\%(0;\)\=39\%(;0\)\=m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=@AnsiDefaultFgGroup,ansiConceal
                               syn region ansiFgDefaultBold	contained	start="\e\[1m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(22\|0*\)\=m" contains=ansiConceal
                               syn region ansiFgDefaultUnerline	contained	start="\e\[4m"  skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgDefaultDefault	contained	start="\e\[49m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgDefaultBlack	contained	start="\e\[40m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgDefaultRed	contained	start="\e\[41m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgDefaultGreen	contained	start="\e\[42m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgDefaultYellow	contained	start="\e\[43m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgDefaultBlue	contained	start="\e\[44m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgDefaultMagenta	contained	start="\e\[45m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgDefaultCyan	contained	start="\e\[46m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgDefaultWhite	contained	start="\e\[47m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               hi link ansiFgDefaultBold	ansiDefaultBold
                               hi link ansiFgDefaultUnderline	ansiDefaultUnderline
                               hi link ansiFgDefaultDefault	ansiDefaultDefault
                               hi link ansiFgDefaultBlack	ansiDefaultBlack
                               hi link ansiFgDefaultRed	ansiDefaultRed
                               hi link ansiFgDefaultGreen	ansiDefaultGreen
                               hi link ansiFgDefaultYellow	ansiDefaultYellow
                               hi link ansiFgDefaultBlue	ansiDefaultBlue
                               hi link ansiFgDefaultMagenta	ansiDefaultMagenta
                               hi link ansiFgDefaultCyan	ansiDefaultCyan
                               hi link ansiFgDefaultWhite	ansiDefaultWhite
                            
                               syn cluster AnsiBlackFgGroup contains=ansiFgBlackBold,ansiFgBlackUnderline,ansiFgBlackDefault,ansiFgBlackBlack,ansiFgBlackRed,ansiFgBlackGreen,ansiFgBlackYellow,ansiFgBlackBlue,ansiFgBlackMagenta,ansiFgBlackCyan,ansiFgBlackWhite
                               syn region ansiBlackFg	concealends	matchgroup=ansiNone start="\e\[;\=0\{0,2};\=\%(1;\)\=30\%(;1\)\=m" skip='\e\[K' end="\e\[\%(0*;*\)\=39m\|\ze\e\[[03m]"  contains=@AnsiBlackFgGroup,ansiConceal
                               syn region ansiFgBlackBold	contained	start="\e\[1m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(22\|0*\)\=m"  contains=ansiConceal
                               syn region ansiFgBlackUnerline	contained	start="\e\[4m"  skip='\e\[K' end="\e\[[04m]"me=e-3  contains=ansiConceal
                               syn region ansiFgBlackDefault	contained	start="\e\[49m" skip='\e\[K' end="\e\[[04m]"me=e-3  contains=ansiConceal
                               syn region ansiFgBlackBlack	contained	start="\e\[40m" skip='\e\[K' end="\e\[[04m]"me=e-3  contains=ansiConceal
                               syn region ansiFgBlackRed	contained	start="\e\[41m" skip='\e\[K' end="\e\[[04m]"me=e-3  contains=ansiConceal
                               syn region ansiFgBlackGreen	contained	start="\e\[42m" skip='\e\[K' end="\e\[[04m]"me=e-3  contains=ansiConceal
                               syn region ansiFgBlackYellow	contained	start="\e\[43m" skip='\e\[K' end="\e\[[04m]"me=e-3  contains=ansiConceal
                               syn region ansiFgBlackBlue	contained	start="\e\[44m" skip='\e\[K' end="\e\[[04m]"me=e-3  contains=ansiConceal
                               syn region ansiFgBlackMagenta	contained	start="\e\[45m" skip='\e\[K' end="\e\[[04m]"me=e-3  contains=ansiConceal
                               syn region ansiFgBlackCyan	contained	start="\e\[46m" skip='\e\[K' end="\e\[[04m]"me=e-3  contains=ansiConceal
                               syn region ansiFgBlackWhite	contained	start="\e\[47m" skip='\e\[K' end="\e\[[04m]"me=e-3  contains=ansiConceal
                               hi link ansiFgBlackBold	ansiBlackBold
                               hi link ansiFgBlackUnderline	ansiBlackUnderline
                               hi link ansiFgBlackDefault	ansiBlackDefault
                               hi link ansiFgBlackBlack	ansiBlackBlack
                               hi link ansiFgBlackRed	ansiBlackRed
                               hi link ansiFgBlackGreen	ansiBlackGreen
                               hi link ansiFgBlackYellow	ansiBlackYellow
                               hi link ansiFgBlackBlue	ansiBlackBlue
                               hi link ansiFgBlackMagenta	ansiBlackMagenta
                               hi link ansiFgBlackCyan	ansiBlackCyan
                               hi link ansiFgBlackWhite	ansiBlackWhite
                            
                               syn cluster AnsiRedFgGroup contains=ansiFgRedBold,ansiFgRedUnderline,ansiFgRedDefault,ansiFgRedBlack,ansiFgRedRed,ansiFgRedGreen,ansiFgRedYellow,ansiFgRedBlue,ansiFgRedMagenta,ansiFgRedCyan,ansiFgRedWhite
                               syn region ansiRedFg		concealends matchgroup=ansiNone start="\e\[;\=0\{0,2};\=\%(1;\)\=31\%(;1\)\=m" skip='\e\[K' end="\e\[\%(0*;*\)\=39m\|\ze\e\[[03m]"  contains=@AnsiRedFgGroup,ansiConceal
                               syn region ansiFgRedBold	contained	start="\e\[1m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(22\|0*\)\=m" contains=ansiConceal
                               syn region ansiFgRedUnderline	contained	start="\e\[4m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(24\|0*\)\=m" contains=ansiConceal
                               syn region ansiFgRedDefault	contained	start="\e\[49m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgRedBlack	contained	start="\e\[40m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgRedRed	contained	start="\e\[41m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgRedGreen	contained	start="\e\[42m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgRedYellow	contained	start="\e\[43m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgRedBlue	contained	start="\e\[44m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgRedMagenta	contained	start="\e\[45m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgRedCyan	contained	start="\e\[46m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgRedWhite	contained	start="\e\[47m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               hi link ansiFgRedBold	ansiRedBold
                               hi link ansiFgRedUnderline	ansiRedUnderline
                               hi link ansiFgRedDefault	ansiRedDefault
                               hi link ansiFgRedBlack	ansiRedBlack
                               hi link ansiFgRedRed		ansiRedRed
                               hi link ansiFgRedGreen	ansiRedGreen
                               hi link ansiFgRedYellow	ansiRedYellow
                               hi link ansiFgRedBlue	ansiRedBlue
                               hi link ansiFgRedMagenta	ansiRedMagenta
                               hi link ansiFgRedCyan	ansiRedCyan
                               hi link ansiFgRedWhite	ansiRedWhite
                            
                               syn cluster AnsiGreenFgGroup contains=ansiFgGreenBold,ansiFgGreenUnderline,ansiFgGreenDefault,ansiFgGreenBlack,ansiFgGreenRed,ansiFgGreenGreen,ansiFgGreenYellow,ansiFgGreenBlue,ansiFgGreenMagenta,ansiFgGreenCyan,ansiFgGreenWhite
                               syn region ansiGreenFg	concealends matchgroup=ansiNone start="\e\[;\=0\{0,2};\=\%(1;\)\=32\%(;1\)\=m" skip='\e\[K' end="\e\[\%(0*;*\)\=39m\|\ze\e\[[03m]"  contains=@AnsiGreenFgGroup,ansiConceal
                               syn region ansiFgGreenBold	contained	start="\e\[1m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(22\|0*\)\=m" contains=ansiConceal
                               syn region ansiFgGreenUnderline	contained	start="\e\[4m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(24\|0*\)\=m" contains=ansiConceal
                               syn region ansiFgGreenDefault	contained	start="\e\[49m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgGreenBlack	contained	start="\e\[40m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgGreenRed	contained	start="\e\[41m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgGreenGreen	contained	start="\e\[42m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgGreenYellow	contained	start="\e\[43m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgGreenBlue	contained	start="\e\[44m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgGreenMagenta	contained	start="\e\[45m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgGreenCyan	contained	start="\e\[46m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgGreenWhite	contained	start="\e\[47m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               hi link ansiFgGreenBold	ansiGreenBold
                               hi link ansiFgGreenUnderline	ansiGreenUnderline
                               hi link ansiFgGreenDefault	ansiGreenDefault
                               hi link ansiFgGreenBlack	ansiGreenBlack
                               hi link ansiFgGreenGreen	ansiGreenGreen
                               hi link ansiFgGreenRed	ansiGreenRed
                               hi link ansiFgGreenYellow	ansiGreenYellow
                               hi link ansiFgGreenBlue	ansiGreenBlue
                               hi link ansiFgGreenMagenta	ansiGreenMagenta
                               hi link ansiFgGreenCyan	ansiGreenCyan
                               hi link ansiFgGreenWhite	ansiGreenWhite
                            
                               syn cluster AnsiYellowFgGroup contains=ansiFgYellowBold,ansiFgYellowUnderline,ansiFgYellowDefault,ansiFgYellowBlack,ansiFgYellowRed,ansiFgYellowGreen,ansiFgYellowYellow,ansiFgYellowBlue,ansiFgYellowMagenta,ansiFgYellowCyan,ansiFgYellowWhite
                               syn region ansiYellowFg	concealends matchgroup=ansiNone start="\e\[;\=0\{0,2};\=\%(1;\)\=33\%(;1\)\=m" skip='\e\[K' end="\e\[\%(0*;*\)\=39m\|\ze\e\[[03m]"  contains=@AnsiYellowFgGroup,ansiConceal
                               syn region ansiFgYellowBold	contained	start="\e\[1m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(22\|0*\)\=m" contains=ansiConceal
                               syn region ansiFgYellowUnderline	contained	start="\e\[4m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(24\|0*\)\=m" contains=ansiConceal
                               syn region ansiFgYellowDefault	contained	start="\e\[49m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgYellowBlack	contained	start="\e\[40m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgYellowRed	contained	start="\e\[41m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgYellowGreen	contained	start="\e\[42m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgYellowYellow	contained	start="\e\[43m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgYellowBlue	contained	start="\e\[44m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgYellowMagenta	contained	start="\e\[45m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgYellowCyan	contained	start="\e\[46m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgYellowWhite	contained	start="\e\[47m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               hi link ansiFgYellowBold	ansiYellowBold
                               hi link ansiFgYellowUnderline	ansiYellowUnderline
                               hi link ansiFgYellowDefault	ansiYellowDefault
                               hi link ansiFgYellowBlack	ansiYellowBlack
                               hi link ansiFgYellowRed	ansiYellowRed
                               hi link ansiFgYellowGreen	ansiYellowGreen
                               hi link ansiFgYellowYellow	ansiYellowYellow
                               hi link ansiFgYellowBlue	ansiYellowBlue
                               hi link ansiFgYellowMagenta	ansiYellowMagenta
                               hi link ansiFgYellowCyan	ansiYellowCyan
                               hi link ansiFgYellowWhite	ansiYellowWhite
                            
                               syn cluster AnsiBlueFgGroup contains=ansiFgBlueBold,ansiFgBlueUnderline,ansiFgBlueDefault,ansiFgBlueBlack,ansiFgBlueRed,ansiFgBlueGreen,ansiFgBlueYellow,ansiFgBlueBlue,ansiFgBlueMagenta,ansiFgBlueCyan,ansiFgBlueWhite
                               syn region ansiBlueFg	concealends matchgroup=ansiNone start="\e\[;\=0\{0,2};\=\%(1;\)\=34\%(;1\)\=m" skip='\e\[K' end="\e\[\%(0*;*\)\=39m\|\ze\e\[[03m]"  contains=@AnsiBlueFgGroup,ansiConceal
                               syn region ansiFgBlueBold	contained	start="\e\[1m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(22\|0*\)\=m" contains=ansiConceal
                               syn region ansiFgBlueUnderline	contained	start="\e\[4m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(24\|0*\)\=m" contains=ansiConceal
                               syn region ansiFgBlueDefault	contained	start="\e\[49m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgBlueBlack	contained	start="\e\[40m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgBlueRed	contained	start="\e\[41m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgBlueGreen	contained	start="\e\[42m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgBlueYellow	contained	start="\e\[43m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgBlueBlue	contained	start="\e\[44m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgBlueMagenta	contained	start="\e\[45m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgBlueCyan	contained	start="\e\[46m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgBlueWhite	contained	start="\e\[47m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               hi link ansiFgBlueBold	ansiBlueBold
                               hi link ansiFgBlueUnderline	ansiBlueUnderline
                               hi link ansiFgBlueDefault	ansiBlueDefault
                               hi link ansiFgBlueBlack	ansiBlueBlack
                               hi link ansiFgBlueRed	ansiBlueRed
                               hi link ansiFgBlueGreen	ansiBlueGreen
                               hi link ansiFgBlueYellow	ansiBlueYellow
                               hi link ansiFgBlueBlue	ansiBlueBlue
                               hi link ansiFgBlueMagenta	ansiBlueMagenta
                               hi link ansiFgBlueCyan	ansiBlueCyan
                               hi link ansiFgBlueWhite	ansiBlueWhite
                            
                               syn cluster AnsiMagentaFgGroup contains=ansiFgMagentaBold,ansiFgMagentaUnderline,ansiFgMagentaDefault,ansiFgMagentaBlack,ansiFgMagentaRed,ansiFgMagentaGreen,ansiFgMagentaYellow,ansiFgMagentaBlue,ansiFgMagentaMagenta,ansiFgMagentaCyan,ansiFgMagentaWhite
                               syn region ansiMagentaFg	concealends matchgroup=ansiNone start="\e\[;\=0\{0,2};\=\%(1;\)\=35\%(;1\)\=m" skip='\e\[K' end="\e\[\%(0*;*\)\=39m\|\ze\e\[[03m]"  contains=@AnsiMagentaFgGroup,ansiConceal
                               syn region ansiFgMagentaBold	contained	start="\e\[1m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(22\|0*\)\=m" contains=ansiConceal
                               syn region ansiFgMagentaUnderline contained	start="\e\[4m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(24\|0*\)\=m" contains=ansiConceal
                               syn region ansiFgMagentaDefault	contained	start="\e\[49m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgMagentaBlack	contained	start="\e\[40m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgMagentaRed	contained	start="\e\[41m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgMagentaGreen	contained	start="\e\[42m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgMagentaYellow	contained	start="\e\[43m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgMagentaBlue	contained	start="\e\[44m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgMagentaMagenta	contained	start="\e\[45m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgMagentaCyan	contained	start="\e\[46m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgMagentaWhite	contained	start="\e\[47m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               hi link ansiFgMagentaBold	ansiMagentaBold
                               hi link ansiFgMagentaUnderline	ansiMagentaUnderline
                               hi link ansiFgMagentaDefault	ansiMagentaDefault
                               hi link ansiFgMagentaBlack	ansiMagentaBlack
                               hi link ansiFgMagentaRed	ansiMagentaRed
                               hi link ansiFgMagentaGreen	ansiMagentaGreen
                               hi link ansiFgMagentaYellow	ansiMagentaYellow
                               hi link ansiFgMagentaBlue	ansiMagentaBlue
                               hi link ansiFgMagentaMagenta	ansiMagentaMagenta
                               hi link ansiFgMagentaCyan	ansiMagentaCyan
                               hi link ansiFgMagentaWhite	ansiMagentaWhite
                            
                               syn cluster AnsiCyanFgGroup contains=ansiFgCyanBold,ansiFgCyanUnderline,ansiFgCyanDefault,ansiFgCyanBlack,ansiFgCyanRed,ansiFgCyanGreen,ansiFgCyanYellow,ansiFgCyanBlue,ansiFgCyanMagenta,ansiFgCyanCyan,ansiFgCyanWhite
                               syn region ansiCyanFg	concealends matchgroup=ansiNone start="\e\[;\=0\{0,2};\=\%(1;\)\=36\%(;1\)\=m" skip='\e\[K' end="\e\[\%(0*;*\)\=39m\|\ze\e\[[03m]"  contains=@AnsiCyanFgGroup,ansiConceal
                               syn region ansiFgCyanBold	contained	start="\e\[1m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(22\|0*\)\=m" contains=ansiConceal
                               syn region ansiFgCyanUnderline contained	start="\e\[4m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(24\|0*\)\=m" contains=ansiConceal
                               syn region ansiFgCyanDefault	contained	start="\e\[49m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgCyanBlack	contained	start="\e\[40m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgCyanRed	contained	start="\e\[41m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgCyanGreen	contained	start="\e\[42m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgCyanYellow	contained	start="\e\[43m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgCyanBlue	contained	start="\e\[44m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgCyanMagenta	contained	start="\e\[45m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgCyanCyan	contained	start="\e\[46m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgCyanWhite	contained	start="\e\[47m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               hi link ansiFgCyanBold	ansiCyanBold
                               hi link ansiFgCyanUnderline	ansiCyanUnderline
                               hi link ansiFgCyanDefault	ansiCyanDefault
                               hi link ansiFgCyanBlack	ansiCyanBlack
                               hi link ansiFgCyanRed	ansiCyanRed
                               hi link ansiFgCyanGreen	ansiCyanGreen
                               hi link ansiFgCyanYellow	ansiCyanYellow
                               hi link ansiFgCyanBlue	ansiCyanBlue
                               hi link ansiFgCyanMagenta	ansiCyanMagenta
                               hi link ansiFgCyanCyan	ansiCyanCyan
                               hi link ansiFgCyanWhite	ansiCyanWhite
                            
                               syn cluster AnsiWhiteFgGroup contains=ansiFgWhiteBold,ansiFgWhiteUnderline,ansiFgWhiteDefault,ansiFgWhiteBlack,ansiFgWhiteRed,ansiFgWhiteGreen,ansiFgWhiteYellow,ansiFgWhiteBlue,ansiFgWhiteMagenta,ansiFgWhiteCyan,ansiFgWhiteWhite
                               syn region ansiWhiteFg	concealends matchgroup=ansiNone start="\e\[;\=0\{0,2};\=\%(1;\)\=37\%(;1\)\=m" skip='\e\[K' end="\e\[\%(0*;*\)\=39m\|\ze\e\[[03m]"  contains=@AnsiWhiteFgGroup,ansiConceal
                               syn region ansiFgWhiteBold	contained	start="\e\[1m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(22\|0*\)\=m" contains=ansiConceal
                               syn region ansiFgWhiteUnderline contained	start="\e\[4m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(24\|0*\)\=m" contains=ansiConceal
                               syn region ansiFgWhiteDefault	contained	start="\e\[49m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgWhiteBlack	contained	start="\e\[40m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgWhiteRed	contained	start="\e\[41m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgWhiteGreen	contained	start="\e\[42m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgWhiteYellow	contained	start="\e\[43m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgWhiteBlue	contained	start="\e\[44m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgWhiteMagenta	contained	start="\e\[45m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgWhiteCyan	contained	start="\e\[46m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgWhiteWhite	contained	start="\e\[47m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               hi link ansiFgWhiteBold	ansiWhiteBold
                               hi link ansiFgWhiteUnderline	ansiWhiteUnderline
                               hi link ansiFgWhiteDefault	ansiWhiteDefault
                               hi link ansiFgWhiteBlack	ansiWhiteBlack
                               hi link ansiFgWhiteRed	ansiWhiteRed
                               hi link ansiFgWhiteGreen	ansiWhiteGreen
                               hi link ansiFgWhiteYellow	ansiWhiteYellow
                               hi link ansiFgWhiteBlue	ansiWhiteBlue
                               hi link ansiFgWhiteMagenta	ansiWhiteMagenta
                               hi link ansiFgWhiteCyan	ansiWhiteCyan
                               hi link ansiFgWhiteWhite	ansiWhiteWhite
                            
                               syn cluster AnsiGrayFgGroup contains=ansiFgGrayBold,ansiFgGrayUnderline,ansiFgGrayDefault,ansiFgGrayBlack,ansiFgGrayRed,ansiFgGrayGreen,ansiFgGrayYellow,ansiFgGrayBlue,ansiFgGrayMagenta,ansiFgGrayCyan,ansiFgGrayWhite
                               syn region ansiGrayFg	concealends matchgroup=ansiNone start="\e\[;\=0\{0,2};\=\%(1;\)\=90\%(;1\)\=m" skip='\e\[K' end="\e\[\%(0*;*\)\=39m\|\ze\e\[[039m]"  contains=@AnsiGrayFgGroup,ansiConceal
                               syn region ansiFgGrayBold	contained	start="\e\[1m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(22\|0*\)\=m" contains=ansiConceal
                               syn region ansiFgGrayUnderline contained	start="\e\[4m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(24\|0*\)\=m" contains=ansiConceal
                               syn region ansiFgGrayDefault	contained	start="\e\[49m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgGrayBlack	contained	start="\e\[40m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgGrayRed	contained	start="\e\[41m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgGrayGreen	contained	start="\e\[42m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgGrayYellow	contained	start="\e\[43m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgGrayBlue	contained	start="\e\[44m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgGrayMagenta	contained	start="\e\[45m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgGrayCyan	contained	start="\e\[46m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiFgGrayWhite	contained	start="\e\[47m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               hi link ansiFgGrayBold	ansiGrayBold
                               hi link ansiFgGrayUnderline	ansiGrayUnderline
                               hi link ansiFgGrayDefault	ansiGrayDefault
                               hi link ansiFgGrayBlack	ansiGrayBlack
                               hi link ansiFgGrayRed	ansiGrayRed
                               hi link ansiFgGrayGreen	ansiGrayGreen
                               hi link ansiFgGrayYellow	ansiGrayYellow
                               hi link ansiFgGrayBlue	ansiGrayBlue
                               hi link ansiFgGrayMagenta	ansiGrayMagenta
                               hi link ansiFgGrayCyan	ansiGrayCyan
                               hi link ansiFgGrayWhite	ansiGrayWhite
                            
                               syn cluster AnsiBoldGroup contains=ansiUnderlineBoldRegion,ansiDefaultBoldRegion,ansiBlackBoldRegion,ansiWhiteBoldRegion,ansiGrayBoldRegion,ansiRedBoldRegion,ansiGreenBoldRegion,ansiYellowBoldRegion,ansiBlueBoldRegion,ansiMagentaBoldRegion,ansiCyanBoldRegion
                               syn region ansiBoldRegion        concealends matchgroup=ansiNone start="\e\[;\=0\{0,2};\=1;\=m" skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(0*\|22\)\=m" contains=@AnsiBoldGroup,ansiConceal
                               syn region ansiUnderlineBoldRegion contained	start="\e\[4m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(24\|0*\)\=m"  contains=ansiConceal
                               syn region ansiDefaultBoldRegion	contained	start="\e\[39m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiBlackBoldRegion	contained	start="\e\[30m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiRedBoldRegion	contained	start="\e\[31m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiGreenBoldRegion	contained	start="\e\[32m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiYellowBoldRegion	contained	start="\e\[33m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiBlueBoldRegion	contained	start="\e\[34m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiMagentaBoldRegion	contained	start="\e\[35m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiCyanBoldRegion	contained	start="\e\[36m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiWhiteBoldRegion	contained	start="\e\[37m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiGrayBoldRegion	contained	start="\e\[90m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               hi link ansiBoldRegion           ansiBold
                               hi link ansiUnderlineBoldRegion	ansiBoldUnderline
                               hi link ansiDefaultBoldRegion	ansiBoldDefault
                               hi link ansiBlackBoldRegion	ansiBoldBlack
                               hi link ansiRedBoldRegion	ansiBoldRed
                               hi link ansiGreenBoldRegion	ansiBoldGreen
                               hi link ansiYellowBoldRegion	ansiBoldYellow
                               hi link ansiBlueBoldRegion	ansiBoldBlue
                               hi link ansiMagentaBoldRegion	ansiBoldMagenta
                               hi link ansiCyanBoldRegion	ansiBoldCyan
                               hi link ansiWhiteBoldRegion	ansiBoldWhite
                               hi link ansiGrayBoldRegion	ansiBoldGray
                            
                               syn cluster AnsiUnderlineGroup contains=ansiBoldUnderlineRegion,ansiDefaultUnderlineRegion,ansiBlackUnderlineRegion,ansiWhiteUnderlineRegion,ansiGrayUnderlineRegion,ansiRedUnderlineRegion,ansiGreenUnderlineRegion,ansiYellowUnderlineRegion,ansiBlueUnderlineRegion,ansiMagentaUnderlineRegion,ansiCyanUnderlineRegion
                               syn region ansiUnderlineRegion       concealends matchgroup=ansiNone start="\e\[;\=0\{0,2};\=4;\=m" skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(0*\|24\)\=m" contains=@AnsiUnderlineGroup,ansiConceal
                               syn region ansiBoldUnderlineRegion	contained	start="\e\[1m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(22\|0*\)\=m"  contains=ansiConceal
                               syn region ansiDefaultUnderlineRegion	contained	start="\e\[39m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiBlackUnderlineRegion	contained	start="\e\[30m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiRedUnderlineRegion	contained	start="\e\[31m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiGreenUnderlineRegion	contained	start="\e\[32m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiYellowUnderlineRegion	contained	start="\e\[33m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiBlueUnderlineRegion	contained	start="\e\[34m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiMagentaUnderlineRegion	contained	start="\e\[35m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiCyanUnderlineRegion	contained	start="\e\[36m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiWhiteUnderlineRegion	contained	start="\e\[37m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiGrayUnderlineRegion	contained	start="\e\[90m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               hi link ansiUnderlineRegion          ansiUnderline
                               hi link ansiBoldUnderlineRegion      ansiBoldUnderline
                               hi link ansiDefaultUnderlineRegion   ansiUnderlineDefault
                               hi link ansiBlackUnderlineRegion	    ansiUnderlineBlack
                               hi link ansiRedUnderlineRegion	    ansiUnderlineRed
                               hi link ansiGreenUnderlineRegion	    ansiUnderlineGreen
                               hi link ansiYellowUnderlineRegion    ansiUnderlineYellow
                               hi link ansiBlueUnderlineRegion	    ansiUnderlineBlue
                               hi link ansiMagentaUnderlineRegion   ansiUnderlineMagenta
                               hi link ansiCyanUnderlineRegion	    ansiUnderlineCyan
                               hi link ansiWhiteUnderlineRegion	    ansiUnderlineWhite
                               hi link ansiGrayUnderlineRegion	    ansiUnderlineGray
                            
                               "-----------------------------------------
                               " handles implicit reverse background highlighting
                               "-----------------------------------------
                            "   call Decho("installing implicit reverse background highlighting")
                            
                               syn cluster AnsiReverseGroup contains=ansiUnderlineReverse,ansiBoldReverse,ansiDefaultReverse,ansiBlackReverse,ansiWhiteReverse,ansiGrayReverse,ansiRedReverse,ansiGreenReverse,ansiYellowReverse,ansiBlueReverse,ansiMagentaReverse,ansiCyanReverse,ansiDefaultReverseBg,ansiBlackReverseBg,ansiRedReverseBg,ansiGreenReverseBg,ansiYellowReverseBg,ansiBlueReverseBg,ansiMagentaReverseBg,ansiCyanReverseBg,ansiWhiteReverseBg,ansiDefaultReverseFg,ansiBlackReverseFg,ansiWhiteReverseFg,ansiGrayReverseFg,ansiRedReverseFg,ansiGreenReverseFg,ansiYellowReverseFg,ansiBlueReverseFg,ansiMagentaReverseFg,ansiCyanReverseFg,ansiReverseBoldRegion,ansiReverseUnderlineRegion
                               syn region ansiReverseRegion        concealends matchgroup=ansiNone start="\e\[;\=0\{0,2};\=7;\=m" skip='\e\[K' end="\ze\e\[\%(0\|27\)\=m" contains=@AnsiReverseGroup,ansiConceal
                               syn region ansiUnderlineReverse	contained	start="\e\[4m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(24\|0*\)\=m"  contains=ansiConceal
                               syn region ansiBgBoldReverse	contained	start="\e\[1m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(22\|0*\)\=m"  contains=ansiConceal
                               syn region ansiDefaultReverse	contained	start="\e\[39m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiBlackReverse	contained	start="\e\[30m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiRedReverse	contained	start="\e\[31m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiGreenReverse	contained	start="\e\[32m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiYellowReverse	contained	start="\e\[33m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiBlueReverse	contained	start="\e\[34m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiMagentaReverse	contained	start="\e\[35m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiCyanReverse	contained	start="\e\[36m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiWhiteReverse	contained	start="\e\[37m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiGrayReverse	contained	start="\e\[90m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               hi link ansiReverseRegion        ansiReverse
                               hi link ansiUnderlineReverse	ansiReverseUnderline
                               hi link ansiBgBoldReverse	ansiReverseBold
                               hi link ansiDefaultReverse	ansiReverseDefault
                               hi link ansiBlackReverse	ansiReverseBlack
                               hi link ansiRedReverse	ansiReverseRed
                               hi link ansiGreenReverse	ansiReverseGreen
                               hi link ansiYellowReverse	ansiReverseYellow
                               hi link ansiBlueReverse	ansiReverseBlue
                               hi link ansiMagentaReverse	ansiReverseMagenta
                               hi link ansiCyanReverse	ansiReverseCyan
                               hi link ansiWhiteReverse	ansiReverseWhite
                               hi link ansiGrayReverse	ansiReverseGray
                            
                               syn cluster AnsiDefaultReverseBgGroup contains=ansiReverseBgBoldDefault,ansiReverseBgUnderlineDefault,ansiReverseBgDefaultDefault,ansiReverseBgBlackDefault,ansiReverseBgRedDefault,ansiReverseBgGreenDefault,ansiReverseBgYellowDefault,ansiReverseBgBlueDefault,ansiReverseBgMagentaDefault,ansiReverseBgCyanDefault,ansiReverseBgWhiteDefault,ansiReverseBgGrayDefault
                               syn region ansiDefaultReverseBg      contained concealends matchgroup=ansiNone start="\e\[;\=0\{0,2};\=\%(0\{0,2};\)\=49\%(0\{0,2};\)\=m" skip='\e\[K' end="\e\[[04m]"me=e-3  contains=@AnsiDefaultBgGroup,ansiConceal
                               syn region ansiReverseBgBoldDefault          contained	start="\e\[1m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(22\|0*\)\=m"  contains=ansiConceal
                               syn region ansiReverseBgUnderlineDefault     contained	start="\e\[4m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(24\|0*\)\=m"  contains=ansiConceal
                               syn region ansiReverseBgDefaultDefault	contained	start="\e\[39m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgBlackDefault	contained	start="\e\[30m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgRedDefault	contained	start="\e\[31m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgGreenDefault	contained	start="\e\[32m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgYellowDefault	contained	start="\e\[33m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgBlueDefault	contained	start="\e\[34m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgMagentaDefault	contained	start="\e\[35m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgCyanDefault	contained	start="\e\[36m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgWhiteDefault	contained	start="\e\[37m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgGrayDefault	contained	start="\e\[90m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               hi link ansiReverseBgBoldDefault             ansiReverseBold
                               hi link ansiReverseBgUnderlineDefault        ansiReverseUnderline
                               hi link ansiReverseBgDefaultDefault	ansiDefaultDefault
                               hi link ansiReverseBgBlackDefault	ansiDefaultBlack
                               hi link ansiReverseBgRedDefault	            ansiDefaultRed
                               hi link ansiReverseBgGreenDefault	ansiDefaultGreen
                               hi link ansiReverseBgYellowDefault	ansiDefaultYellow
                               hi link ansiReverseBgBlueDefault	            ansiDefaultBlue
                               hi link ansiReverseBgMagentaDefault	ansiDefaultMagenta
                               hi link ansiReverseBgCyanDefault	            ansiDefaultCyan
                               hi link ansiReverseBgWhiteDefault	ansiDefaultWhite
                               hi link ansiReverseBgGrayDefault	            ansiDefaultGray
                            
                               syn cluster AnsiBlackReverseBgGroup contains=ansiReverseBgBoldBlack,ansiReverseBgUnderlineBlack,ansiReverseBgDefaultBlack,ansiReverseBgBlackBlack,ansiReverseBgRedBlack,ansiReverseBgGreenBlack,ansiReverseBgYellowBlack,ansiReverseBgBlueBlack,ansiReverseBgMagentaBlack,ansiReverseBgCyanBlack,ansiReverseBgWhiteBlack,ansiReverseBgGrayBlack
                               syn region ansiBlackReverseBg	contained concealends matchgroup=ansiNone start="\e\[;\=0\{0,2};\=\%(1;\)\=40\%(;1\)\=m" skip='\e\[K' end="\e\[\%(0*;*\)\=49m\|\ze\e\[[04m]"  contains=@AnsiBlackReverseBgGroup,ansiConceal
                               syn region ansiReverseBgBoldBlack	contained	start="\e\[1m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(22\|0*\)\=m"  contains=ansiConceal
                               syn region ansiReverseBgUnderlineBlack	contained	start="\e\[4m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(24\|0*\)\=m"  contains=ansiConceal
                               syn region ansiReverseBgDefaultBlack	contained	start="\e\[39m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgBlackBlack	contained	start="\e\[30m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgRedBlack	            contained	start="\e\[31m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgGreenBlack	contained	start="\e\[32m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgYellowBlack	contained	start="\e\[33m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgBlueBlack	contained	start="\e\[34m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgMagentaBlack	contained	start="\e\[35m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgCyanBlack	contained	start="\e\[36m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgWhiteBlack	contained	start="\e\[37m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgGrayBlack	contained	start="\e\[90m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               hi link ansiReverseBgBoldBlack       ansiBlackBold
                               hi link ansiReverseBgUnderlineBlack  ansiBlackUnderline
                               hi link ansiReverseBgDefaultBlack    ansiDefaultBlack
                               hi link ansiReverseBgBlackBlack	    ansiBlackBlack
                               hi link ansiReverseBgRedBlack	    ansiBlackRed
                               hi link ansiReverseBgGreenBlack	    ansiBlackGreen
                               hi link ansiReverseBgYellowBlack	    ansiBlackYellow
                               hi link ansiReverseBgBlueBlack	    ansiBlackBlue
                               hi link ansiReverseBgMagentaBlack    ansiBlackMagenta
                               hi link ansiReverseBgCyanBlack	    ansiBlackCyan
                               hi link ansiReverseBgWhiteBlack	    ansiBlackWhite
                               hi link ansiReverseBgGrayBlack	    ansiBlackGray
                            
                               syn cluster AnsiRedReverseBgGroup contains=ansiReverseBgBoldRed,ansiReverseBgUnderlineRed,ansiReverseBgDefaultRed,ansiReverseBgBlackRed,ansiReverseBgRedRed,ansiReverseBgGreenRed,ansiReverseBgYellowRed,ansiReverseBgBlueRed,ansiReverseBgMagentaRed,ansiReverseBgCyanRed,ansiReverseBgWhiteRed,ansiReverseBgGrayRed
                               syn region ansiRedReverseBg	contained concealends matchgroup=ansiNone start="\e\[;\=0\{0,2};\=\%(1;\)\=41\%(;1\)\=m" skip='\e\[K' end="\e\[\%(0*;*\)\=49m\|\ze\e\[[04m]"  contains=@AnsiRedReverseBgGroup,ansiConceal
                               syn region ansiReverseBgBoldRed	    contained start="\e\[1m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(22\|0*\)\=m"  contains=ansiConceal
                               syn region ansiReverseBgUnderlineRed contained start="\e\[4m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(24\|0*\)\=m"  contains=ansiConceal
                               syn region ansiReverseBgDefaultRed   contained start="\e\[39m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgBlackRed	    contained start="\e\[30m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgRedRed	    contained start="\e\[31m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgGreenRed	    contained start="\e\[32m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgYellowRed    contained start="\e\[33m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgBlueRed	    contained start="\e\[34m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgMagentaRed   contained start="\e\[35m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgCyanRed	    contained start="\e\[36m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgWhiteRed	    contained start="\e\[37m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgGrayRed	    contained start="\e\[90m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               hi link ansiReverseBgBoldRed     ansiRedBold
                               hi link ansiReverseBgUnderlineRed ansiRedUnderline
                               hi link ansiReverseBgDefaultRed	ansiRedDefault
                               hi link ansiReverseBgBlackRed	ansiRedBlack
                               hi link ansiReverseBgRedRed	ansiRedRed
                               hi link ansiReverseBgGreenRed	ansiRedGreen
                               hi link ansiReverseBgYellowRed	ansiRedYellow
                               hi link ansiReverseBgBlueRed	ansiRedBlue
                               hi link ansiReverseBgMagentaRed	ansiRedMagenta
                               hi link ansiReverseBgCyanRed	ansiRedCyan
                               hi link ansiReverseBgWhiteRed	ansiRedWhite
                               hi link ansiReverseBgGrayRed	ansiRedGray
                            
                               syn cluster AnsiGreenReverseBgGroup contains=ansiReverseBgBoldGreen,ansiReverseBgUnderlineGreen,ansiReverseBgDefaultGreen,ansiReverseBgBlackGreen,ansiReverseBgRedGreen,ansiReverseBgGreenGreen,ansiReverseBgYellowGreen,ansiReverseBgBlueGreen,ansiReverseBgMagentaGreen,ansiReverseBgCyanGreen,ansiReverseBgWhiteGreen,ansiReverseBgGrayGreen
                               syn region ansiGreenReverseBg	contained concealends matchgroup=ansiNone start="\e\[;\=0\{0,2};\=\%(1;\)\=42\%(;1\)\=m" skip='\e\[K' end="\e\[\%(0*;*\)\=49m\|\ze\e\[[04m]"  contains=@AnsiGreenReverseBgGroup,ansiConceal
                               syn region ansiReverseBgBoldGreen        contained start="\e\[1m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(22\|0*\)\=m"  contains=ansiConceal
                               syn region ansiReverseBgUnderlineGreen   contained start="\e\[4m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(24\|0*\)\=m"  contains=ansiConceal
                               syn region ansiReverseBgDefaultGreen     contained start="\e\[39m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgBlackGreen       contained start="\e\[30m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgRedGreen	        contained start="\e\[31m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgGreenGreen       contained start="\e\[32m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgYellowGreen      contained start="\e\[33m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgBlueGreen        contained start="\e\[34m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgMagentaGreen     contained start="\e\[35m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgCyanGreen        contained start="\e\[36m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgWhiteGreen       contained start="\e\[37m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgGrayGreen       contained start="\e\[90m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               hi link ansiReverseBgBoldGreen   ansiGreenBold
                               hi link ansiReverseBgUnderlineGreen ansiGreenUnderline
                               hi link ansiReverseBgDefaultGreen ansiGreenDefault
                               hi link ansiReverseBgBlackGreen	ansiGreenBlack
                               hi link ansiReverseBgGreenGreen	ansiGreenGreen
                               hi link ansiReverseBgGreenGreen	ansiGreenGreen
                               hi link ansiReverseBgYellowGreen	ansiGreenYellow
                               hi link ansiReverseBgBlueGreen	ansiGreenBlue
                               hi link ansiReverseBgMagentaGreen ansiGreenMagenta
                               hi link ansiReverseBgCyanGreen	ansiGreenCyan
                               hi link ansiReverseBgWhiteGreen	ansiGreenWhite
                               hi link ansiReverseBgGrayGreen	ansiGreenGray
                            
                               syn cluster AnsiYellowReverseBgGroup contains=ansiReverseFgBoldYellow,ansiReverseFgUnderlineYellow,ansiReverseFgDefaultYellow,ansiReverseFgBlackYellow,ansiReverseFgRedYellow,ansiReverseFgGreenYellow,ansiReverseFgYellowYellow,ansiReverseFgBlueYellow,ansiReverseFgMagentaYellow,ansiReverseFgCyanYellow,ansiReverseFgWhiteYellow,ansiReverseFgGrayYellow
                               syn region ansiYellowReverseBg	contained concealends matchgroup=ansiNone start="\e\[;\=0\{0,2};\=\%(1;\)\=43\%(;1\)\=m" skip='\e\[K' end="\e\[\%(0*;*\)\=49m\|\ze\e\[[04m]" contains=@AnsiYellowReverseBgGroup,ansiConceal
                               syn region ansiReverseFgBoldYellow	contained start="\e\[1m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(22\|0*\)\=m"  contains=ansiConceal
                               syn region ansiReverseFgUnderlineYellow	contained start="\e\[4m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(24\|0*\)\=m"  contains=ansiConceal
                               syn region ansiReverseFgDefaultYellow	contained start="\e\[39m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseFgBlackYellow	contained start="\e\[30m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseFgRedYellow	contained start="\e\[31m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseFgGreenYellow	contained start="\e\[32m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseFgYellowYellow	contained start="\e\[33m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseFgBlueYellow	contained start="\e\[34m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseFgMagentaYellow	contained start="\e\[35m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseFgCyanYellow	contained start="\e\[36m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseFgWhiteYellow	contained start="\e\[37m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseFgGrayYellow	contained start="\e\[90m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               hi link ansiReverseFgBoldYellow      ansiYellowBold
                               hi link ansiReverseFgUnderlineYellow ansiYellowUnderline
                               hi link ansiReverseFgDefaultYellow   ansiYellowDefault
                               hi link ansiReverseFgBlackYellow	    ansiYellowBlack
                               hi link ansiReverseFgYellowYellow    ansiYellowYellow
                               hi link ansiReverseFgGreenYellow	    ansiYellowGreen
                               hi link ansiReverseFgYellowYellow    ansiYellowYellow
                               hi link ansiReverseFgBlueYellow	    ansiYellowBlue
                               hi link ansiReverseFgMagentaYellow   ansiYellowMagenta
                               hi link ansiReverseFgCyanYellow	    ansiYellowCyan
                               hi link ansiReverseFgWhiteYellow	    ansiYellowWhite
                               hi link ansiReverseFgGrayYellow	    ansiYellowGray
                            
                               syn cluster AnsiBlueReverseBgGroup contains=ansiReverseBgBoldBlue,ansiReverseBgUnderlineBlue,ansiReverseBgDefaultBlue,ansiReverseBgBlackBlue,ansiReverseBgRedBlue,ansiReverseBgGreenBlue,ansiReverseBgYellowBlue,ansiReverseBgBlueBlue,ansiReverseBgMagentaBlue,ansiReverseBgCyanBlue,ansiReverseBgWhiteBlue,ansiReverseBgGrayBlue
                               syn region ansiBlueReverseBg	contained concealends matchgroup=ansiNone start="\e\[;\=0\{0,2};\=\%(1;\)\=44\%(;1\)\=m" skip='\e\[K' end="\e\[\%(0*;*\)\=49m\|\ze\e\[[04m]"  contains=@AnsiBlueReverseBgGroup,ansiConceal
                               syn region ansiReverseBgBoldBlue	        contained start="\e\[1m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(22\|0*\)\=m"  contains=ansiConceal
                               syn region ansiReverseBgUnderlineBlue    contained start="\e\[4m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(24\|0*\)\=m"  contains=ansiConceal
                               syn region ansiReverseBgDefaultBlue      contained start="\e\[39m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgBlackBlue        contained start="\e\[30m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgRedBlue          contained start="\e\[31m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgGreenBlue        contained start="\e\[32m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgYellowBlue       contained start="\e\[33m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgBlueBlue         contained start="\e\[34m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgMagentaBlue      contained start="\e\[35m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgCyanBlue         contained start="\e\[36m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgWhiteBlue        contained start="\e\[37m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgGrayBlue        contained start="\e\[90m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               hi link ansiReverseBgBoldBlue    ansiBlueBold
                               hi link ansiReverseBgUnderlineBlue ansiBlueUnderline
                               hi link ansiReverseBgDefaultBlue	ansiBlueDefault
                               hi link ansiReverseBgBlackBlue	ansiBlueBlack
                               hi link ansiReverseBgBlueBlue	ansiBlueBlue
                               hi link ansiReverseBgGreenBlue	ansiBlueGreen
                               hi link ansiReverseBgYellowBlue	ansiBlueYellow
                               hi link ansiReverseBgBlueBlue	ansiBlueBlue
                               hi link ansiReverseBgMagentaBlue	ansiBlueMagenta
                               hi link ansiReverseBgCyanBlue	ansiBlueCyan
                               hi link ansiReverseBgWhiteBlue	ansiBlueWhite
                               hi link ansiReverseBgGrayBlue	ansiBlueGray
                            
                               syn cluster AnsiMagentaReverseBgGroup contains=ansiReverseBgBoldMagenta,ansiReverseBgUnderlineMagenta,ansiReverseBgDefaultMagenta,ansiReverseBgBlackMagenta,ansiReverseBgRedMagenta,ansiReverseBgGreenMagenta,ansiReverseBgYellowMagenta,ansiReverseBgBlueMagenta,ansiReverseBgMagentaMagenta,ansiReverseBgCyanMagenta,ansiReverseBgWhiteMagenta,ansiReverseBgGrayMagenta
                               syn region ansiMagentaReverseBg	contained concealends matchgroup=ansiNone start="\e\[;\=0\{0,2};\=\%(1;\)\=45\%(;1\)\=m" skip='\e\[K' end="\e\[\%(0*;*\)\=49m\|\ze\e\[[04m]"  contains=@AnsiMagentaReverseBgGroup,ansiConceal
                               syn region ansiReverseBgBoldMagenta          contained start="\e\[1m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(22\|0*\)\=m"  contains=ansiConceal
                               syn region ansiReverseBgUnderlineMagenta     contained start="\e\[4m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(24\|0*\)\=m"  contains=ansiConceal
                               syn region ansiReverseBgDefaultMagenta	contained start="\e\[39m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgBlackMagenta	contained start="\e\[30m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgRedMagenta	contained start="\e\[31m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgGreenMagenta	contained start="\e\[32m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgYellowMagenta	contained start="\e\[33m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgBlueMagenta	contained start="\e\[34m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgMagentaMagenta	contained start="\e\[35m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgCyanMagenta	contained start="\e\[36m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgWhiteMagenta	contained start="\e\[37m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgGrayMagenta	contained start="\e\[90m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               hi link ansiReverseBgBoldMagenta         ansiMagentaBold
                               hi link ansiReverseBgUnderlineMagenta    ansiMagentaUnderline
                               hi link ansiReverseBgDefaultMagenta      ansiMagentaDefault
                               hi link ansiReverseBgBlackMagenta        ansiMagentaBlack
                               hi link ansiReverseBgMagentaMagenta      ansiMagentaMagenta
                               hi link ansiReverseBgGreenMagenta        ansiMagentaGreen
                               hi link ansiReverseBgYellowMagenta       ansiMagentaYellow
                               hi link ansiReverseBgBlueMagenta         ansiMagentaBlue
                               hi link ansiReverseBgMagentaMagenta      ansiMagentaMagenta
                               hi link ansiReverseBgCyanMagenta         ansiMagentaCyan
                               hi link ansiReverseBgWhiteMagenta        ansiMagentaWhite
                               hi link ansiReverseBgGrayMagenta        ansiMagentaGray
                            
                               syn cluster AnsiCyanReverseBgGroup contains=ansiReverseBgBoldCyan,ansiReverseBgUnderlineCyan,ansiReverseBgDefaultCyan,ansiReverseBgBlackCyan,ansiReverseBgRedCyan,ansiReverseBgGreenCyan,ansiReverseBgYellowCyan,ansiReverseBgBlueCyan,ansiReverseBgMagentaCyan,ansiReverseBgCyanCyan,ansiReverseBgWhiteCyan,ansiReverseBgGrayCyan
                               syn region ansiCyanReverseBg	contained concealends matchgroup=ansiNone start="\e\[;\=0\{0,2};\=\%(1;\)\=46\%(;1\)\=m" skip='\e\[K' end="\e\[\%(0*;*\)\=49m\|\ze\e\[[04m]"  contains=@AnsiCyanReverseBgGroup,ansiConceal
                               syn region ansiReverseBgBoldCyan         contained start="\e\[1m" skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(22\|0*\)\=m"  contains=ansiConceal
                               syn region ansiReverseBgUnderlineCyan    contained start="\e\[4m" skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(24\|0*\)\=m"  contains=ansiConceal
                               syn region ansiReverseBgDefaultCyan      contained start="\e\[39m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgBlackCyan        contained start="\e\[30m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgRedCyan          contained start="\e\[31m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgGreenCyan        contained start="\e\[32m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgYellowCyan       contained start="\e\[33m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgBlueCyan         contained start="\e\[34m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgMagentaCyan      contained start="\e\[35m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgCyanCyan         contained start="\e\[36m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgWhiteCyan        contained start="\e\[37m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgGrayCyan        contained start="\e\[90m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               hi link ansiReverseBgBoldCyan    ansiCyanBold
                               hi link ansiReverseBgUnderlineCyan ansiCyanUnderline
                               hi link ansiReverseBgDefaultCyan	ansiCyanDefault
                               hi link ansiReverseBgBlackCyan	ansiCyanBlack
                               hi link ansiReverseBgCyanCyan	ansiCyanCyan
                               hi link ansiReverseBgGreenCyan	ansiCyanGreen
                               hi link ansiReverseBgYellowCyan	ansiCyanYellow
                               hi link ansiReverseBgBlueCyan	ansiCyanBlue
                               hi link ansiReverseBgMagentaCyan	ansiCyanMagenta
                               hi link ansiReverseBgCyanCyan	ansiCyanCyan
                               hi link ansiReverseBgWhiteCyan	ansiCyanWhite
                               hi link ansiReverseBgGrayCyan	ansiCyanGray
                            
                               syn cluster AnsiWhiteReverseBgGroup contains=ansiReverseBgBoldWhite,ansiReverseBgUnderlineWhite,ansiReverseBgDefaultWhite,ansiReverseBgBlackWhite,ansiReverseBgRedWhite,ansiReverseBgGreenWhite,ansiReverseBgYellowWhite,ansiReverseBgBlueWhite,ansiReverseBgMagentaWhite,ansiReverseBgCyanWhite,ansiReverseBgWhiteWhite,ansiReverseBgGrayWhite
                               syn region ansiWhiteReverseBg	contained concealends matchgroup=ansiNone start="\e\[;\=0\{0,2};\=\%(1;\)\=47\%(;1\)\=m" skip='\e\[K' end="\e\[\%(0*;*\)\=49m\|\ze\e\[[04m]"  contains=@AnsiWhiteReverseBgGroup,ansiConceal
                               syn region ansiReverseBgBoldWhite        contained start="\e\[1m" skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(22\|0*\)\=m"  contains=ansiConceal
                               syn region ansiReverseBgUnderlineWhite   contained start="\e\[4m" skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(24\|0*\)\=m"  contains=ansiConceal
                               syn region ansiReverseBgDefaultWhite     contained start="\e\[39m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgBlackWhite       contained start="\e\[30m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgRedWhite         contained start="\e\[31m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgGreenWhite       contained start="\e\[32m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgYellowWhite      contained start="\e\[33m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgBlueWhite        contained start="\e\[34m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgMagentaWhite     contained start="\e\[35m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgCyanWhite        contained start="\e\[36m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgWhiteWhite       contained start="\e\[37m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseBgGrayWhite       contained start="\e\[90m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               hi link ansiReverseBgBoldWhite   ansiWhiteBold
                               hi link ansiReverseBgUnderlineWhite ansiWhiteUnderline
                               hi link ansiReverseBgDefaultWhite ansiWhiteDefault
                               hi link ansiReverseBgBlackWhite	ansiWhiteBlack
                               hi link ansiReverseBgRedWhite    ansiWhiteRed
                               hi link ansiReverseBgGreenWhite	ansiWhiteGreen
                               hi link ansiReverseBgYellowWhite	ansiWhiteYellow
                               hi link ansiReverseBgBlueWhite	ansiWhiteBlue
                               hi link ansiReverseBgMagentaWhite ansiWhiteMagenta
                               hi link ansiReverseBgCyanWhite	ansiWhiteCyan
                               hi link ansiReverseBgWhiteWhite	ansiWhiteWhite
                               hi link ansiReverseBgGrayWhite	ansiWhiteGray
                            
                               "-----------------------------------------
                               " handles implicit reverse foreground highlighting
                               "-----------------------------------------
                            "   call Decho("installing implicit reverse foreground highlighting")
                            
                               syn cluster AnsiDefaultReverseFgGroup contains=ansiReverseFgDefaultBold,ansiReverseFgDefaultUnderline,ansiReverseFgDefaultDefault,ansiReverseFgDefaultBlack,ansiReverseFgDefaultRed,ansiReverseFgDefaultGreen,ansiReverseFgDefaultYellow,ansiReverseFgDefaultBlue,ansiReverseFgDefaultMagenta,ansiReverseFgDefaultCyan,ansiReverseFgDefaultWhite
                               syn region ansiDefaultReverseFg		contained concealends matchgroup=ansiNone start="\e\[;\=0\{0,2};\=\%(1;\)\=39\%(;1\)\=m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=@AnsiDefaultReverseFgGroup,ansiConceal
                               syn region ansiReverseFgDefaultBold	contained	start="\e\[1m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(22\|0*\)\=m" contains=ansiConceal
                               syn region ansiReverseFgDefaultUnerline	contained	start="\e\[4m"  skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgDefaultDefault	contained	start="\e\[49m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgDefaultBlack	contained	start="\e\[40m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgDefaultRed	contained	start="\e\[41m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgDefaultGreen	contained	start="\e\[42m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgDefaultYellow	contained	start="\e\[43m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgDefaultBlue	contained	start="\e\[44m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgDefaultMagenta	contained	start="\e\[45m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgDefaultCyan	contained	start="\e\[46m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgDefaultWhite	contained	start="\e\[47m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               hi link ansiDefaultReverseFg		ansiReverseDefault
                               hi link ansiReverseFgDefaultBold      	 ansiBoldDefault
                               hi link ansiReverseFgDefaultUnderline 	 ansiUnderlineDefault
                               hi link ansiReverseFgDefaultDefault   	 ansiDefaultDefault
                               hi link ansiReverseFgDefaultBlack     	 ansiBlackDefault
                               hi link ansiReverseFgDefaultRed       	 ansiRedDefault
                               hi link ansiReverseFgDefaultGreen     	 ansiGreenDefault
                               hi link ansiReverseFgDefaultYellow    	 ansiYellowDefault
                               hi link ansiReverseFgDefaultBlue      	 ansiBlueDefault
                               hi link ansiReverseFgDefaultMagenta   	 ansiMagentaDefault
                               hi link ansiReverseFgDefaultCyan      	 ansiCyanDefault
                               hi link ansiReverseFgDefaultWhite     	 ansiWhiteDefault
                            
                               syn cluster AnsiBlackReverseFgGroup contains=ansiReverseFgBlackBold,ansiReverseFgBlackUnderline,ansiReverseFgBlackDefault,ansiReverseFgBlackBlack,ansiReverseFgBlackRed,ansiReverseFgBlackGreen,ansiReverseFgBlackYellow,ansiReverseFgBlackBlue,ansiReverseFgBlackMagenta,ansiReverseFgBlackCyan,ansiReverseFgBlackWhite
                               syn region ansiBlackReverseFg	contained concealends	matchgroup=ansiNone start="\e\[;\=0\{0,2};\=\%(1;\)\=30\%(;1\)\=m" skip='\e\[K' end="\e\[\%(0*;*\)\=39m\|\ze\e\[[03m]"  contains=@AnsiBlackReverseFgGroup,ansiConceal
                               syn region ansiReverseFgBlackBold	contained	start="\e\[1m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(22\|0*\)\=m"  contains=ansiConceal
                               syn region ansiReverseFgBlackUnerline	contained	start="\e\[4m"  skip='\e\[K' end="\e\[[04m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseFgBlackDefault	contained	start="\e\[49m" skip='\e\[K' end="\e\[[04m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseFgBlackBlack	contained	start="\e\[40m" skip='\e\[K' end="\e\[[04m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseFgBlackRed	            contained	start="\e\[41m" skip='\e\[K' end="\e\[[04m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseFgBlackGreen	contained	start="\e\[42m" skip='\e\[K' end="\e\[[04m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseFgBlackYellow	contained	start="\e\[43m" skip='\e\[K' end="\e\[[04m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseFgBlackBlue	contained	start="\e\[44m" skip='\e\[K' end="\e\[[04m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseFgBlackMagenta	contained	start="\e\[45m" skip='\e\[K' end="\e\[[04m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseFgBlackCyan	contained	start="\e\[46m" skip='\e\[K' end="\e\[[04m]"me=e-3  contains=ansiConceal
                               syn region ansiReverseFgBlackWhite	contained	start="\e\[47m" skip='\e\[K' end="\e\[[04m]"me=e-3  contains=ansiConceal
                               hi link ansiBlackReverseFg		ansiReverseBlack
                               hi link ansiReverseFgBlackBold      	 ansiBoldBlack
                               hi link ansiReverseFgBlackUnderline 	 ansiUnderlineBlack
                               hi link ansiReverseFgBlackDefault   	 ansiDefaultBlack
                               hi link ansiReverseFgBlackBlack     	 ansiBlackBlack
                               hi link ansiReverseFgBlackRed       	 ansiRedBlack
                               hi link ansiReverseFgBlackGreen     	 ansiGreenBlack
                               hi link ansiReverseFgBlackYellow    	 ansiYellowBlack
                               hi link ansiReverseFgBlackBlue      	 ansiBlueBlack
                               hi link ansiReverseFgBlackMagenta   	 ansiMagentaBlack
                               hi link ansiReverseFgBlackCyan      	 ansiCyanBlack
                               hi link ansiReverseFgBlackWhite     	 ansiWhiteBlack
                            
                               syn cluster AnsiRedReverseFgGroup contains=ansiReverseFgRedBold,ansiReverseFgRedUnderline,ansiReverseFgRedDefault,ansiReverseFgRedBlack,ansiReverseFgRedRed,ansiReverseFgRedGreen,ansiReverseFgRedYellow,ansiReverseFgRedBlue,ansiReverseFgRedMagenta,ansiReverseFgRedCyan,ansiReverseFgRedWhite
                               syn region ansiRedReverseFg		contained concealends matchgroup=ansiNone start="\e\[;\=0\{0,2};\=\%(1;\)\=31\%(;1\)\=m" skip='\e\[K' end="\e\[\%(0*;*\)\=39m\|\ze\e\[[03m]"  contains=@AnsiRedReverseFgGroup,ansiConceal
                               syn region ansiReverseFgRedBold      contained start="\e\[1m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(22\|0*\)\=m" contains=ansiConceal
                               syn region ansiReverseFgRedUnderline contained start="\e\[4m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(24\|0*\)\=m" contains=ansiConceal
                               syn region ansiReverseFgRedDefault   contained start="\e\[49m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgRedBlack     contained start="\e\[40m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgRedRed       contained start="\e\[41m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgRedGreen     contained start="\e\[42m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgRedYellow    contained start="\e\[43m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgRedBlue      contained start="\e\[44m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgRedMagenta   contained start="\e\[45m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgRedCyan      contained start="\e\[46m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgRedWhite     contained start="\e\[47m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               hi link ansiRedReverseFg		ansiReverseRed
                               hi link ansiReverseFgRedBold      	 ansiBoldRed
                               hi link ansiReverseFgRedUnderline 	 ansiUnderlineRed
                               hi link ansiReverseFgRedDefault   	 ansiDefaultRed
                               hi link ansiReverseFgRedBlack     	 ansiBlackRed
                               hi link ansiReverseFgRedRed       	 ansiRedRed
                               hi link ansiReverseFgRedGreen     	 ansiGreenRed
                               hi link ansiReverseFgRedYellow    	 ansiYellowRed
                               hi link ansiReverseFgRedBlue      	 ansiBlueRed
                               hi link ansiReverseFgRedMagenta   	 ansiMagentaRed
                               hi link ansiReverseFgRedCyan      	 ansiCyanRed
                               hi link ansiReverseFgRedWhite     	 ansiWhiteRed
                            
                               syn cluster AnsiGreenReverseFgGroup contains=ansiReverseFgGreenBold,ansiReverseFgGreenUnderline,ansiReverseFgGreenDefault,ansiReverseFgGreenBlack,ansiReverseFgGreenRed,ansiReverseFgGreenGreen,ansiReverseFgGreenYellow,ansiReverseFgGreenBlue,ansiReverseFgGreenMagenta,ansiReverseFgGreenCyan,ansiReverseFgGreenWhite
                               syn region ansiGreenReverseFg	contained concealends matchgroup=ansiNone start="\e\[;\=0\{0,2};\=\%(1;\)\=32\%(;1\)\=m" skip='\e\[K' end="\e\[\%(0*;*\)\=39m\|\ze\e\[[03m]"  contains=@AnsiGreenReverseFgGroup,ansiConceal
                               syn region ansiReverseFgGreenBold      contained start="\e\[1m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(22\|0*\)\=m" contains=ansiConceal
                               syn region ansiReverseFgGreenUnderline contained start="\e\[4m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(24\|0*\)\=m" contains=ansiConceal
                               syn region ansiReverseFgGreenDefault   contained start="\e\[49m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgGreenBlack     contained start="\e\[40m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgGreenRed       contained start="\e\[41m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgGreenGreen     contained start="\e\[42m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgGreenYellow    contained start="\e\[43m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgGreenBlue      contained start="\e\[44m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgGreenMagenta   contained start="\e\[45m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgGreenCyan      contained start="\e\[46m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgGreenWhite     contained start="\e\[47m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               hi link ansiGreenReverseFg		ansiReverseGreen
                               hi link ansiReverseFgGreenBold      	 ansiBoldGreen
                               hi link ansiReverseFgGreenUnderline 	 ansiUnderlineGreen
                               hi link ansiReverseFgGreenDefault   	 ansiDefaultGreen
                               hi link ansiReverseFgGreenBlack     	 ansiBlackGreen
                               hi link ansiReverseFgGreenGreen     	 ansiGreenGreen
                               hi link ansiReverseFgGreenRed       	 ansiRedGreen
                               hi link ansiReverseFgGreenYellow    	 ansiYellowGreen
                               hi link ansiReverseFgGreenBlue      	 ansiBlueGreen
                               hi link ansiReverseFgGreenMagenta   	 ansiMagentaGreen
                               hi link ansiReverseFgGreenCyan      	 ansiCyanGreen
                               hi link ansiReverseFgGreenWhite     	 ansiWhiteGreen
                            
                               syn cluster AnsiYellowReverseFgGroup contains=ansiReverseFgYellowBold,ansiReverseFgYellowUnderline,ansiReverseFgYellowDefault,ansiReverseFgYellowBlack,ansiReverseFgYellowRed,ansiReverseFgYellowGreen,ansiReverseFgYellowYellow,ansiReverseFgYellowBlue,ansiReverseFgYellowMagenta,ansiReverseFgYellowCyan,ansiReverseFgYellowWhite
                               syn region ansiYellowReverseFg	contained concealends matchgroup=ansiNone start="\e\[;\=0\{0,2};\=\%(1;\)\=33\%(;1\)\=m" skip='\e\[K' end="\e\[\%(0*;*\)\=39m\|\ze\e\[[03m]"  contains=@AnsiYellowReverseFgGroup,ansiConceal
                               syn region ansiReverseFgYellowBold	contained	start="\e\[1m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(22\|0*\)\=m" contains=ansiConceal
                               syn region ansiReverseFgYellowUnderline	contained	start="\e\[4m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(24\|0*\)\=m" contains=ansiConceal
                               syn region ansiReverseFgYellowDefault	contained	start="\e\[49m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgYellowBlack	contained	start="\e\[40m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgYellowRed	contained	start="\e\[41m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgYellowGreen	contained	start="\e\[42m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgYellowYellow	contained	start="\e\[43m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgYellowBlue	contained	start="\e\[44m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgYellowMagenta	contained	start="\e\[45m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgYellowCyan	contained	start="\e\[46m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgYellowWhite	contained	start="\e\[47m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               hi link ansiYellowReverseFg		ansiReverseYellow
                               hi link ansiReverseFgYellowBold      	 ansiBoldYellow
                               hi link ansiReverseFgYellowUnderline 	 ansiUnderlineYellow
                               hi link ansiReverseFgYellowDefault   	 ansiDefaultYellow
                               hi link ansiReverseFgYellowBlack     	 ansiBlackYellow
                               hi link ansiReverseFgYellowRed       	 ansiRedYellow
                               hi link ansiReverseFgYellowGreen     	 ansiGreenYellow
                               hi link ansiReverseFgYellowYellow    	 ansiYellowYellow
                               hi link ansiReverseFgYellowBlue      	 ansiBlueYellow
                               hi link ansiReverseFgYellowMagenta   	 ansiMagentaYellow
                               hi link ansiReverseFgYellowCyan      	 ansiCyanYellow
                               hi link ansiReverseFgYellowWhite     	 ansiWhiteYellow
                            
                               syn cluster AnsiBlueReverseFgGroup contains=ansiReverseFgBlueBold,ansiReverseFgBlueUnderline,ansiReverseFgBlueDefault,ansiReverseFgBlueBlack,ansiReverseFgBlueRed,ansiReverseFgBlueGreen,ansiReverseFgBlueYellow,ansiReverseFgBlueBlue,ansiReverseFgBlueMagenta,ansiReverseFgBlueCyan,ansiReverseFgBlueWhite
                               syn region ansiBlueReverseFg	contained concealends matchgroup=ansiNone start="\e\[;\=0\{0,2};\=\%(1;\)\=34\%(;1\)\=m" skip='\e\[K' end="\e\[\%(0*;*\)\=39m\|\ze\e\[[03m]"  contains=@AnsiBlueReverseFgGroup,ansiConceal
                               syn region ansiReverseFgBlueBold      contained start="\e\[1m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(22\|0*\)\=m" contains=ansiConceal
                               syn region ansiReverseFgBlueUnderline contained start="\e\[4m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(24\|0*\)\=m" contains=ansiConceal
                               syn region ansiReverseFgBlueDefault   contained start="\e\[49m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgBlueBlack     contained start="\e\[40m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgBlueRed       contained start="\e\[41m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgBlueGreen     contained start="\e\[42m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgBlueYellow    contained start="\e\[43m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgBlueBlue      contained start="\e\[44m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgBlueMagenta   contained start="\e\[45m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgBlueCyan      contained start="\e\[46m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgBlueWhite     contained start="\e\[47m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               hi link ansiBlueReverseFg		ansiReverseBlue
                               hi link ansiReverseFgBlueBold      	 ansiBoldBlue
                               hi link ansiReverseFgBlueUnderline 	 ansiUnderlineBlue
                               hi link ansiReverseFgBlueDefault   	 ansiDefaultBlue
                               hi link ansiReverseFgBlueBlack     	 ansiBlackBlue
                               hi link ansiReverseFgBlueRed       	 ansiRedBlue
                               hi link ansiReverseFgBlueGreen     	 ansiGreenBlue
                               hi link ansiReverseFgBlueYellow    	 ansiYellowBlue
                               hi link ansiReverseFgBlueBlue      	 ansiBlueBlue
                               hi link ansiReverseFgBlueMagenta   	 ansiMagentaBlue
                               hi link ansiReverseFgBlueCyan      	 ansiCyanBlue
                               hi link ansiReverseFgBlueWhite     	 ansiWhiteBlue
                            
                               syn cluster AnsiMagentaReverseFgGroup contains=ansiReverseFgMagentaBold,ansiReverseFgMagentaUnderline,ansiReverseFgMagentaDefault,ansiReverseFgMagentaBlack,ansiReverseFgMagentaRed,ansiReverseFgMagentaGreen,ansiReverseFgMagentaYellow,ansiReverseFgMagentaBlue,ansiReverseFgMagentaMagenta,ansiReverseFgMagentaCyan,ansiReverseFgMagentaWhite
                               syn region ansiMagentaReverseFg	contained concealends matchgroup=ansiNone start="\e\[;\=0\{0,2};\=\%(1;\)\=35\%(;1\)\=m" skip='\e\[K' end="\e\[\%(0*;*\)\=39m\|\ze\e\[[03m]"  contains=@AnsiMagentaReverseFgGroup,ansiConceal
                               syn region ansiReverseFgMagentaBold      contained start="\e\[1m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(22\|0*\)\=m" contains=ansiConceal
                               syn region ansiReverseFgMagentaUnderline contained start="\e\[4m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(24\|0*\)\=m" contains=ansiConceal
                               syn region ansiReverseFgMagentaDefault   contained start="\e\[49m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgMagentaBlack     contained start="\e\[40m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgMagentaRed       contained start="\e\[41m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgMagentaGreen     contained start="\e\[42m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgMagentaYellow    contained start="\e\[43m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgMagentaBlue      contained start="\e\[44m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgMagentaMagenta   contained start="\e\[45m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgMagentaCyan      contained start="\e\[46m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgMagentaWhite     contained start="\e\[47m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               hi link ansiMagentaReverseFg		ansiReverseMagenta
                               hi link ansiReverseFgMagentaBold      	 ansiBoldMagenta
                               hi link ansiReverseFgMagentaUnderline 	 ansiUnderlineMagenta
                               hi link ansiReverseFgMagentaDefault   	 ansiDefaultMagenta
                               hi link ansiReverseFgMagentaBlack     	 ansiBlackMagenta
                               hi link ansiReverseFgMagentaRed       	 ansiRedMagenta
                               hi link ansiReverseFgMagentaGreen     	 ansiGreenMagenta
                               hi link ansiReverseFgMagentaYellow    	 ansiYellowMagenta
                               hi link ansiReverseFgMagentaBlue      	 ansiBlueMagenta
                               hi link ansiReverseFgMagentaMagenta   	 ansiMagentaMagenta
                               hi link ansiReverseFgMagentaCyan      	 ansiCyanMagenta
                               hi link ansiReverseFgMagentaWhite     	 ansiWhiteMagenta
                            
                               syn cluster AnsiCyanReverseFgGroup contains=ansiReverseFgCyanBold,ansiReverseFgCyanUnderline,ansiReverseFgCyanDefault,ansiReverseFgCyanBlack,ansiReverseFgCyanRed,ansiReverseFgCyanGreen,ansiReverseFgCyanYellow,ansiReverseFgCyanBlue,ansiReverseFgCyanMagenta,ansiReverseFgCyanCyan,ansiReverseFgCyanWhite
                               syn region ansiCyanReverseFg	contained concealends matchgroup=ansiNone start="\e\[;\=0\{0,2};\=\%(1;\)\=36\%(;1\)\=m" skip='\e\[K' end="\e\[\%(0*;*\)\=39m\|\ze\e\[[03m]"  contains=@AnsiCyanReverseFgGroup,ansiConceal
                               syn region ansiReverseFgCyanBold      contained start="\e\[1m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(22\|0*\)\=m" contains=ansiConceal
                               syn region ansiReverseFgCyanUnderline contained start="\e\[4m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(24\|0*\)\=m" contains=ansiConceal
                               syn region ansiReverseFgCyanDefault   contained start="\e\[49m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgCyanBlack     contained start="\e\[40m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgCyanRed       contained start="\e\[41m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgCyanGreen     contained start="\e\[42m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgCyanYellow    contained start="\e\[43m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgCyanBlue      contained start="\e\[44m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgCyanMagenta   contained start="\e\[45m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgCyanCyan      contained start="\e\[46m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgCyanWhite     contained start="\e\[47m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               hi link ansiCyanReverseFg		ansiReverseCyan
                               hi link ansiReverseFgCyanBold      	 ansiBoldCyan
                               hi link ansiReverseFgCyanUnderline 	 ansiUnderlineCyan
                               hi link ansiReverseFgCyanDefault   	 ansiDefaultCyan
                               hi link ansiReverseFgCyanBlack     	 ansiBlackCyan
                               hi link ansiReverseFgCyanRed       	 ansiRedCyan
                               hi link ansiReverseFgCyanGreen     	 ansiGreenCyan
                               hi link ansiReverseFgCyanYellow    	 ansiYellowCyan
                               hi link ansiReverseFgCyanBlue      	 ansiBlueCyan
                               hi link ansiReverseFgCyanMagenta   	 ansiMagentaCyan
                               hi link ansiReverseFgCyanCyan      	 ansiCyanCyan
                               hi link ansiReverseFgCyanWhite     	 ansiWhiteCyan
                            
                               syn cluster AnsiWhiteReverseFgGroup contains=ansiReverseFgWhiteBold,ansiReverseFgWhiteUnderline,ansiReverseFgWhiteDefault,ansiReverseFgWhiteBlack,ansiReverseFgWhiteRed,ansiReverseFgWhiteGreen,ansiReverseFgWhiteYellow,ansiReverseFgWhiteBlue,ansiReverseFgWhiteMagenta,ansiReverseFgWhiteCyan,ansiReverseFgWhiteWhite
                               syn region ansiWhiteReverseFg	contained concealends matchgroup=ansiNone start="\e\[;\=0\{0,2};\=\%(1;\)\=37\%(;1\)\=m" skip='\e\[K' end="\e\[\%(0*;*\)\=39m\|\ze\e\[[03m]"  contains=@AnsiWhiteReverseFgGroup,ansiConceal
                               syn region ansiReverseFgWhiteBold      contained start="\e\[1m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(22\|0*\)\=m" contains=ansiConceal
                               syn region ansiReverseFgWhiteUnderline contained start="\e\[4m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(24\|0*\)\=m" contains=ansiConceal
                               syn region ansiReverseFgWhiteDefault   contained start="\e\[49m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgWhiteBlack     contained start="\e\[40m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgWhiteRed       contained start="\e\[41m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgWhiteGreen     contained start="\e\[42m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgWhiteYellow    contained start="\e\[43m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgWhiteBlue      contained start="\e\[44m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgWhiteMagenta   contained start="\e\[45m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgWhiteCyan      contained start="\e\[46m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgWhiteWhite     contained start="\e\[47m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               hi link ansiWhiteReverseFg		ansiReverseWhite
                               hi link ansiReverseFgWhiteBold      	 ansiBoldWhite
                               hi link ansiReverseFgWhiteUnderline 	 ansiUnderlineWhite
                               hi link ansiReverseFgWhiteDefault   	 ansiDefaultWhite
                               hi link ansiReverseFgWhiteBlack     	 ansiBlackWhite
                               hi link ansiReverseFgWhiteRed       	 ansiRedWhite
                               hi link ansiReverseFgWhiteGreen     	 ansiGreenWhite
                               hi link ansiReverseFgWhiteYellow    	 ansiYellowWhite
                               hi link ansiReverseFgWhiteBlue      	 ansiBlueWhite
                               hi link ansiReverseFgWhiteMagenta   	 ansiMagentaWhite
                               hi link ansiReverseFgWhiteCyan      	 ansiCyanWhite
                               hi link ansiReverseFgWhiteWhite     	 ansiWhiteWhite
                            
                               syn cluster AnsiGrayReverseFgGroup contains=ansiReverseFgGrayBold,ansiReverseFgGrayUnderline,ansiReverseFgGrayDefault,ansiReverseFgGrayBlack,ansiReverseFgGrayRed,ansiReverseFgGrayGreen,ansiReverseFgGrayYellow,ansiReverseFgGrayBlue,ansiReverseFgGrayMagenta,ansiReverseFgGrayCyan,ansiReverseFgGrayWhite
                               syn region ansiGrayReverseFg	contained concealends matchgroup=ansiNone start="\e\[;\=0\{0,2};\=\%(1;\)\=90\%(;1\)\=m" skip='\e\[K' end="\e\[\%(0*;*\)\=39m\|\ze\e\[[039m]"  contains=@AnsiGrayReverseFgGroup,ansiConceal
                               syn region ansiReverseFgGrayBold      contained start="\e\[1m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(22\|0*\)\=m" contains=ansiConceal
                               syn region ansiReverseFgGrayUnderline contained start="\e\[4m"  skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(24\|0*\)\=m" contains=ansiConceal
                               syn region ansiReverseFgGrayDefault   contained start="\e\[49m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgGrayBlack     contained start="\e\[40m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgGrayRed       contained start="\e\[41m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgGrayGreen     contained start="\e\[42m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgGrayYellow    contained start="\e\[43m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgGrayBlue      contained start="\e\[44m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgGrayMagenta   contained start="\e\[45m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgGrayCyan      contained start="\e\[46m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               syn region ansiReverseFgGrayWhite     contained start="\e\[47m" skip='\e\[K' end="\e\[[04m]"me=e-3 contains=ansiConceal
                               hi link ansiGrayReverseFg		ansiReverseGray
                               hi link ansiReverseFgGrayBold      	 ansiBoldGray
                               hi link ansiReverseFgGrayUnderline 	 ansiUnderlineGray
                               hi link ansiReverseFgGrayDefault   	 ansiDefaultGray
                               hi link ansiReverseFgGrayBlack     	 ansiBlackGray
                               hi link ansiReverseFgGrayRed       	 ansiRedGray
                               hi link ansiReverseFgGrayGreen     	 ansiGreenGray
                               hi link ansiReverseFgGrayYellow    	 ansiYellowGray
                               hi link ansiReverseFgGrayBlue      	 ansiBlueGray
                               hi link ansiReverseFgGrayMagenta   	 ansiMagentaGray
                               hi link ansiReverseFgGrayCyan      	 ansiCyanGray
                               hi link ansiReverseFgGrayWhite     	 ansiWhiteGray
                            
                               syn cluster AnsiReverseBoldGroup contains=ansiUnderlineReverseBoldRegion,ansiDefaultReverseBoldRegion,ansiBlackReverseBoldRegion,ansiWhiteReverseBoldRegion,ansiGrayReverseBoldRegion,ansiRedReverseBoldRegion,ansiGreenReverseBoldRegion,ansiYellowReverseBoldRegion,ansiBlueReverseBoldRegion,ansiMagentaReverseBoldRegion,ansiCyanReverseBoldRegion
                               syn region ansiReverseBoldRegion     contained concealends matchgroup=ansiNone start="\e\[;\=0\{0,2};\=1;\=m" end="\ze\e\[\%(0*;*\)\=\%(0*\|22\)\=m" contains=@AnsiBoldGroup,ansiConceal
                               syn region ansiUnderlineReverseBoldRegion	contained start="\e\[4m" skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(24\|0*\)\=m"  contains=ansiConceal
                               syn region ansiDefaultReverseBoldRegion	contained start="\e\[39m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiBlackReverseBoldRegion	contained start="\e\[30m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiRedReverseBoldRegion	contained start="\e\[31m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiGreenReverseBoldRegion	contained start="\e\[32m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiYellowReverseBoldRegion	contained start="\e\[33m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiBlueReverseBoldRegion	contained start="\e\[34m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiMagentaReverseBoldRegion	contained start="\e\[35m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiCyanReverseBoldRegion	contained start="\e\[36m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiWhiteReverseBoldRegion	contained start="\e\[37m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiGrayReverseBoldRegion	contained start="\e\[90m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               hi link ansiReverseBoldRegion                ansiReverseBold
                               hi link ansiUnderlineReverseBoldRegion	ansiReverseBoldUnderline
                               hi link ansiDefaultReverseBoldRegion	ansiDefaultBold
                               hi link ansiBlackReverseBoldRegion	ansiBlackBold
                               hi link ansiRedReverseBoldRegion	            ansiRedBold
                               hi link ansiGreenReverseBoldRegion	ansiGreenBold
                               hi link ansiYellowReverseBoldRegion	ansiYellowBold
                               hi link ansiBlueReverseBoldRegion	ansiBlueBold
                               hi link ansiMagentaReverseBoldRegion	ansiMagentaBold
                               hi link ansiCyanReverseBoldRegion	ansiCyanBold
                               hi link ansiWhiteReverseBoldRegion	ansiWhiteBold
                               hi link ansiGrayReverseBoldRegion	ansiGrayBold
                            
                               syn cluster AnsiReverseUnderlineGroup contains=ansiBoldReverseUnderlineRegion,ansiDefaultReverseUnderlineRegion,ansiBlackReverseUnderlineRegion,ansiWhiteReverseUnderlineRegion,ansiGrayReverseUnderlineRegion,ansiRedReverseUnderlineRegion,ansiGreenReverseUnderlineRegion,ansiYellowReverseUnderlineRegion,ansiBlueReverseUnderlineRegion,ansiMagentaReverseUnderlineRegion,ansiCyanReverseUnderlineRegion,ansiBgStop,ansiBoldStop
                               syn region ansiReverseUnderlineRegion contained concealends matchgroup=ansiNone start="\e\[;\=0\{0,2};\=4;\=m" end="\ze\e\[\%(0*;*\)\=\%(0*\|24\)\=m" contains=@AnsiUnderlineGroup,ansiConceal
                               syn region ansiBoldReverseUnderlineRegion	contained start="\e\[1m" skip='\e\[K' end="\ze\e\[\%(0*;*\)\=\%(22\|0*\)\=m"  contains=ansiConceal
                               syn region ansiDefaultReverseUnderlineRegion	contained start="\e\[39m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiBlackReverseUnderlineRegion	contained start="\e\[30m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiRedReverseUnderlineRegion	contained start="\e\[31m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiGreenReverseUnderlineRegion	contained start="\e\[32m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiYellowReverseUnderlineRegion	contained start="\e\[33m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiBlueReverseUnderlineRegion	contained start="\e\[34m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiMagentaReverseUnderlineRegion	contained start="\e\[35m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiCyanReverseUnderlineRegion	contained start="\e\[36m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiWhiteReverseUnderlineRegion	contained start="\e\[37m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               syn region ansiGrayReverseUnderlineRegion	contained start="\e\[90m" skip='\e\[K' end="\e\[[03m]"me=e-3  contains=ansiConceal
                               hi link ansiReverseUnderlineRegion           ansiReverseUnderline
                               hi link ansiBoldReverseUnderlineRegion       ansiReverseBoldUnderline
                               hi link ansiDefaultReverseUnderlineRegion    ansiDefaultUnderline
                               hi link ansiBlackReverseUnderlineRegion      ansiBlackUnderline
                               hi link ansiRedReverseUnderlineRegion	ansiRedUnderline
                               hi link ansiGreenReverseUnderlineRegion	ansiGreenUnderline
                               hi link ansiYellowReverseUnderlineRegion     ansiYellowUnderline
                               hi link ansiBlueReverseUnderlineRegion	ansiBlueUnderline
                               hi link ansiMagentaReverseUnderlineRegion    ansiMagentaUnderline
                               hi link ansiCyanReverseUnderlineRegion	ansiCyanUnderline
                               hi link ansiWhiteReverseUnderlineRegion	ansiWhiteUnderline
                               hi link ansiGrayReverseUnderlineRegion	ansiGrayUnderline
                              endif
                            
                              if has("conceal")
                               syn match ansiStop		conceal "\e\[;\=0\{0,2}m"
                               syn match ansiStop		conceal "\e\[K"
                               syn match ansiStop		conceal "\e\[H"
                               syn match ansiStop		conceal "\e\[2J"
                              else
                               syn match ansiStop		"\e\[;\=0\{0,2}m"
                               syn match ansiStop		"\e\[K"
                               syn match ansiStop		"\e\[H"
                               syn match ansiStop		"\e\[2J"
                              endif
                            
                              " ---------------------------------------------------------------------
                              " Some Color Combinations: - can't do 'em all, the qty of highlighting groups is limited! {{{2
                              " ---------------------------------------------------------------------
                              syn region ansiBlackDefault	start="\e\[0\{0,2};\=\(30;49\|49;30\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiRedDefault	start="\e\[0\{0,2};\=\(31;49\|49;31\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiGreenDefault	start="\e\[0\{0,2};\=\(32;49\|49;32\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiYellowDefault	start="\e\[0\{0,2};\=\(33;49\|49;33\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiBlueDefault	start="\e\[0\{0,2};\=\(34;49\|49;34\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiMagentaDefault	start="\e\[0\{0,2};\=\(35;49\|49;35\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiCyanDefault	start="\e\[0\{0,2};\=\(36;49\|49;36\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiWhiteDefault	start="\e\[0\{0,2};\=\(37;49\|49;37\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiDefaultDefault	start="\e\[0\{0,2};\=\(39;49\|49;39\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiGrayDefault	start="\e\[0\{0,2};\=\(90;49\|49;90\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                            
                              syn region ansiBlackBlack	start="\e\[0\{0,2};\=\(30;40\|40;30\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiRedBlack	start="\e\[0\{0,2};\=\(31;40\|40;31\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiGreenBlack	start="\e\[0\{0,2};\=\(32;40\|40;32\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiYellowBlack	start="\e\[0\{0,2};\=\(33;40\|40;33\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiBlueBlack	start="\e\[0\{0,2};\=\(34;40\|40;34\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiMagentaBlack	start="\e\[0\{0,2};\=\(35;40\|40;35\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiCyanBlack	start="\e\[0\{0,2};\=\(36;40\|40;36\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiWhiteBlack	start="\e\[0\{0,2};\=\(37;40\|40;37\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiDefaultBlack	start="\e\[0\{0,2};\=\(39;40\|40;39\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiGrayBlack	start="\e\[0\{0,2};\=\(90;40\|40;90\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                            
                              syn region ansiBlackRed	start="\e\[0\{0,2};\=\(30;41\|41;30\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiRedRed		start="\e\[0\{0,2};\=\(31;41\|41;31\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiGreenRed	start="\e\[0\{0,2};\=\(32;41\|41;32\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiYellowRed	start="\e\[0\{0,2};\=\(33;41\|41;33\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiBlueRed	start="\e\[0\{0,2};\=\(34;41\|41;34\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiMagentaRed	start="\e\[0\{0,2};\=\(35;41\|41;35\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiCyanRed	start="\e\[0\{0,2};\=\(36;41\|41;36\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiWhiteRed	start="\e\[0\{0,2};\=\(37;41\|41;37\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiDefaultRed	start="\e\[0\{0,2};\=\(39;41\|41;39\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiGrayRed	start="\e\[0\{0,2};\=\(90;41\|41;90\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                            
                              syn region ansiBlackGreen	start="\e\[0\{0,2};\=\(30;42\|42;30\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiRedGreen	start="\e\[0\{0,2};\=\(31;42\|42;31\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiGreenGreen	start="\e\[0\{0,2};\=\(32;42\|42;32\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiYellowGreen	start="\e\[0\{0,2};\=\(33;42\|42;33\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiBlueGreen	start="\e\[0\{0,2};\=\(34;42\|42;34\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiMagentaGreen	start="\e\[0\{0,2};\=\(35;42\|42;35\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiCyanGreen	start="\e\[0\{0,2};\=\(36;42\|42;36\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiWhiteGreen	start="\e\[0\{0,2};\=\(37;42\|42;37\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiDefaultGreen	start="\e\[0\{0,2};\=\(39;42\|42;39\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiGrayGreen	start="\e\[0\{0,2};\=\(90;42\|42;90\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                            
                              syn region ansiBlackYellow	start="\e\[0\{0,2};\=\(30;43\|43;30\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiRedYellow	start="\e\[0\{0,2};\=\(31;43\|43;31\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiGreenYellow	start="\e\[0\{0,2};\=\(32;43\|43;32\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiYellowYellow	start="\e\[0\{0,2};\=\(33;43\|43;33\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiBlueYellow	start="\e\[0\{0,2};\=\(34;43\|43;34\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiMagentaYellow	start="\e\[0\{0,2};\=\(35;43\|43;35\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiCyanYellow	start="\e\[0\{0,2};\=\(36;43\|43;36\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiWhiteYellow	start="\e\[0\{0,2};\=\(37;43\|43;37\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiDefaultYellow	start="\e\[0\{0,2};\=\(39;43\|43;39\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiGrayYellow	start="\e\[0\{0,2};\=\(90;43\|43;90\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                            
                              syn region ansiBlackBlue	start="\e\[0\{0,2};\=\(30;44\|44;30\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiRedBlue	start="\e\[0\{0,2};\=\(31;44\|44;31\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiGreenBlue	start="\e\[0\{0,2};\=\(32;44\|44;32\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiYellowBlue	start="\e\[0\{0,2};\=\(33;44\|44;33\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiBlueBlue	start="\e\[0\{0,2};\=\(34;44\|44;34\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiMagentaBlue	start="\e\[0\{0,2};\=\(35;44\|44;35\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiCyanBlue	start="\e\[0\{0,2};\=\(36;44\|44;36\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiWhiteBlue	start="\e\[0\{0,2};\=\(37;44\|44;37\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiDefaultBlue	start="\e\[0\{0,2};\=\(39;44\|44;39\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiGrayBlue	start="\e\[0\{0,2};\=\(90;44\|44;90\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                            
                              syn region ansiBlackMagenta	start="\e\[0\{0,2};\=\(30;45\|45;30\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiRedMagenta	start="\e\[0\{0,2};\=\(31;45\|45;31\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiGreenMagenta	start="\e\[0\{0,2};\=\(32;45\|45;32\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiYellowMagenta	start="\e\[0\{0,2};\=\(33;45\|45;33\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiBlueMagenta	start="\e\[0\{0,2};\=\(34;45\|45;34\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiMagentaMagenta	start="\e\[0\{0,2};\=\(35;45\|45;35\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiCyanMagenta	start="\e\[0\{0,2};\=\(36;45\|45;36\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiWhiteMagenta	start="\e\[0\{0,2};\=\(37;45\|45;37\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiDefaultMagenta	start="\e\[0\{0,2};\=\(39;45\|45;39\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiGrayMagenta	start="\e\[0\{0,2};\=\(90;45\|45;90\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                            
                              syn region ansiBlackCyan	start="\e\[0\{0,2};\=\(30;46\|46;30\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiRedCyan	start="\e\[0\{0,2};\=\(31;46\|46;31\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiGreenCyan	start="\e\[0\{0,2};\=\(32;46\|46;32\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiYellowCyan	start="\e\[0\{0,2};\=\(33;46\|46;33\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiBlueCyan	start="\e\[0\{0,2};\=\(34;46\|46;34\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiMagentaCyan	start="\e\[0\{0,2};\=\(35;46\|46;35\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiCyanCyan	start="\e\[0\{0,2};\=\(36;46\|46;36\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiWhiteCyan	start="\e\[0\{0,2};\=\(37;46\|46;37\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiDefaultCyan	start="\e\[0\{0,2};\=\(39;46\|46;39\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiGrayCyan	start="\e\[0\{0,2};\=\(90;46\|46;90\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                            
                              syn region ansiBlackWhite	start="\e\[0\{0,2};\=\(30;47\|47;30\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiRedWhite	start="\e\[0\{0,2};\=\(31;47\|47;31\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiGreenWhite	start="\e\[0\{0,2};\=\(32;47\|47;32\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiYellowWhite	start="\e\[0\{0,2};\=\(33;47\|47;33\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiBlueWhite	start="\e\[0\{0,2};\=\(34;47\|47;34\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiMagentaWhite	start="\e\[0\{0,2};\=\(35;47\|47;35\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiCyanWhite	start="\e\[0\{0,2};\=\(36;47\|47;36\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiWhiteWhite	start="\e\[0\{0,2};\=\(37;47\|47;37\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiDefaultWhite	start="\e\[0\{0,2};\=\(39;47\|47;39\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                              syn region ansiGrayWhite	start="\e\[0\{0,2};\=\(90;47\|47;90\)m" skip="\e\[K" end="\e\["me=e-2 contains=ansiConceal
                            
                              syn match ansiExtended	"\e\[;\=\(0;\)\=[34]8;\(\d*;\)*\d*m"   contains=ansiConceal
                            
                              " -------------
                              " Highlighting: {{{2
                              " -------------
                              if !has("conceal")
                               " --------------
                               " ansiesc_ignore: {{{3
                               " --------------
                               hi def link ansiConceal	Ignore
                               hi def link ansiSuppress	Ignore
                               hi def link ansiIgnore	ansiStop
                               hi def link ansiStop		Ignore
                               hi def link ansiExtended	Ignore
                               let s:hlkeep_{bufnr("%")}= &l:hl
                               exe "setlocal hl=".substitute(&hl,'8:[^,]\{-},','8:Ignore,',"")
                              endif
                            
                              " handle 3 or more element ansi escape sequences by building syntax and highlighting rules
                              " specific to the current file
                              call s:MultiElementHandler()
                            
                              hi ansiNone	cterm=NONE gui=NONE
                            
                              if &t_Co == 8 || &t_Co == 256
                               " ---------------------
                               " eight-color handling: {{{3
                               " ---------------------
                            "   call Decho("set up 8-color highlighting groups")
                               hi ansiBlack             ctermfg=Black      guifg=Black                                        cterm=NONE         gui=NONE
                               hi ansiRed               ctermfg=DarkRed        guifg=DarkRed                                          cterm=NONE         gui=NONE
                               hi ansiGreen             ctermfg=DarkGreen      guifg=DarkGreen                                        cterm=NONE         gui=NONE
                               hi ansiYellow            ctermfg=DarkYellow     guifg=DarkYellow                                       cterm=NONE         gui=NONE
                               hi ansiBlue              ctermfg=DarkBlue       guifg=DarkBlue                                         cterm=NONE         gui=NONE
                               hi ansiMagenta           ctermfg=DarkMagenta    guifg=DarkMagenta                                      cterm=NONE         gui=NONE
                               hi ansiCyan              ctermfg=DarkCyan       guifg=DarkCyan                                         cterm=NONE         gui=NONE
                               hi ansiWhite             ctermfg=LightGray      guifg=LightGray                                        cterm=NONE         gui=NONE
                               hi ansiGray              ctermfg=DarkGray       guifg=DarkGray                                         cterm=NONE         gui=NONE
                            
                               hi ansiDefaultBg         ctermbg=NONE       guibg=NONE                                         cterm=NONE         gui=NONE
                               hi ansiBlackBg           ctermbg=Black      guibg=Black                                        cterm=NONE         gui=NONE
                               hi ansiRedBg             ctermbg=DarkRed        guibg=DarkRed                                          cterm=NONE         gui=NONE
                               hi ansiGreenBg           ctermbg=DarkGreen      guibg=DarkGreen                                        cterm=NONE         gui=NONE
                               hi ansiYellowBg          ctermbg=DarkYellow     guibg=DarkYellow                                       cterm=NONE         gui=NONE
                               hi ansiBlueBg            ctermbg=DarkBlue       guibg=DarkBlue                                         cterm=NONE         gui=NONE
                               hi ansiMagentaBg         ctermbg=DarkMagenta    guibg=DarkMagenta                                      cterm=NONE         gui=NONE
                               hi ansiCyanBg            ctermbg=DarkCyan       guibg=DarkCyan                                         cterm=NONE         gui=NONE
                               hi ansiWhiteBg           ctermbg=LightGray      guibg=LightGray                                        cterm=NONE         gui=NONE
                               hi ansiGrayBg            ctermbg=DarkGray       guibg=DarkGray                                         cterm=NONE         gui=NONE
                            
                               hi ansiBlackFg           ctermfg=Black      guifg=Black                                        cterm=NONE         gui=NONE
                               hi ansiRedFg             ctermfg=DarkRed        guifg=DarkRed                                          cterm=NONE         gui=NONE
                               hi ansiGreenFg           ctermfg=DarkGreen      guifg=DarkGreen                                        cterm=NONE         gui=NONE
                               hi ansiYellowFg          ctermfg=DarkYellow     guifg=DarkYellow                                       cterm=NONE         gui=NONE
                               hi ansiBlueFg            ctermfg=DarkBlue       guifg=DarkBlue                                         cterm=NONE         gui=NONE
                               hi ansiMagentaFg         ctermfg=DarkMagenta    guifg=DarkMagenta                                      cterm=NONE         gui=NONE
                               hi ansiCyanFg            ctermfg=DarkCyan       guifg=DarkCyan                                         cterm=NONE         gui=NONE
                               hi ansiWhiteFg           ctermfg=LightGray      guifg=LightGray                                        cterm=NONE         gui=NONE
                               hi ansiGrayFg            ctermfg=DarkGray       guifg=DarkGray                                         cterm=NONE         gui=NONE
                            
                               hi ansiDefaultReverseBg         ctermbg=NONE       guibg=NONE                                         cterm=reverse         gui=reverse
                               hi ansiBlackReverseBg           ctermbg=Black      guibg=Black                                        cterm=reverse         gui=reverse
                               hi ansiRedReverseBg             ctermbg=DarkRed        guibg=DarkRed                                          cterm=reverse         gui=reverse
                               hi ansiGreenReverseBg           ctermbg=DarkGreen      guibg=DarkGreen                                        cterm=reverse         gui=reverse
                               hi ansiYellowReverseBg          ctermbg=DarkYellow     guibg=DarkYellow                                       cterm=reverse         gui=reverse
                               hi ansiBlueReverseBg            ctermbg=DarkBlue       guibg=DarkBlue                                         cterm=reverse         gui=reverse
                               hi ansiMagentaReverseBg         ctermbg=DarkMagenta    guibg=DarkMagenta                                      cterm=reverse         gui=reverse
                               hi ansiCyanReverseBg            ctermbg=DarkCyan       guibg=DarkCyan                                         cterm=reverse         gui=reverse
                               hi ansiWhiteReverseBg           ctermbg=LightGray      guibg=LightGray                                        cterm=reverse         gui=reverse
                            
                               hi ansiBold                                                                                    cterm=bold         gui=bold
                               hi ansiBoldUnderline                                                                           cterm=bold,underline gui=bold,underline
                               hi ansiBoldBlack         ctermfg=Black      guifg=Black                                        cterm=bold         gui=bold
                               hi ansiBoldRed           ctermfg=DarkRed        guifg=DarkRed                                          cterm=bold         gui=bold
                               hi ansiBoldGreen         ctermfg=DarkGreen      guifg=DarkGreen                                        cterm=bold         gui=bold
                               hi ansiBoldYellow        ctermfg=DarkYellow     guifg=DarkYellow                                       cterm=bold         gui=bold
                               hi ansiBoldBlue          ctermfg=DarkBlue       guifg=DarkBlue                                         cterm=bold         gui=bold
                               hi ansiBoldMagenta       ctermfg=DarkMagenta    guifg=DarkMagenta                                      cterm=bold         gui=bold
                               hi ansiBoldCyan          ctermfg=DarkCyan       guifg=DarkCyan                                         cterm=bold         gui=bold
                               hi ansiBoldWhite         ctermfg=LightGray      guifg=LightGray                                        cterm=bold         gui=bold
                               hi ansiBoldGray          ctermbg=DarkGray       guibg=DarkGray                                         cterm=bold         gui=bold
                            
                               hi ansiBlackBold         ctermbg=Black      guibg=Black                                        cterm=bold         gui=bold
                               hi ansiRedBold           ctermbg=DarkRed        guibg=DarkRed                                          cterm=bold         gui=bold
                               hi ansiGreenBold         ctermbg=DarkGreen      guibg=DarkGreen                                        cterm=bold         gui=bold
                               hi ansiYellowBold        ctermbg=DarkYellow     guibg=DarkYellow                                       cterm=bold         gui=bold
                               hi ansiBlueBold          ctermbg=DarkBlue       guibg=DarkBlue                                         cterm=bold         gui=bold
                               hi ansiMagentaBold       ctermbg=DarkMagenta    guibg=DarkMagenta                                      cterm=bold         gui=bold
                               hi ansiCyanBold          ctermbg=DarkCyan       guibg=DarkCyan                                         cterm=bold         gui=bold
                               hi ansiWhiteBold         ctermbg=LightGray      guibg=LightGray                                        cterm=bold         gui=bold
                            
                               hi ansiReverse                                                                                 cterm=reverse      gui=reverse
                               hi ansiReverseUnderline                                                                        cterm=reverse,underline gui=reverse,underline
                               hi ansiReverseBold                                                                             cterm=reverse,bold gui=reverse,bold
                               hi ansiReverseBoldUnderline                                                                    cterm=reverse,bold,underline gui=reverse,bold,underline
                               hi ansiReverseBlack      ctermfg=Black      guifg=Black                                        cterm=reverse         gui=reverse
                               hi ansiReverseRed        ctermfg=DarkRed        guifg=DarkRed                                          cterm=reverse         gui=reverse
                               hi ansiReverseGreen      ctermfg=DarkGreen      guifg=DarkGreen                                        cterm=reverse         gui=reverse
                               hi ansiReverseYellow     ctermfg=DarkYellow     guifg=DarkYellow                                       cterm=reverse         gui=reverse
                               hi ansiReverseBlue       ctermfg=DarkBlue       guifg=DarkBlue                                         cterm=reverse         gui=reverse
                               hi ansiReverseMagenta    ctermfg=DarkMagenta    guifg=DarkMagenta                                      cterm=reverse         gui=reverse
                               hi ansiReverseCyan       ctermfg=DarkCyan       guifg=DarkCyan                                         cterm=reverse         gui=reverse
                               hi ansiReverseWhite      ctermfg=LightGray      guifg=LightGray                                        cterm=reverse         gui=reverse
                               hi ansiReverseGray       ctermfg=DarkGray       guifg=DarkGray                                         cterm=reverse         gui=reverse
                            
                               hi ansiStandout                                                                                cterm=standout     gui=standout
                               hi ansiStandoutBlack     ctermfg=Black      guifg=Black                                        cterm=standout     gui=standout
                               hi ansiStandoutRed       ctermfg=DarkRed        guifg=DarkRed                                          cterm=standout     gui=standout
                               hi ansiStandoutGreen     ctermfg=DarkGreen      guifg=DarkGreen                                        cterm=standout     gui=standout
                               hi ansiStandoutYellow    ctermfg=DarkYellow     guifg=DarkYellow                                       cterm=standout     gui=standout
                               hi ansiStandoutBlue      ctermfg=DarkBlue       guifg=DarkBlue                                         cterm=standout     gui=standout
                               hi ansiStandoutMagenta   ctermfg=DarkMagenta    guifg=DarkMagenta                                      cterm=standout     gui=standout
                               hi ansiStandoutCyan      ctermfg=DarkCyan       guifg=DarkCyan                                         cterm=standout     gui=standout
                               hi ansiStandoutWhite     ctermfg=LightGray      guifg=LightGray                                        cterm=standout     gui=standout
                               hi ansiStandoutGray      ctermfg=DarkGray       guifg=DarkGray                                         cterm=standout     gui=standout
                            
                               hi ansiItalic                                                                                  cterm=italic       gui=italic
                               hi ansiItalicBlack       ctermfg=Black      guifg=Black                                        cterm=italic       gui=italic
                               hi ansiItalicRed         ctermfg=DarkRed        guifg=DarkRed                                          cterm=italic       gui=italic
                               hi ansiItalicGreen       ctermfg=DarkGreen      guifg=DarkGreen                                        cterm=italic       gui=italic
                               hi ansiItalicYellow      ctermfg=DarkYellow     guifg=DarkYellow                                       cterm=italic       gui=italic
                               hi ansiItalicBlue        ctermfg=DarkBlue       guifg=DarkBlue                                         cterm=italic       gui=italic
                               hi ansiItalicMagenta     ctermfg=DarkMagenta    guifg=DarkMagenta                                      cterm=italic       gui=italic
                               hi ansiItalicCyan        ctermfg=DarkCyan       guifg=DarkCyan                                         cterm=italic       gui=italic
                               hi ansiItalicWhite       ctermfg=LightGray      guifg=LightGray                                        cterm=italic       gui=italic
                               hi ansiItalicGray        ctermfg=DarkGray       guifg=DarkGray                                         cterm=italic       gui=italic
                            
                               hi ansiUnderline                                                                               cterm=underline    gui=underline
                               hi ansiUnderlineBlack    ctermfg=Black      guifg=Black                                        cterm=underline    gui=underline
                               hi ansiUnderlineRed      ctermfg=DarkRed        guifg=DarkRed                                          cterm=underline    gui=underline
                               hi ansiUnderlineGreen    ctermfg=DarkGreen      guifg=DarkGreen                                        cterm=underline    gui=underline
                               hi ansiUnderlineYellow   ctermfg=DarkYellow     guifg=DarkYellow                                       cterm=underline    gui=underline
                               hi ansiUnderlineBlue     ctermfg=DarkBlue       guifg=DarkBlue                                         cterm=underline    gui=underline
                               hi ansiUnderlineMagenta  ctermfg=DarkMagenta    guifg=DarkMagenta                                      cterm=underline    gui=underline
                               hi ansiUnderlineCyan     ctermfg=DarkCyan       guifg=DarkCyan                                         cterm=underline    gui=underline
                               hi ansiUnderlineWhite    ctermfg=LightGray      guifg=LightGray                                        cterm=underline    gui=underline
                               hi ansiUnderlineGray     ctermfg=DarkGray       guifg=DarkGray                                         cterm=underline    gui=underline
                            
                               hi ansiBlackUnderline    ctermbg=Black      guibg=Black                                        cterm=underline    gui=underline
                               hi ansiRedUnderline      ctermbg=DarkRed        guibg=DarkRed                                          cterm=underline    gui=underline
                               hi ansiGreenUnderline    ctermbg=DarkGreen      guibg=DarkGreen                                        cterm=underline    gui=underline
                               hi ansiYellowUnderline   ctermbg=DarkYellow     guibg=DarkYellow                                       cterm=underline    gui=underline
                               hi ansiBlueUnderline     ctermbg=DarkBlue       guibg=DarkBlue                                         cterm=underline    gui=underline
                               hi ansiMagentaUnderline  ctermbg=DarkMagenta    guibg=DarkMagenta                                      cterm=underline    gui=underline
                               hi ansiCyanUnderline     ctermbg=DarkCyan       guibg=DarkCyan                                         cterm=underline    gui=underline
                               hi ansiWhiteUnderline    ctermbg=LightGray      guibg=LightGray                                        cterm=underline    gui=underline
                            
                               hi ansiBlink                                                                                   cterm=standout     gui=undercurl
                               hi ansiBlinkBlack        ctermfg=Black      guifg=Black                                        cterm=standout     gui=undercurl
                               hi ansiBlinkRed          ctermfg=DarkRed        guifg=DarkRed                                          cterm=standout     gui=undercurl
                               hi ansiBlinkGreen        ctermfg=DarkGreen      guifg=DarkGreen                                        cterm=standout     gui=undercurl
                               hi ansiBlinkYellow       ctermfg=DarkYellow     guifg=DarkYellow                                       cterm=standout     gui=undercurl
                               hi ansiBlinkBlue         ctermfg=DarkBlue       guifg=DarkBlue                                         cterm=standout     gui=undercurl
                               hi ansiBlinkMagenta      ctermfg=DarkMagenta    guifg=DarkMagenta                                      cterm=standout     gui=undercurl
                               hi ansiBlinkCyan         ctermfg=DarkCyan       guifg=DarkCyan                                         cterm=standout     gui=undercurl
                               hi ansiBlinkWhite        ctermfg=LightGray      guifg=LightGray                                        cterm=standout     gui=undercurl
                               hi ansiBlinkGray         ctermfg=DarkGray       guifg=DarkGray                                         cterm=standout     gui=undercurl
                            
                               hi ansiRapidBlink                                                                              cterm=standout     gui=undercurl
                               hi ansiRapidBlinkBlack   ctermfg=Black      guifg=Black                                        cterm=standout     gui=undercurl
                               hi ansiRapidBlinkRed     ctermfg=DarkRed        guifg=DarkRed                                          cterm=standout     gui=undercurl
                               hi ansiRapidBlinkGreen   ctermfg=DarkGreen      guifg=DarkGreen                                        cterm=standout     gui=undercurl
                               hi ansiRapidBlinkYellow  ctermfg=DarkYellow     guifg=DarkYellow                                       cterm=standout     gui=undercurl
                               hi ansiRapidBlinkBlue    ctermfg=DarkBlue       guifg=DarkBlue                                         cterm=standout     gui=undercurl
                               hi ansiRapidBlinkMagenta ctermfg=DarkMagenta    guifg=DarkMagenta                                      cterm=standout     gui=undercurl
                               hi ansiRapidBlinkCyan    ctermfg=DarkCyan       guifg=DarkCyan                                         cterm=standout     gui=undercurl
                               hi ansiRapidBlinkWhite   ctermfg=LightGray      guifg=LightGray                                        cterm=standout     gui=undercurl
                               hi ansiRapidBlinkGray    ctermfg=DarkGray       guifg=DarkGray                                         cterm=standout     gui=undercurl
                            
                               hi ansiRV                                                                                      cterm=reverse      gui=reverse
                               hi ansiRVBlack           ctermfg=Black      guifg=Black                                        cterm=reverse      gui=reverse
                               hi ansiRVRed             ctermfg=DarkRed        guifg=DarkRed                                          cterm=reverse      gui=reverse
                               hi ansiRVGreen           ctermfg=DarkGreen      guifg=DarkGreen                                        cterm=reverse      gui=reverse
                               hi ansiRVYellow          ctermfg=DarkYellow     guifg=DarkYellow                                       cterm=reverse      gui=reverse
                               hi ansiRVBlue            ctermfg=DarkBlue       guifg=DarkBlue                                         cterm=reverse      gui=reverse
                               hi ansiRVMagenta         ctermfg=DarkMagenta    guifg=DarkMagenta                                      cterm=reverse      gui=reverse
                               hi ansiRVCyan            ctermfg=DarkCyan       guifg=DarkCyan                                         cterm=reverse      gui=reverse
                               hi ansiRVWhite           ctermfg=LightGray      guifg=LightGray                                        cterm=reverse      gui=reverse
                               hi ansiRVGray            ctermfg=DarkGray       guifg=DarkGray                                         cterm=reverse      gui=reverse
                            
                               hi ansiBoldDefault         ctermfg=NONE           ctermbg=NONE      guifg=NONE           guibg=NONE    cterm=bold         gui=bold
                               hi ansiUnderlineDefault    ctermfg=NONE           ctermbg=NONE      guifg=NONE           guibg=NONE    cterm=underline    gui=underline
                               hi ansiBlackDefault        ctermfg=Black          ctermbg=NONE      guifg=Black          guibg=NONE    cterm=NONE         gui=NONE
                               hi ansiRedDefault          ctermfg=DarkRed        ctermbg=NONE      guifg=DarkRed        guibg=NONE    cterm=NONE         gui=NONE
                               hi ansiGreenDefault        ctermfg=DarkGreen      ctermbg=NONE      guifg=DarkGreen      guibg=NONE    cterm=NONE         gui=NONE
                               hi ansiYellowDefault       ctermfg=DarkYellow     ctermbg=NONE      guifg=DarkYellow     guibg=NONE    cterm=NONE         gui=NONE
                               hi ansiBlueDefault         ctermfg=DarkBlue       ctermbg=NONE      guifg=DarkBlue       guibg=NONE    cterm=NONE         gui=NONE
                               hi ansiMagentaDefault      ctermfg=DarkMagenta    ctermbg=NONE      guifg=DarkMagenta    guibg=NONE    cterm=NONE         gui=NONE
                               hi ansiCyanDefault         ctermfg=DarkCyan       ctermbg=NONE      guifg=DarkCyan       guibg=NONE    cterm=NONE         gui=NONE
                               hi ansiWhiteDefault        ctermfg=LightGray      ctermbg=NONE      guifg=LightGray      guibg=NONE    cterm=NONE         gui=NONE
                               hi ansiGrayDefault         ctermfg=DarkGray      ctermbg=NONE      guifg=DarkGray      guibg=NONE    cterm=NONE         gui=NONE
                            
                               hi ansiDefaultDefault      ctermfg=NONE      ctermbg=NONE       guifg=NONE       guibg=NONE    cterm=NONE         gui=NONE
                               hi ansiDefaultBlack        ctermfg=NONE      ctermbg=Black      guifg=NONE       guibg=Black   cterm=NONE         gui=NONE
                               hi ansiDefaultRed          ctermfg=NONE        ctermbg=DarkRed      guifg=NONE        guibg=DarkRed    cterm=NONE         gui=NONE
                               hi ansiDefaultGreen        ctermfg=NONE      ctermbg=DarkGreen      guifg=NONE      guibg=DarkGreen    cterm=NONE         gui=NONE
                               hi ansiDefaultYellow       ctermfg=NONE     ctermbg=DarkYellow      guifg=NONE     guibg=DarkYellow    cterm=NONE         gui=NONE
                               hi ansiDefaultBlue         ctermfg=NONE       ctermbg=DarkBlue      guifg=NONE       guibg=DarkBlue    cterm=NONE         gui=NONE
                               hi ansiDefaultMagenta      ctermfg=NONE    ctermbg=DarkMagenta      guifg=NONE    guibg=DarkMagenta    cterm=NONE         gui=NONE
                               hi ansiDefaultCyan         ctermfg=NONE       ctermbg=DarkCyan      guifg=NONE       guibg=DarkCyan    cterm=NONE         gui=NONE
                               hi ansiDefaultWhite        ctermfg=NONE      ctermbg=LightGray      guifg=NONE      guibg=LightGray    cterm=NONE         gui=NONE
                               hi ansiDefaultGray         ctermfg=NONE      ctermbg=DarkGray      guifg=NONE      guibg=DarkGray    cterm=NONE         gui=NONE
                            
                               hi ansiBlackBlack        ctermfg=Black      ctermbg=Black      guifg=Black      guibg=Black    cterm=NONE         gui=NONE
                               hi ansiRedBlack          ctermfg=DarkRed        ctermbg=Black      guifg=DarkRed        guibg=Black    cterm=NONE         gui=NONE
                               hi ansiGreenBlack        ctermfg=DarkGreen      ctermbg=Black      guifg=DarkGreen      guibg=Black    cterm=NONE         gui=NONE
                               hi ansiYellowBlack       ctermfg=DarkYellow     ctermbg=Black      guifg=DarkYellow     guibg=Black    cterm=NONE         gui=NONE
                               hi ansiBlueBlack         ctermfg=DarkBlue       ctermbg=Black      guifg=DarkBlue       guibg=Black    cterm=NONE         gui=NONE
                               hi ansiMagentaBlack      ctermfg=DarkMagenta    ctermbg=Black      guifg=DarkMagenta    guibg=Black    cterm=NONE         gui=NONE
                               hi ansiCyanBlack         ctermfg=DarkCyan       ctermbg=Black      guifg=DarkCyan       guibg=Black    cterm=NONE         gui=NONE
                               hi ansiWhiteBlack        ctermfg=LightGray      ctermbg=Black      guifg=LightGray      guibg=Black    cterm=NONE         gui=NONE
                               hi ansiGrayBlack         ctermfg=DarkGray       ctermbg=Black      guifg=DarkGray       guibg=Black    cterm=NONE         gui=NONE
                            
                               hi ansiBlackRed          ctermfg=Black      ctermbg=DarkRed        guifg=Black      guibg=DarkRed      cterm=NONE         gui=NONE
                               hi ansiRedRed            ctermfg=DarkRed        ctermbg=DarkRed        guifg=DarkRed        guibg=DarkRed      cterm=NONE         gui=NONE
                               hi ansiGreenRed          ctermfg=DarkGreen      ctermbg=DarkRed        guifg=DarkGreen      guibg=DarkRed      cterm=NONE         gui=NONE
                               hi ansiYellowRed         ctermfg=DarkYellow     ctermbg=DarkRed        guifg=DarkYellow     guibg=DarkRed      cterm=NONE         gui=NONE
                               hi ansiBlueRed           ctermfg=DarkBlue       ctermbg=DarkRed        guifg=DarkBlue       guibg=DarkRed      cterm=NONE         gui=NONE
                               hi ansiMagentaRed        ctermfg=DarkMagenta    ctermbg=DarkRed        guifg=DarkMagenta    guibg=DarkRed      cterm=NONE         gui=NONE
                               hi ansiCyanRed           ctermfg=DarkCyan       ctermbg=DarkRed        guifg=DarkCyan       guibg=DarkRed      cterm=NONE         gui=NONE
                               hi ansiWhiteRed          ctermfg=LightGray      ctermbg=DarkRed        guifg=LightGray      guibg=DarkRed      cterm=NONE         gui=NONE
                               hi ansiGrayRed           ctermfg=DarkGray       ctermbg=DarkRed        guifg=DarkGray       guibg=DarkRed      cterm=NONE         gui=NONE
                            
                               hi ansiBlackGreen        ctermfg=Black      ctermbg=DarkGreen      guifg=Black      guibg=DarkGreen    cterm=NONE         gui=NONE
                               hi ansiRedGreen          ctermfg=DarkRed        ctermbg=DarkGreen      guifg=DarkRed        guibg=DarkGreen    cterm=NONE         gui=NONE
                               hi ansiGreenGreen        ctermfg=DarkGreen      ctermbg=DarkGreen      guifg=DarkGreen      guibg=DarkGreen    cterm=NONE         gui=NONE
                               hi ansiYellowGreen       ctermfg=DarkYellow     ctermbg=DarkGreen      guifg=DarkYellow     guibg=DarkGreen    cterm=NONE         gui=NONE
                               hi ansiBlueGreen         ctermfg=DarkBlue       ctermbg=DarkGreen      guifg=DarkBlue       guibg=DarkGreen    cterm=NONE         gui=NONE
                               hi ansiMagentaGreen      ctermfg=DarkMagenta    ctermbg=DarkGreen      guifg=DarkMagenta    guibg=DarkGreen    cterm=NONE         gui=NONE
                               hi ansiCyanGreen         ctermfg=DarkCyan       ctermbg=DarkGreen      guifg=DarkCyan       guibg=DarkGreen    cterm=NONE         gui=NONE
                               hi ansiWhiteGreen        ctermfg=LightGray      ctermbg=DarkGreen      guifg=LightGray      guibg=DarkGreen    cterm=NONE         gui=NONE
                               hi ansiGrayGreen         ctermfg=DarkGray       ctermbg=DarkGreen      guifg=DarkGray       guibg=DarkGreen    cterm=NONE         gui=NONE
                            
                               hi ansiBlackYellow       ctermfg=Black      ctermbg=DarkYellow     guifg=Black      guibg=DarkYellow   cterm=NONE         gui=NONE
                               hi ansiRedYellow         ctermfg=DarkRed        ctermbg=DarkYellow     guifg=DarkRed        guibg=DarkYellow   cterm=NONE         gui=NONE
                               hi ansiGreenYellow       ctermfg=DarkGreen      ctermbg=DarkYellow     guifg=DarkGreen      guibg=DarkYellow   cterm=NONE         gui=NONE
                               hi ansiYellowYellow      ctermfg=DarkYellow     ctermbg=DarkYellow     guifg=DarkYellow     guibg=DarkYellow   cterm=NONE         gui=NONE
                               hi ansiBlueYellow        ctermfg=DarkBlue       ctermbg=DarkYellow     guifg=DarkBlue       guibg=DarkYellow   cterm=NONE         gui=NONE
                               hi ansiMagentaYellow     ctermfg=DarkMagenta    ctermbg=DarkYellow     guifg=DarkMagenta    guibg=DarkYellow   cterm=NONE         gui=NONE
                               hi ansiCyanYellow        ctermfg=DarkCyan       ctermbg=DarkYellow     guifg=DarkCyan       guibg=DarkYellow   cterm=NONE         gui=NONE
                               hi ansiWhiteYellow       ctermfg=LightGray      ctermbg=DarkYellow     guifg=LightGray      guibg=DarkYellow   cterm=NONE         gui=NONE
                               hi ansiGrayYellow        ctermfg=DarkGray       ctermbg=DarkYellow     guifg=DarkGray       guibg=DarkYellow   cterm=NONE         gui=NONE
                            
                               hi ansiBlackBlue         ctermfg=Black      ctermbg=DarkBlue       guifg=Black      guibg=DarkBlue     cterm=NONE         gui=NONE
                               hi ansiRedBlue           ctermfg=DarkRed        ctermbg=DarkBlue       guifg=DarkRed        guibg=DarkBlue     cterm=NONE         gui=NONE
                               hi ansiGreenBlue         ctermfg=DarkGreen      ctermbg=DarkBlue       guifg=DarkGreen      guibg=DarkBlue     cterm=NONE         gui=NONE
                               hi ansiYellowBlue        ctermfg=DarkYellow     ctermbg=DarkBlue       guifg=DarkYellow     guibg=DarkBlue     cterm=NONE         gui=NONE
                               hi ansiBlueBlue          ctermfg=DarkBlue       ctermbg=DarkBlue       guifg=DarkBlue       guibg=DarkBlue     cterm=NONE         gui=NONE
                               hi ansiMagentaBlue       ctermfg=DarkMagenta    ctermbg=DarkBlue       guifg=DarkMagenta    guibg=DarkBlue     cterm=NONE         gui=NONE
                               hi ansiCyanBlue          ctermfg=DarkCyan       ctermbg=DarkBlue       guifg=DarkCyan       guibg=DarkBlue     cterm=NONE         gui=NONE
                               hi ansiWhiteBlue         ctermfg=LightGray      ctermbg=DarkBlue       guifg=LightGray      guibg=DarkBlue     cterm=NONE         gui=NONE
                               hi ansiGrayBlue          ctermfg=DarkGray       ctermbg=DarkBlue       guifg=DarkGray       guibg=DarkBlue     cterm=NONE         gui=NONE
                            
                               hi ansiBlackMagenta      ctermfg=Black      ctermbg=DarkMagenta    guifg=Black      guibg=DarkMagenta  cterm=NONE         gui=NONE
                               hi ansiRedMagenta        ctermfg=DarkRed        ctermbg=DarkMagenta    guifg=DarkRed        guibg=DarkMagenta  cterm=NONE         gui=NONE
                               hi ansiGreenMagenta      ctermfg=DarkGreen      ctermbg=DarkMagenta    guifg=DarkGreen      guibg=DarkMagenta  cterm=NONE         gui=NONE
                               hi ansiYellowMagenta     ctermfg=DarkYellow     ctermbg=DarkMagenta    guifg=DarkYellow     guibg=DarkMagenta  cterm=NONE         gui=NONE
                               hi ansiBlueMagenta       ctermfg=DarkBlue       ctermbg=DarkMagenta    guifg=DarkBlue       guibg=DarkMagenta  cterm=NONE         gui=NONE
                               hi ansiMagentaMagenta    ctermfg=DarkMagenta    ctermbg=DarkMagenta    guifg=DarkMagenta    guibg=DarkMagenta  cterm=NONE         gui=NONE
                               hi ansiCyanMagenta       ctermfg=DarkCyan       ctermbg=DarkMagenta    guifg=DarkCyan       guibg=DarkMagenta  cterm=NONE         gui=NONE
                               hi ansiWhiteMagenta      ctermfg=LightGray      ctermbg=DarkMagenta    guifg=LightGray      guibg=DarkMagenta  cterm=NONE         gui=NONE
                               hi ansiGrayMagenta       ctermfg=DarkGray       ctermbg=DarkMagenta    guifg=DarkGray       guibg=DarkMagenta  cterm=NONE         gui=NONE
                            
                               hi ansiBlackCyan         ctermfg=Black      ctermbg=DarkCyan       guifg=Black      guibg=DarkCyan     cterm=NONE         gui=NONE
                               hi ansiRedCyan           ctermfg=DarkRed        ctermbg=DarkCyan       guifg=DarkRed        guibg=DarkCyan     cterm=NONE         gui=NONE
                               hi ansiGreenCyan         ctermfg=DarkGreen      ctermbg=DarkCyan       guifg=DarkGreen      guibg=DarkCyan     cterm=NONE         gui=NONE
                               hi ansiYellowCyan        ctermfg=DarkYellow     ctermbg=DarkCyan       guifg=DarkYellow     guibg=DarkCyan     cterm=NONE         gui=NONE
                               hi ansiBlueCyan          ctermfg=DarkBlue       ctermbg=DarkCyan       guifg=DarkBlue       guibg=DarkCyan     cterm=NONE         gui=NONE
                               hi ansiMagentaCyan       ctermfg=DarkMagenta    ctermbg=DarkCyan       guifg=DarkMagenta    guibg=DarkCyan     cterm=NONE         gui=NONE
                               hi ansiCyanCyan          ctermfg=DarkCyan       ctermbg=DarkCyan       guifg=DarkCyan       guibg=DarkCyan     cterm=NONE         gui=NONE
                               hi ansiWhiteCyan         ctermfg=LightGray      ctermbg=DarkCyan       guifg=LightGray      guibg=DarkCyan     cterm=NONE         gui=NONE
                               hi ansiGrayCyan          ctermfg=DarkGray       ctermbg=DarkCyan       guifg=DarkGray       guibg=DarkCyan     cterm=NONE         gui=NONE
                            
                               hi ansiBlackWhite        ctermfg=Black      ctermbg=LightGray      guifg=Black      guibg=LightGray    cterm=NONE         gui=NONE
                               hi ansiRedWhite          ctermfg=DarkRed        ctermbg=LightGray      guifg=DarkRed        guibg=LightGray    cterm=NONE         gui=NONE
                               hi ansiGreenWhite        ctermfg=DarkGreen      ctermbg=LightGray      guifg=DarkGreen      guibg=LightGray    cterm=NONE         gui=NONE
                               hi ansiYellowWhite       ctermfg=DarkYellow     ctermbg=LightGray      guifg=DarkYellow     guibg=LightGray    cterm=NONE         gui=NONE
                               hi ansiBlueWhite         ctermfg=DarkBlue       ctermbg=LightGray      guifg=DarkBlue       guibg=LightGray    cterm=NONE         gui=NONE
                               hi ansiMagentaWhite      ctermfg=DarkMagenta    ctermbg=LightGray      guifg=DarkMagenta    guibg=LightGray    cterm=NONE         gui=NONE
                               hi ansiCyanWhite         ctermfg=DarkCyan       ctermbg=LightGray      guifg=DarkCyan       guibg=LightGray    cterm=NONE         gui=NONE
                               hi ansiWhiteWhite        ctermfg=LightGray      ctermbg=LightGray      guifg=LightGray      guibg=LightGray    cterm=NONE         gui=NONE
                               hi ansiGrayWhite         ctermfg=DarkGray       ctermbg=LightGray      guifg=DarkGray       guibg=LightGray    cterm=NONE         gui=NONE
                            
                               hi ansiBlackGray         ctermfg=Black      ctermbg=DarkGray       guifg=Black      guibg=DarkGray     cterm=NONE         gui=NONE
                               hi ansiRedGray           ctermfg=DarkRed        ctermbg=DarkGray       guifg=DarkRed        guibg=DarkGray     cterm=NONE         gui=NONE
                               hi ansiGreenGray         ctermfg=DarkGreen      ctermbg=DarkGray       guifg=DarkGreen      guibg=DarkGray     cterm=NONE         gui=NONE
                               hi ansiYellowGray        ctermfg=DarkYellow     ctermbg=DarkGray       guifg=DarkYellow     guibg=DarkGray     cterm=NONE         gui=NONE
                               hi ansiBlueGray          ctermfg=DarkBlue       ctermbg=DarkGray       guifg=DarkBlue       guibg=DarkGray     cterm=NONE         gui=NONE
                               hi ansiMagentaGray       ctermfg=DarkMagenta    ctermbg=DarkGray       guifg=DarkMagenta    guibg=DarkGray     cterm=NONE         gui=NONE
                               hi ansiCyanGray          ctermfg=DarkCyan       ctermbg=DarkGray       guifg=DarkCyan       guibg=DarkGray     cterm=NONE         gui=NONE
                               hi ansiWhiteGray         ctermfg=LightGray      ctermbg=DarkGray       guifg=LightGray      guibg=DarkGray     cterm=NONE         gui=NONE
                               hi ansiGrayGray          ctermfg=DarkGray       ctermbg=DarkGray       guifg=DarkGray       guibg=DarkGray     cterm=NONE         gui=NONE
                            
                               if v:version >= 700 && exists("+t_Co") && &t_Co == 256 && exists("g:ansiesc_256color")
                                " ---------------------------
                                " handle 256-color terminals: {{{3
                                " ---------------------------
                            "    call Decho("set up 256-color highlighting groups")
                                let icolor= 1
                                while icolor < 256
                                 let jcolor= 1
                                 exe "hi ansiHL_".icolor."_0 ctermfg=".icolor
                                 exe "hi ansiHL_0_".icolor." ctermbg=".icolor
                            "     call Decho("exe hi ansiHL_".icolor." ctermfg=".icolor)
                                 while jcolor < 256
                                  exe "hi ansiHL_".icolor."_".jcolor." ctermfg=".icolor." ctermbg=".jcolor
                            "      call Decho("exe hi ansiHL_".icolor."_".jcolor." ctermfg=".icolor." ctermbg=".jcolor)
                                  let jcolor= jcolor + 1
                                 endwhile
                                 let icolor= icolor + 1
                                endwhile
                               endif
                            
                              else
                               " ----------------------------------
                               " not 8 or 256 color terminals (gui): {{{3
                               " ----------------------------------
                            "   call Decho("set up gui highlighting groups")
                               hi ansiBlack             ctermfg=Black      guifg=Black                                        cterm=NONE         gui=NONE
                               hi ansiRed               ctermfg=DarkRed        guifg=DarkRed                                          cterm=NONE         gui=NONE
                               hi ansiGreen             ctermfg=DarkGreen      guifg=DarkGreen                                        cterm=NONE         gui=NONE
                               hi ansiYellow            ctermfg=DarkYellow     guifg=DarkYellow                                       cterm=NONE         gui=NONE
                               hi ansiBlue              ctermfg=DarkBlue       guifg=DarkBlue                                         cterm=NONE         gui=NONE
                               hi ansiMagenta           ctermfg=DarkMagenta    guifg=DarkMagenta                                      cterm=NONE         gui=NONE
                               hi ansiCyan              ctermfg=DarkCyan       guifg=DarkCyan                                         cterm=NONE         gui=NONE
                               hi ansiWhite             ctermfg=LightGray      guifg=LightGray                                        cterm=NONE         gui=NONE
                               hi ansiGray              ctermfg=DarkGray       guifg=DarkGray                                         cterm=NONE         gui=NONE
                            
                               hi ansiBlackFg           ctermfg=Black      guifg=Black                                        cterm=NONE         gui=NONE
                               hi ansiRedFg             ctermfg=DarkRed        guifg=DarkRed                                          cterm=NONE         gui=NONE
                               hi ansiGreenFg           ctermfg=DarkGreen      guifg=DarkGreen                                        cterm=NONE         gui=NONE
                               hi ansiYellowFg          ctermfg=DarkYellow     guifg=DarkYellow                                       cterm=NONE         gui=NONE
                               hi ansiBlueFg            ctermfg=DarkBlue       guifg=DarkBlue                                         cterm=NONE         gui=NONE
                               hi ansiMagentaFg         ctermfg=DarkMagenta    guifg=DarkMagenta                                      cterm=NONE         gui=NONE
                               hi ansiCyanFg            ctermfg=DarkCyan       guifg=DarkCyan                                         cterm=NONE         gui=NONE
                               hi ansiWhiteFg           ctermfg=LightGray      guifg=LightGray                                        cterm=NONE         gui=NONE
                               hi ansiGrayFg            ctermfg=DarkGray       guifg=DarkGray                                         cterm=NONE         gui=NONE
                            
                               hi ansiDefaultBg         ctermbg=NONE       guibg=NONE                                         cterm=NONE         gui=NONE
                               hi ansiBlackBg           ctermbg=Black      guibg=Black                                        cterm=NONE         gui=NONE
                               hi ansiRedBg             ctermbg=DarkRed        guibg=DarkRed                                          cterm=NONE         gui=NONE
                               hi ansiGreenBg           ctermbg=DarkGreen      guibg=DarkGreen                                        cterm=NONE         gui=NONE
                               hi ansiYellowBg          ctermbg=DarkYellow     guibg=DarkYellow                                       cterm=NONE         gui=NONE
                               hi ansiBlueBg            ctermbg=DarkBlue       guibg=DarkBlue                                         cterm=NONE         gui=NONE
                               hi ansiMagentaBg         ctermbg=DarkMagenta    guibg=DarkMagenta                                      cterm=NONE         gui=NONE
                               hi ansiCyanBg            ctermbg=DarkCyan       guibg=DarkCyan                                         cterm=NONE         gui=NONE
                               hi ansiWhiteBg           ctermbg=LightGray      guibg=LightGray                                        cterm=NONE         gui=NONE
                               hi ansiGrayBg            ctermbg=DarkGray       guibg=DarkGray                                         cterm=NONE         gui=NONE
                            
                               hi ansiDefaultReverseBg         ctermbg=NONE       guibg=NONE                                         cterm=reverse         gui=reverse
                               hi ansiBlackReverseBg           ctermbg=Black      guibg=Black                                        cterm=reverse         gui=reverse
                               hi ansiRedReverseBg             ctermbg=DarkRed        guibg=DarkRed                                          cterm=reverse         gui=reverse
                               hi ansiGreenReverseBg           ctermbg=DarkGreen      guibg=DarkGreen                                        cterm=reverse         gui=reverse
                               hi ansiYellowReverseBg          ctermbg=DarkYellow     guibg=DarkYellow                                       cterm=reverse         gui=reverse
                               hi ansiBlueReverseBg            ctermbg=DarkBlue       guibg=DarkBlue                                         cterm=reverse         gui=reverse
                               hi ansiMagentaReverseBg         ctermbg=DarkMagenta    guibg=DarkMagenta                                      cterm=reverse         gui=reverse
                               hi ansiCyanReverseBg            ctermbg=DarkCyan       guibg=DarkCyan                                         cterm=reverse         gui=reverse
                               hi ansiWhiteReverseBg           ctermbg=LightGray      guibg=LightGray                                        cterm=reverse         gui=reverse
                               hi ansiGrayReverseBg            ctermbg=DarkGray      guibg=DarkGray                                        cterm=reverse         gui=reverse
                            
                               hi ansiBold                                                                                    cterm=bold         gui=bold
                               hi ansiBoldUnderline                                                                           cterm=bold,underline gui=bold,underline
                               hi ansiBoldBlack         ctermfg=Black      guifg=Black                                        cterm=bold         gui=bold
                               hi ansiBoldRed           ctermfg=DarkRed        guifg=DarkRed                                          cterm=bold         gui=bold
                               hi ansiBoldGreen         ctermfg=DarkGreen      guifg=DarkGreen                                        cterm=bold         gui=bold
                               hi ansiBoldYellow        ctermfg=DarkYellow     guifg=DarkYellow                                       cterm=bold         gui=bold
                               hi ansiBoldBlue          ctermfg=DarkBlue       guifg=DarkBlue                                         cterm=bold         gui=bold
                               hi ansiBoldMagenta       ctermfg=DarkMagenta    guifg=DarkMagenta                                      cterm=bold         gui=bold
                               hi ansiBoldCyan          ctermfg=DarkCyan       guifg=DarkCyan                                         cterm=bold         gui=bold
                               hi ansiBoldWhite         ctermfg=LightGray      guifg=LightGray                                        cterm=bold         gui=bold
                               hi ansiBoldGray          ctermfg=DarkGray      guifg=DarkGray                                        cterm=bold         gui=bold
                            
                               hi ansiBlackBold         ctermbg=Black      guibg=Black                                        cterm=bold         gui=bold
                               hi ansiRedBold           ctermbg=DarkRed        guibg=DarkRed                                          cterm=bold         gui=bold
                               hi ansiGreenBold         ctermbg=DarkGreen      guibg=DarkGreen                                        cterm=bold         gui=bold
                               hi ansiYellowBold        ctermbg=DarkYellow     guibg=DarkYellow                                       cterm=bold         gui=bold
                               hi ansiBlueBold          ctermbg=DarkBlue       guibg=DarkBlue                                         cterm=bold         gui=bold
                               hi ansiMagentaBold       ctermbg=DarkMagenta    guibg=DarkMagenta                                      cterm=bold         gui=bold
                               hi ansiCyanBold          ctermbg=DarkCyan       guibg=DarkCyan                                         cterm=bold         gui=bold
                               hi ansiWhiteBold         ctermbg=LightGray      guibg=LightGray                                        cterm=bold         gui=bold
                               hi ansiGrayBold          ctermbg=DarkGray      guibg=DarkGray                                        cterm=bold         gui=bold
                            
                               hi ansiReverse                                                                                 cterm=reverse      gui=reverse
                               hi ansiReverseUnderline                                                                        cterm=reverse,underline gui=reverse,underline
                               hi ansiReverseBold                                                                             cterm=reverse,bold gui=reverse,bold
                               hi ansiReverseBoldUnderline                                                                    cterm=reverse,bold,underline gui=reverse,bold,underline
                               hi ansiReverseBlack      ctermfg=Black      guifg=Black                                        cterm=reverse         gui=reverse
                               hi ansiReverseRed        ctermfg=DarkRed        guifg=DarkRed                                          cterm=reverse         gui=reverse
                               hi ansiReverseGreen      ctermfg=DarkGreen      guifg=DarkGreen                                        cterm=reverse         gui=reverse
                               hi ansiReverseYellow     ctermfg=DarkYellow     guifg=DarkYellow                                       cterm=reverse         gui=reverse
                               hi ansiReverseBlue       ctermfg=DarkBlue       guifg=DarkBlue                                         cterm=reverse         gui=reverse
                               hi ansiReverseMagenta    ctermfg=DarkMagenta    guifg=DarkMagenta                                      cterm=reverse         gui=reverse
                               hi ansiReverseCyan       ctermfg=DarkCyan       guifg=DarkCyan                                         cterm=reverse         gui=reverse
                               hi ansiReverseWhite      ctermfg=LightGray      guifg=LightGray                                        cterm=reverse         gui=reverse
                               hi ansiReverseGray       ctermfg=DarkGray      guifg=DarkGray                                        cterm=reverse         gui=reverse
                            
                               hi ansiStandout                                                                                cterm=standout     gui=standout
                               hi ansiStandoutBlack     ctermfg=Black      guifg=Black                                        cterm=standout     gui=standout
                               hi ansiStandoutRed       ctermfg=DarkRed        guifg=DarkRed                                          cterm=standout     gui=standout
                               hi ansiStandoutGreen     ctermfg=DarkGreen      guifg=DarkGreen                                        cterm=standout     gui=standout
                               hi ansiStandoutYellow    ctermfg=DarkYellow     guifg=DarkYellow                                       cterm=standout     gui=standout
                               hi ansiStandoutBlue      ctermfg=DarkBlue       guifg=DarkBlue                                         cterm=standout     gui=standout
                               hi ansiStandoutMagenta   ctermfg=DarkMagenta    guifg=DarkMagenta                                      cterm=standout     gui=standout
                               hi ansiStandoutCyan      ctermfg=DarkCyan       guifg=DarkCyan                                         cterm=standout     gui=standout
                               hi ansiStandoutWhite     ctermfg=LightGray      guifg=LightGray                                        cterm=standout     gui=standout
                               hi ansiStandoutGray      ctermfg=DarkGray      guifg=DarkGray                                        cterm=standout     gui=standout
                            
                               hi ansiItalic                                                                                  cterm=italic       gui=italic
                               hi ansiItalicBlack       ctermfg=Black      guifg=Black                                        cterm=italic       gui=italic
                               hi ansiItalicRed         ctermfg=DarkRed        guifg=DarkRed                                          cterm=italic       gui=italic
                               hi ansiItalicGreen       ctermfg=DarkGreen      guifg=DarkGreen                                        cterm=italic       gui=italic
                               hi ansiItalicYellow      ctermfg=DarkYellow     guifg=DarkYellow                                       cterm=italic       gui=italic
                               hi ansiItalicBlue        ctermfg=DarkBlue       guifg=DarkBlue                                         cterm=italic       gui=italic
                               hi ansiItalicMagenta     ctermfg=DarkMagenta    guifg=DarkMagenta                                      cterm=italic       gui=italic
                               hi ansiItalicCyan        ctermfg=DarkCyan       guifg=DarkCyan                                         cterm=italic       gui=italic
                               hi ansiItalicWhite       ctermfg=LightGray      guifg=LightGray                                        cterm=italic       gui=italic
                               hi ansiItalicGray        ctermfg=DarkGray      guifg=DarkGray                                        cterm=italic       gui=italic
                            
                               hi ansiUnderline                                                                               cterm=underline    gui=underline
                               hi ansiUnderlineBlack    ctermfg=Black      guifg=Black                                        cterm=underline    gui=underline
                               hi ansiUnderlineRed      ctermfg=DarkRed        guifg=DarkRed                                          cterm=underline    gui=underline
                               hi ansiUnderlineGreen    ctermfg=DarkGreen      guifg=DarkGreen                                        cterm=underline    gui=underline
                               hi ansiUnderlineYellow   ctermfg=DarkYellow     guifg=DarkYellow                                       cterm=underline    gui=underline
                               hi ansiUnderlineBlue     ctermfg=DarkBlue       guifg=DarkBlue                                         cterm=underline    gui=underline
                               hi ansiUnderlineMagenta  ctermfg=DarkMagenta    guifg=DarkMagenta                                      cterm=underline    gui=underline
                               hi ansiUnderlineCyan     ctermfg=DarkCyan       guifg=DarkCyan                                         cterm=underline    gui=underline
                               hi ansiUnderlineWhite    ctermfg=LightGray      guifg=LightGray                                        cterm=underline    gui=underline
                               hi ansiUnderlineGray     ctermfg=DarkGray      guifg=DarkGray                                        cterm=underline    gui=underline
                            
                               hi ansiBlackUnderline    ctermbg=Black      guibg=Black                                        cterm=underline    gui=underline
                               hi ansiRedUnderline      ctermbg=DarkRed        guibg=DarkRed                                          cterm=underline    gui=underline
                               hi ansiGreenUnderline    ctermbg=DarkGreen      guibg=DarkGreen                                        cterm=underline    gui=underline
                               hi ansiYellowUnderline   ctermbg=DarkYellow     guibg=DarkYellow                                       cterm=underline    gui=underline
                               hi ansiBlueUnderline     ctermbg=DarkBlue       guibg=DarkBlue                                         cterm=underline    gui=underline
                               hi ansiMagentaUnderline  ctermbg=DarkMagenta    guibg=DarkMagenta                                      cterm=underline    gui=underline
                               hi ansiCyanUnderline     ctermbg=DarkCyan       guibg=DarkCyan                                         cterm=underline    gui=underline
                               hi ansiWhiteUnderline    ctermbg=LightGray      guibg=LightGray                                        cterm=underline    gui=underline
                               hi ansiGrayUnderline     ctermbg=DarkGray      guibg=DarkGray                                        cterm=underline    gui=underline
                            
                               hi ansiBlink                                                                                   cterm=standout     gui=undercurl
                               hi ansiBlinkBlack        ctermfg=Black      guifg=Black                                        cterm=standout     gui=undercurl
                               hi ansiBlinkRed          ctermfg=DarkRed        guifg=DarkRed                                          cterm=standout     gui=undercurl
                               hi ansiBlinkGreen        ctermfg=DarkGreen      guifg=DarkGreen                                        cterm=standout     gui=undercurl
                               hi ansiBlinkYellow       ctermfg=DarkYellow     guifg=DarkYellow                                       cterm=standout     gui=undercurl
                               hi ansiBlinkBlue         ctermfg=DarkBlue       guifg=DarkBlue                                         cterm=standout     gui=undercurl
                               hi ansiBlinkMagenta      ctermfg=DarkMagenta    guifg=DarkMagenta                                      cterm=standout     gui=undercurl
                               hi ansiBlinkCyan         ctermfg=DarkCyan       guifg=DarkCyan                                         cterm=standout     gui=undercurl
                               hi ansiBlinkWhite        ctermfg=LightGray      guifg=LightGray                                        cterm=standout     gui=undercurl
                               hi ansiBlinkGray         ctermfg=DarkGray      guifg=DarkGray                                        cterm=standout     gui=undercurl
                            
                               hi ansiRapidBlink                                                                              cterm=standout     gui=undercurl
                               hi ansiRapidBlinkBlack   ctermfg=Black      guifg=Black                                        cterm=standout     gui=undercurl
                               hi ansiRapidBlinkRed     ctermfg=DarkRed        guifg=DarkRed                                          cterm=standout     gui=undercurl
                               hi ansiRapidBlinkGreen   ctermfg=DarkGreen      guifg=DarkGreen                                        cterm=standout     gui=undercurl
                               hi ansiRapidBlinkYellow  ctermfg=DarkYellow     guifg=DarkYellow                                       cterm=standout     gui=undercurl
                               hi ansiRapidBlinkBlue    ctermfg=DarkBlue       guifg=DarkBlue                                         cterm=standout     gui=undercurl
                               hi ansiRapidBlinkMagenta ctermfg=DarkMagenta    guifg=DarkMagenta                                      cterm=standout     gui=undercurl
                               hi ansiRapidBlinkCyan    ctermfg=DarkCyan       guifg=DarkCyan                                         cterm=standout     gui=undercurl
                               hi ansiRapidBlinkWhite   ctermfg=LightGray      guifg=LightGray                                        cterm=standout     gui=undercurl
                               hi ansiRapidBlinkGray    ctermfg=DarkGray      guifg=DarkGray                                        cterm=standout     gui=undercurl
                            
                               hi ansiRV                                                                                      cterm=reverse      gui=reverse
                               hi ansiRVBlack           ctermfg=Black      guifg=Black                                        cterm=reverse      gui=reverse
                               hi ansiRVRed             ctermfg=DarkRed        guifg=DarkRed                                          cterm=reverse      gui=reverse
                               hi ansiRVGreen           ctermfg=DarkGreen      guifg=DarkGreen                                        cterm=reverse      gui=reverse
                               hi ansiRVYellow          ctermfg=DarkYellow     guifg=DarkYellow                                       cterm=reverse      gui=reverse
                               hi ansiRVBlue            ctermfg=DarkBlue       guifg=DarkBlue                                         cterm=reverse      gui=reverse
                               hi ansiRVMagenta         ctermfg=DarkMagenta    guifg=DarkMagenta                                      cterm=reverse      gui=reverse
                               hi ansiRVCyan            ctermfg=DarkCyan       guifg=DarkCyan                                         cterm=reverse      gui=reverse
                               hi ansiRVWhite           ctermfg=LightGray      guifg=LightGray                                        cterm=reverse      gui=reverse
                               hi ansiRVGray            ctermfg=DarkGray      guifg=DarkGray                                        cterm=reverse      gui=reverse
                            
                               hi ansiBoldDefault         ctermfg=NONE           ctermbg=NONE      guifg=NONE           guibg=NONE    cterm=bold         gui=bold
                               hi ansiUnderlineDefault    ctermfg=NONE           ctermbg=NONE      guifg=NONE           guibg=NONE    cterm=underline    gui=underline
                               hi ansiBlackDefault        ctermfg=Black          ctermbg=NONE      guifg=Black          guibg=NONE    cterm=NONE         gui=NONE
                               hi ansiRedDefault          ctermfg=DarkRed        ctermbg=NONE      guifg=DarkRed        guibg=NONE    cterm=NONE         gui=NONE
                               hi ansiGreenDefault        ctermfg=DarkGreen      ctermbg=NONE      guifg=DarkGreen      guibg=NONE    cterm=NONE         gui=NONE
                               hi ansiYellowDefault       ctermfg=DarkYellow     ctermbg=NONE      guifg=DarkYellow     guibg=NONE    cterm=NONE         gui=NONE
                               hi ansiBlueDefault         ctermfg=DarkBlue       ctermbg=NONE      guifg=DarkBlue       guibg=NONE    cterm=NONE         gui=NONE
                               hi ansiMagentaDefault      ctermfg=DarkMagenta    ctermbg=NONE      guifg=DarkMagenta    guibg=NONE    cterm=NONE         gui=NONE
                               hi ansiCyanDefault         ctermfg=DarkCyan       ctermbg=NONE      guifg=DarkCyan       guibg=NONE    cterm=NONE         gui=NONE
                               hi ansiWhiteDefault        ctermfg=LightGray      ctermbg=NONE      guifg=LightGray      guibg=NONE    cterm=NONE         gui=NONE
                               hi ansiGrayDefault         ctermfg=DarkGray       ctermbg=NONE      guifg=DarkGray       guibg=NONE    cterm=NONE         gui=NONE
                            
                               hi ansiDefaultDefault      ctermfg=NONE      ctermbg=NONE       guifg=NONE       guibg=NONE    cterm=NONE         gui=NONE
                               hi ansiDefaultBlack        ctermfg=NONE      ctermbg=Black      guifg=NONE       guibg=Black   cterm=NONE         gui=NONE
                               hi ansiDefaultRed          ctermfg=NONE        ctermbg=DarkRed      guifg=NONE        guibg=DarkRed    cterm=NONE         gui=NONE
                               hi ansiDefaultGreen        ctermfg=NONE      ctermbg=DarkGreen      guifg=NONE      guibg=DarkGreen    cterm=NONE         gui=NONE
                               hi ansiDefaultYellow       ctermfg=NONE     ctermbg=DarkYellow      guifg=NONE     guibg=DarkYellow    cterm=NONE         gui=NONE
                               hi ansiDefaultBlue         ctermfg=NONE       ctermbg=DarkBlue      guifg=NONE       guibg=DarkBlue    cterm=NONE         gui=NONE
                               hi ansiDefaultMagenta      ctermfg=NONE    ctermbg=DarkMagenta      guifg=NONE    guibg=DarkMagenta    cterm=NONE         gui=NONE
                               hi ansiDefaultCyan         ctermfg=NONE       ctermbg=DarkCyan      guifg=NONE       guibg=DarkCyan    cterm=NONE         gui=NONE
                               hi ansiDefaultWhite        ctermfg=NONE      ctermbg=LightGray      guifg=NONE      guibg=LightGray    cterm=NONE         gui=NONE
                               hi ansiDefaultGray         ctermfg=NONE      ctermbg=DarkGray       guifg=NONE      guibg=DarkGray     cterm=NONE         gui=NONE
                             
                               hi ansiBlackBlack        ctermfg=Black      ctermbg=Black      guifg=Black      guibg=Black    cterm=NONE         gui=NONE
                               hi ansiRedBlack          ctermfg=DarkRed        ctermbg=Black      guifg=DarkRed        guibg=Black    cterm=NONE         gui=NONE
                               hi ansiGreenBlack        ctermfg=DarkGreen      ctermbg=Black      guifg=DarkGreen      guibg=Black    cterm=NONE         gui=NONE
                               hi ansiYellowBlack       ctermfg=DarkYellow     ctermbg=Black      guifg=DarkYellow     guibg=Black    cterm=NONE         gui=NONE
                               hi ansiBlueBlack         ctermfg=DarkBlue       ctermbg=Black      guifg=DarkBlue       guibg=Black    cterm=NONE         gui=NONE
                               hi ansiMagentaBlack      ctermfg=DarkMagenta    ctermbg=Black      guifg=DarkMagenta    guibg=Black    cterm=NONE         gui=NONE
                               hi ansiCyanBlack         ctermfg=DarkCyan       ctermbg=Black      guifg=DarkCyan       guibg=Black    cterm=NONE         gui=NONE
                               hi ansiWhiteBlack        ctermfg=LightGray      ctermbg=Black      guifg=LightGray      guibg=Black    cterm=NONE         gui=NONE
                               hi ansiGrayBlack         ctermfg=DarkGray      ctermbg=Black      guifg=DarkGray      guibg=Black    cterm=NONE         gui=NONE
                            
                               hi ansiBlackRed          ctermfg=Black      ctermbg=DarkRed        guifg=Black      guibg=DarkRed      cterm=NONE         gui=NONE
                               hi ansiRedRed            ctermfg=DarkRed        ctermbg=DarkRed        guifg=DarkRed        guibg=DarkRed      cterm=NONE         gui=NONE
                               hi ansiGreenRed          ctermfg=DarkGreen      ctermbg=DarkRed        guifg=DarkGreen      guibg=DarkRed      cterm=NONE         gui=NONE
                               hi ansiYellowRed         ctermfg=DarkYellow     ctermbg=DarkRed        guifg=DarkYellow     guibg=DarkRed      cterm=NONE         gui=NONE
                               hi ansiBlueRed           ctermfg=DarkBlue       ctermbg=DarkRed        guifg=DarkBlue       guibg=DarkRed      cterm=NONE         gui=NONE
                               hi ansiMagentaRed        ctermfg=DarkMagenta    ctermbg=DarkRed        guifg=DarkMagenta    guibg=DarkRed      cterm=NONE         gui=NONE
                               hi ansiCyanRed           ctermfg=DarkCyan       ctermbg=DarkRed        guifg=DarkCyan       guibg=DarkRed      cterm=NONE         gui=NONE
                               hi ansiWhiteRed          ctermfg=LightGray      ctermbg=DarkRed        guifg=LightGray      guibg=DarkRed      cterm=NONE         gui=NONE
                               hi ansiGrayRed           ctermfg=DarkGray      ctermbg=DarkRed        guifg=DarkGray      guibg=DarkRed      cterm=NONE         gui=NONE
                            
                               hi ansiBlackGreen        ctermfg=Black      ctermbg=DarkGreen      guifg=Black      guibg=DarkGreen    cterm=NONE         gui=NONE
                               hi ansiRedGreen          ctermfg=DarkRed        ctermbg=DarkGreen      guifg=DarkRed        guibg=DarkGreen    cterm=NONE         gui=NONE
                               hi ansiGreenGreen        ctermfg=DarkGreen      ctermbg=DarkGreen      guifg=DarkGreen      guibg=DarkGreen    cterm=NONE         gui=NONE
                               hi ansiYellowGreen       ctermfg=DarkYellow     ctermbg=DarkGreen      guifg=DarkYellow     guibg=DarkGreen    cterm=NONE         gui=NONE
                               hi ansiBlueGreen         ctermfg=DarkBlue       ctermbg=DarkGreen      guifg=DarkBlue       guibg=DarkGreen    cterm=NONE         gui=NONE
                               hi ansiMagentaGreen      ctermfg=DarkMagenta    ctermbg=DarkGreen      guifg=DarkMagenta    guibg=DarkGreen    cterm=NONE         gui=NONE
                               hi ansiCyanGreen         ctermfg=DarkCyan       ctermbg=DarkGreen      guifg=DarkCyan       guibg=DarkGreen    cterm=NONE         gui=NONE
                               hi ansiWhiteGreen        ctermfg=LightGray      ctermbg=DarkGreen      guifg=LightGray      guibg=DarkGreen    cterm=NONE         gui=NONE
                               hi ansiGrayGreen         ctermfg=DarkGray      ctermbg=DarkGreen      guifg=DarkGray      guibg=DarkGreen    cterm=NONE         gui=NONE
                            
                               hi ansiBlackYellow       ctermfg=Black      ctermbg=DarkYellow     guifg=Black      guibg=DarkYellow   cterm=NONE         gui=NONE
                               hi ansiRedYellow         ctermfg=DarkRed        ctermbg=DarkYellow     guifg=DarkRed        guibg=DarkYellow   cterm=NONE         gui=NONE
                               hi ansiGreenYellow       ctermfg=DarkGreen      ctermbg=DarkYellow     guifg=DarkGreen      guibg=DarkYellow   cterm=NONE         gui=NONE
                               hi ansiYellowYellow      ctermfg=DarkYellow     ctermbg=DarkYellow     guifg=DarkYellow     guibg=DarkYellow   cterm=NONE         gui=NONE
                               hi ansiBlueYellow        ctermfg=DarkBlue       ctermbg=DarkYellow     guifg=DarkBlue       guibg=DarkYellow   cterm=NONE         gui=NONE
                               hi ansiMagentaYellow     ctermfg=DarkMagenta    ctermbg=DarkYellow     guifg=DarkMagenta    guibg=DarkYellow   cterm=NONE         gui=NONE
                               hi ansiCyanYellow        ctermfg=DarkCyan       ctermbg=DarkYellow     guifg=DarkCyan       guibg=DarkYellow   cterm=NONE         gui=NONE
                               hi ansiWhiteYellow       ctermfg=LightGray      ctermbg=DarkYellow     guifg=LightGray      guibg=DarkYellow   cterm=NONE         gui=NONE
                               hi ansiGrayYellow        ctermfg=DarkGray      ctermbg=DarkYellow     guifg=DarkGray      guibg=DarkYellow   cterm=NONE         gui=NONE
                            
                               hi ansiBlackBlue         ctermfg=Black      ctermbg=DarkBlue       guifg=Black      guibg=DarkBlue     cterm=NONE         gui=NONE
                               hi ansiRedBlue           ctermfg=DarkRed        ctermbg=DarkBlue       guifg=DarkRed        guibg=DarkBlue     cterm=NONE         gui=NONE
                               hi ansiGreenBlue         ctermfg=DarkGreen      ctermbg=DarkBlue       guifg=DarkGreen      guibg=DarkBlue     cterm=NONE         gui=NONE
                               hi ansiYellowBlue        ctermfg=DarkYellow     ctermbg=DarkBlue       guifg=DarkYellow     guibg=DarkBlue     cterm=NONE         gui=NONE
                               hi ansiBlueBlue          ctermfg=DarkBlue       ctermbg=DarkBlue       guifg=DarkBlue       guibg=DarkBlue     cterm=NONE         gui=NONE
                               hi ansiMagentaBlue       ctermfg=DarkMagenta    ctermbg=DarkBlue       guifg=DarkMagenta    guibg=DarkBlue     cterm=NONE         gui=NONE
                               hi ansiCyanBlue          ctermfg=DarkCyan       ctermbg=DarkBlue       guifg=DarkCyan       guibg=DarkBlue     cterm=NONE         gui=NONE
                               hi ansiWhiteBlue         ctermfg=LightGray      ctermbg=DarkBlue       guifg=LightGray      guibg=DarkBlue     cterm=NONE         gui=NONE
                               hi ansiGrayBlue          ctermfg=DarkGray      ctermbg=DarkBlue       guifg=DarkGray      guibg=DarkBlue     cterm=NONE         gui=NONE
                            
                               hi ansiBlackMagenta      ctermfg=Black      ctermbg=DarkMagenta    guifg=Black      guibg=DarkMagenta  cterm=NONE         gui=NONE
                               hi ansiRedMagenta        ctermfg=DarkRed        ctermbg=DarkMagenta    guifg=DarkRed        guibg=DarkMagenta  cterm=NONE         gui=NONE
                               hi ansiGreenMagenta      ctermfg=DarkGreen      ctermbg=DarkMagenta    guifg=DarkGreen      guibg=DarkMagenta  cterm=NONE         gui=NONE
                               hi ansiYellowMagenta     ctermfg=DarkYellow     ctermbg=DarkMagenta    guifg=DarkYellow     guibg=DarkMagenta  cterm=NONE         gui=NONE
                               hi ansiBlueMagenta       ctermfg=DarkBlue       ctermbg=DarkMagenta    guifg=DarkBlue       guibg=DarkMagenta  cterm=NONE         gui=NONE
                               hi ansiMagentaMagenta    ctermfg=DarkMagenta    ctermbg=DarkMagenta    guifg=DarkMagenta    guibg=DarkMagenta  cterm=NONE         gui=NONE
                               hi ansiCyanMagenta       ctermfg=DarkCyan       ctermbg=DarkMagenta    guifg=DarkCyan       guibg=DarkMagenta  cterm=NONE         gui=NONE
                               hi ansiWhiteMagenta      ctermfg=LightGray      ctermbg=DarkMagenta    guifg=LightGray      guibg=DarkMagenta  cterm=NONE         gui=NONE
                               hi ansiGrayMagenta       ctermfg=DarkGray      ctermbg=DarkMagenta    guifg=DarkGray      guibg=DarkMagenta  cterm=NONE         gui=NONE
                            
                               hi ansiBlackCyan         ctermfg=Black      ctermbg=DarkCyan       guifg=Black      guibg=DarkCyan     cterm=NONE         gui=NONE
                               hi ansiRedCyan           ctermfg=DarkRed        ctermbg=DarkCyan       guifg=DarkRed        guibg=DarkCyan     cterm=NONE         gui=NONE
                               hi ansiGreenCyan         ctermfg=DarkGreen      ctermbg=DarkCyan       guifg=DarkGreen      guibg=DarkCyan     cterm=NONE         gui=NONE
                               hi ansiYellowCyan        ctermfg=DarkYellow     ctermbg=DarkCyan       guifg=DarkYellow     guibg=DarkCyan     cterm=NONE         gui=NONE
                               hi ansiBlueCyan          ctermfg=DarkBlue       ctermbg=DarkCyan       guifg=DarkBlue       guibg=DarkCyan     cterm=NONE         gui=NONE
                               hi ansiMagentaCyan       ctermfg=DarkMagenta    ctermbg=DarkCyan       guifg=DarkMagenta    guibg=DarkCyan     cterm=NONE         gui=NONE
                               hi ansiCyanCyan          ctermfg=DarkCyan       ctermbg=DarkCyan       guifg=DarkCyan       guibg=DarkCyan     cterm=NONE         gui=NONE
                               hi ansiWhiteCyan         ctermfg=LightGray      ctermbg=DarkCyan       guifg=LightGray      guibg=DarkCyan     cterm=NONE         gui=NONE
                               hi ansiGrayCyan          ctermfg=DarkGray      ctermbg=DarkCyan       guifg=DarkGray      guibg=DarkCyan     cterm=NONE         gui=NONE
                            
                               hi ansiBlackWhite        ctermfg=Black      ctermbg=LightGray      guifg=Black      guibg=LightGray    cterm=NONE         gui=NONE
                               hi ansiRedWhite          ctermfg=DarkRed        ctermbg=LightGray      guifg=DarkRed        guibg=LightGray    cterm=NONE         gui=NONE
                               hi ansiGreenWhite        ctermfg=DarkGreen      ctermbg=LightGray      guifg=DarkGreen      guibg=LightGray    cterm=NONE         gui=NONE
                               hi ansiYellowWhite       ctermfg=DarkYellow     ctermbg=LightGray      guifg=DarkYellow     guibg=LightGray    cterm=NONE         gui=NONE
                               hi ansiBlueWhite         ctermfg=DarkBlue       ctermbg=LightGray      guifg=DarkBlue       guibg=LightGray    cterm=NONE         gui=NONE
                               hi ansiMagentaWhite      ctermfg=DarkMagenta    ctermbg=LightGray      guifg=DarkMagenta    guibg=LightGray    cterm=NONE         gui=NONE
                               hi ansiCyanWhite         ctermfg=DarkCyan       ctermbg=LightGray      guifg=DarkCyan       guibg=LightGray    cterm=NONE         gui=NONE
                               hi ansiWhiteWhite        ctermfg=LightGray      ctermbg=LightGray      guifg=LightGray      guibg=LightGray    cterm=NONE         gui=NONE
                               hi ansiGrayWhite         ctermfg=DarkGray      ctermbg=LightGray      guifg=DarkGray      guibg=LightGray    cterm=NONE         gui=NONE
                              endif
                            "  call Dret("AnsiEsc#AnsiEsc")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:MultiElementHandler: builds custom syntax highlighting for three or more element ansi escape sequences {{{2
    1              0.000001 fun! s:MultiElementHandler()
                            "  call Dfunc("s:MultiElementHandler()")
                              let curwp= SaveWinPosn(0)
                              keepj 1
                              keepj norm! 0
                              let mehcnt = 0
                              let mehrules     = []
                              while search('\e\[;\=\d\+;\d\+;\d\+\(;\d\+\)*m','cW')
                               let curcol  = col(".")+1
                               call search('m','cW')
                               let mcol    = col(".")
                               let ansiesc = strpart(getline("."),curcol,mcol - curcol)
                               let aecodes = split(ansiesc,'[;m]')
                            "   call Decho("ansiesc<".ansiesc."> aecodes=".string(aecodes))
                               let skip         = 0
                               let mod          = "NONE,"
                               let fg           = ""
                               let bg           = ""
                            
                               " if the ansiesc is
                               if index(mehrules,ansiesc) == -1
                                let mehrules+= [ansiesc]
                            
                                for code in aecodes
                            
                                 " handle multi-code sequences (38;5;color  and 48;5;color)
                                 if skip == 38 && code == 5
                                  " handling <esc>[38;5
                                  let skip= 385
                            "      call Decho(" 1: building code=".code." skip=".skip.": mod<".mod."> fg<".fg."> bg<".bg.">")
                                  continue
                                 elseif skip == 385
                                  " handling <esc>[38;5;...
                                  if has("gui") && has("gui_running")
                                   let fg= s:Ansi2Gui(code)
                                  else
                                   let fg= code
                                  endif
                                  let skip= 0
                            "      call Decho(" 2: building code=".code." skip=".skip.": mod<".mod."> fg<".fg."> bg<".bg.">")
                                  continue
                            
                                 elseif skip == 48 && code == 5
                                  " handling <esc>[48;5
                                  let skip= 485
                            "      call Decho(" 3: building code=".code." skip=".skip.": mod<".mod."> fg<".fg."> bg<".bg.">")
                                  continue
                                 elseif skip == 485
                                  " handling <esc>[48;5;...
                                  if has("gui") && has("gui_running")
                                   let bg= s:Ansi2Gui(code)
                                  else
                                   let bg= code
                                  endif
                                  let skip= 0
                            "      call Decho(" 4: building code=".code." skip=".skip.": mod<".mod."> fg<".fg."> bg<".bg.">")
                                  continue
                            
                                 else
                                  let skip= 0
                                 endif
                            
                                 " handle single-code sequences
                                 if code == 1
                                  let mod=mod."bold,"
                                 elseif code == 2
                                  let mod=mod."italic,"
                                 elseif code == 3
                                  let mod=mod."standout,"
                                 elseif code == 4
                                  let mod=mod."underline,"
                                 elseif code == 5 || code == 6
                                  let mod=mod."undercurl,"
                                 elseif code == 7
                                  let mod=mod."reverse,"
                            
                                 elseif code == 30
                                  let fg= "black"
                                 elseif code == 31
                                  let fg= "red"
                                 elseif code == 32
                                  let fg= "green"
                                 elseif code == 33
                                  let fg= "yellow"
                                 elseif code == 34
                                  let fg= "blue"
                                 elseif code == 35
                                  let fg= "magenta"
                                 elseif code == 36
                                  let fg= "cyan"
                                 elseif code == 37
                                  let fg= "white"
                            
                                 elseif code == 40
                                  let bg= "black"
                                 elseif code == 41
                                  let bg= "red"
                                 elseif code == 42
                                  let bg= "green"
                                 elseif code == 43
                                  let bg= "yellow"
                                 elseif code == 44
                                  let bg= "blue"
                                 elseif code == 45
                                  let bg= "magenta"
                                 elseif code == 46
                                  let bg= "cyan"
                                 elseif code == 47
                                  let bg= "white"
                            
                                 elseif code == 38
                                  let skip= 38
                            
                                 elseif code == 48
                                  let skip= 48
                                 endif
                            
                            "     call Decho(" 5: building code=".code." skip=".skip.": mod<".mod."> fg<".fg."> bg<".bg.">")
                                endfor
                            
                                " fixups
                                let mod= substitute(mod,',$','','')
                            
                                " build syntax-recognition rule
                                let mehcnt  = mehcnt + 1
                                let synrule = "syn region ansiMEH".mehcnt
                                let synrule = synrule.' start="\e\['.ansiesc.'"'
                                let synrule = synrule.' end="\e\["me=e-2'
                                let synrule = synrule." contains=ansiConceal"
                            "    call Decho(" exe synrule: ".synrule)
                                exe synrule
                            
                                " build highlighting rule
                                let hirule= "hi ansiMEH".mehcnt
                                if has("gui") && has("gui_running")
                                 let hirule=hirule." gui=".mod
                                 if fg != ""| let hirule=hirule." guifg=".fg| endif
                                 if bg != ""| let hirule=hirule." guibg=".bg| endif
                                else
                                 let hirule=hirule." cterm=".mod
                                 if fg != ""| let hirule=hirule." ctermfg=".fg| endif
                                 if bg != ""| let hirule=hirule." ctermbg=".bg| endif
                                endif
                            "    call Decho(" exe hirule: ".hirule)
                                exe hirule
                               endif
                            
                              endwhile
                            
                              call RestoreWinPosn(curwp)
                            "  call Dret("s:MultiElementHandler")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:Ansi2Gui: converts an ansi-escape sequence (for 256-color xterms) {{{2
                            "           to an equivalent gui color
                            "           colors   0- 15:
                            "           colors  16-231:  6x6x6 color cube, code= 16+r*36+g*6+b  with r,g,b each in [0,5]
                            "           colors 232-255:  grayscale ramp,   code= 10*gray + 8    with gray in [0,23] (black,white left out)
    1              0.000001 fun! s:Ansi2Gui(code)
                            "  call Dfunc("s:Ansi2Gui(code=)".a:code)
                              let guicolor= a:code
                              if a:code < 16
                               let code2rgb = [ "black", "red3", "green3", "yellow3", "blue3", "magenta3", "cyan3", "gray70", "gray40", "red", "green", "yellow", "royalblue3", "magenta", "cyan", "white"]
                               let guicolor = code2rgb[a:code]
                              elseif a:code >= 232
                               let code     = a:code - 232
                               let code     = 10*code + 8
                               let guicolor = printf("#%02x%02x%02x",code,code,code)
                              else
                               let code     = a:code - 16
                               let code2rgb = [43,85,128,170,213,255]
                               let r        = code2rgb[code/36]
                               let g        = code2rgb[(code%36)/6]
                               let b        = code2rgb[code%6]
                               let guicolor = printf("#%02x%02x%02x",r,g,b)
                              endif
                            "  call Dret("s:Ansi2Gui ".guicolor)
                              return guicolor
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " AnsiEsc#BufReadPost: updates ansi-escape code visualization if it was alredy
                            " on for the buffer{{{2
    1              0.000001 fun! AnsiEsc#BufReadPost()
                              let bn= bufnr("%")
                              if exists("s:AnsiEsc_enabled_{bn}") && s:AnsiEsc_enabled_{bn}
                               call AnsiEsc#AnsiEsc(1)
                              endif
                            endfun
                            
                            " ---------------------------------------------------------------------
                            "  Restore: {{{1
    1              0.000002 let &cpo= s:keepcpo
    1              0.000001 unlet s:keepcpo
                            
                            " ---------------------------------------------------------------------
                            "  Modelines: {{{1
                            " vim: ts=12 fdm=marker

SCRIPT  /home/francois/.local/share/nvim/lazy/vim-signify/autoload/sy.vim
Sourced 1 time
Total time:   0.000045
 Self time:   0.000045

count  total (s)   self (s)
                            " vim: et sw=2 sts=2 fdm=marker
                            
    1              0.000001 scriptencoding utf-8
                            
                            " #start {{{1
                            " Optional argument: {'bufnr': X }
    1              0.000001 function! sy#start(...) abort
                              if g:signify_locked
                                call sy#verbose('Locked.')
                                return
                              endif
                            
                              if g:signify_detecting > 50
                                call sy#verbose('Too many detection jobs running, deferring detection')
                                return
                              endif
                            
                              let bufnr = a:0 && has_key(a:1, 'bufnr') ? a:1.bufnr : bufnr('')
                              let sy = getbufvar(bufnr, 'sy')
                            
                              if empty(sy)
                                let path = s:get_path(bufnr)
                                if s:skip(bufnr, path)
                                  call sy#verbose('Skip file: '. path)
                                  return
                                endif
                                call sy#verbose('Register new file: '. path)
                                let new_sy = {
                                      \ 'path':       path,
                                      \ 'buffer':     bufnr,
                                      \ 'detecting':  0,
                                      \ 'vcs':        [],
                                      \ 'hunks':      [],
                                      \ 'signid':     0x100,
                                      \ 'updated_by': '',
                                      \ 'stats':      [-1, -1, -1],
                                      \ 'info':       {
                                      \    'dir':  fnamemodify(path, ':p:h'),
                                      \    'path': sy#util#escape(path),
                                      \    'file': sy#util#escape(fnamemodify(path, ':t'))
                                      \ }}
                                call setbufvar(bufnr, 'sy', new_sy)
                                call sy#set_buflocal_autocmds(bufnr)
                                call sy#repo#detect(bufnr)
                              elseif has('vim_starting')
                                call sy#verbose("Don't run Sy more than once during startup.")
                                return
                              else
                                let path = s:get_path(bufnr)
                                if !filereadable(path)
                                  call sy#stop()
                                  return
                                elseif empty(sy.vcs)
                                  if get(sy, 'retry')
                                    let sy.retry = 0
                                    call sy#verbose('Redetecting VCS.')
                                    call sy#repo#detect(sy.buffer)
                                  else
                                    if get(sy, 'detecting')
                                      call sy#verbose('Detection is already in progress.')
                                    else
                                      call sy#verbose('No VCS found. Disabling.')
                                      call sy#stop(sy.buffer)
                                    endif
                                  endif
                                else
                                  for vcs in sy.vcs
                                    let job_id = getbufvar(sy.buffer, 'sy_job_id_'. vcs, 0)
                                    if type(job_id) != type(0) || job_id > 0
                                      call sy#verbose('Update is already in progress.', vcs)
                                    else
                                      call sy#verbose('Updating signs.', vcs)
                                      call sy#repo#get_diff(sy.buffer, vcs, function('sy#sign#set_signs'))
                                    endif
                                  endfor
                                endif
                              endif
                            endfunction
                            
                            " #stop {{{1
    1              0.000001 function! sy#stop(...) abort
                              let bufnr = bufnr('')
                              if empty(getbufvar(a:0 ? a:1 : bufnr, 'sy')) | return | endif
                              call sy#sign#remove_all_signs(bufnr)
                              execute printf('autocmd! signify * <buffer=%d>', bufnr)
                              call setbufvar(bufnr, 'sy', {})
                            endfunction
                            
                            " #toggle {{{1
    1              0.000001 function! sy#toggle() abort
                              call call(empty(getbufvar(bufnr(''), 'sy')) ? 'sy#start' : 'sy#stop', [])
                            endfunction
                            
                            " #start_all {{{1
    1              0.000001 function! sy#start_all() abort
                              for bufnr in range(1, bufnr("$"))
                                call sy#start({'bufnr': bufnr})
                              endfor
                              let g:signify_disable_by_default = 0
                            endfunction
                            
                            " #stop_all {{{1
    1              0.000000 function! sy#stop_all() abort
                              for bufnr in range(1, bufnr(''))
                                if !empty(getbufvar(bufnr, 'sy'))
                                  call sy#stop(bufnr)
                                endif
                              endfor
                              let g:signify_disable_by_default = 1
                            endfunction
                            
                            " #buffer_is_active {{{1
    1              0.000001 function! sy#buffer_is_active(...)
                              let bufnr = a:0 ? a:1 : bufnr('')
                              return !empty(getbufvar(bufnr, 'sy'))
                            endfunction
                            
                            " #verbose {{{1
    1              0.000001 function! sy#verbose(msg, ...) abort
                              if &verbose
                                if type(a:msg) == type([])
                                  for msg in a:msg
                                    echomsg printf('[sy%s] %s', (a:0 ? ':'.a:1 : ''), msg)
                                  endfor
                                else
                                  echomsg printf('[sy%s] %s', (a:0 ? ':'.a:1 : ''), a:msg)
                                endif
                              endif
                            endfunction
                            
                            " #set_buflocal_autocmds {{{1
    1              0.000001 function! sy#set_buflocal_autocmds(bufnr) abort
                              augroup signify
                                execute printf('autocmd! * <buffer=%d>', a:bufnr)
                            
                                execute printf('autocmd BufEnter     <buffer=%d> call sy#start()', a:bufnr)
                                execute printf('autocmd WinEnter     <buffer=%d> call sy#start()', a:bufnr)
                                execute printf('autocmd BufWritePost <buffer=%d> call sy#start()', a:bufnr)
                            
                                execute printf('autocmd CursorHold   <buffer=%d> call sy#start()', a:bufnr)
                                execute printf('autocmd CursorHoldI  <buffer=%d> call sy#start()', a:bufnr)
                            
                                execute printf('autocmd FocusGained  <buffer=%d> SignifyRefresh', a:bufnr)
                            
                                execute printf('autocmd CmdwinEnter <buffer=%d> let g:signify_cmdwin_active = 1', a:bufnr)
                                execute printf('autocmd CmdwinLeave <buffer=%d> let g:signify_cmdwin_active = 0', a:bufnr)
                            
                                execute printf('autocmd ShellCmdPost <buffer=%d> call sy#start()', a:bufnr)
                            
                                if exists('##VimResume')
                                  execute printf('autocmd VimResume <buffer=%d> call sy#start()', a:bufnr)
                                endif
                              augroup END
                            
                              if exists('#User#SignifyAutocmds')
                                doautocmd <nomodeline> User SignifyAutocmds
                              endif
                            endfunction
                            
                            " s:get_path {{{1
    1              0.000001 function! s:get_path(bufnr)
                              let path = resolve(fnamemodify(bufname(a:bufnr), ':p'))
                              if has('win32')
                                let path = substitute(path, '\v^(\w):\\\\', '\1:\\', '')
                              endif
                              return path
                            endfunction
                            
                            " s:skip {{{1
    1              0.000001 function! s:skip(bufnr, path)
                              if getbufvar(a:bufnr, '&diff') || !filereadable(a:path)
                                return 1
                              endif
                            
                              if exists('g:signify_skip_filetype')
                                if has_key(g:signify_skip_filetype, getbufvar(a:bufnr, '&filetype'))
                                  return 1
                                elseif has_key(g:signify_skip_filetype, 'help')
                                      \ && getbufvar(a:bufnr, '&buftype') == 'help'
                                  return 1
                                endif
                              endif
                            
                              if exists('g:signify_skip_filename') && has_key(g:signify_skip_filename, a:path)
                                return 1
                              endif
                            
                              " DEPRECATED: Use g:signify_skip.pattern instead.
                              if exists('g:signify_skip_filename_pattern')
                                for pattern in g:signify_skip_filename_pattern
                                  if a:path =~ pattern
                                    return 1
                                  endif
                                endfor
                              endif
                            
                              if exists('g:signify_skip')
                                if has_key(g:signify_skip, 'pattern')
                                  for pattern in g:signify_skip.pattern
                                    if a:path =~ pattern
                                      return 1
                                    endif
                                  endfor
                                endif
                              endif
                            
                              return 0
                            endfunction

SCRIPT  /home/francois/.local/share/nvim/lazy/vim-signify/autoload/sy/util.vim
Sourced 1 time
Total time:   0.000065
 Self time:   0.000065

count  total (s)   self (s)
                            " vim: et sw=2 sts=2 fdm=marker
                            
    1              0.000001 scriptencoding utf-8
                            
                            " #escape {{{1
    1              0.000001 function! sy#util#escape(path) abort
                              if exists('+shellslash')
                                let old_ssl = &shellslash
                                if fnamemodify(&shell, ':t') == 'cmd.exe'
                                  set noshellslash
                                else
                                  set shellslash
                                endif
                              endif
                            
                              let path = shellescape(a:path)
                            
                              if exists('old_ssl')
                                let &shellslash = old_ssl
                              endif
                            
                              return path
                            endfunction
                            
                            " #refresh_windows {{{1
    1              0.000001 function! sy#util#refresh_windows() abort
                              if exists('*win_getid')
                                let winid = win_getid()
                              else
                                let winnr = winnr()
                              endif
                            
                              if !get(g:, 'signify_cmdwin_active')
                                for bufnr in tabpagebuflist()
                                  if sy#buffer_is_active(bufnr)
                                    call sy#start({'bufnr': bufnr})
                                  endif
                                endfor
                              endif
                            
                              if exists('winid')
                                call win_gotoid(winid)
                              else
                                execute winnr .'wincmd w'
                              endif
                            endfunction
                            
                            " #hunk_text_object {{{1
    1              0.000001 function! sy#util#hunk_text_object(emptylines) abort
                              execute sy#util#return_if_no_changes()
                            
                              let lnum  = line('.')
                              let hunks = filter(copy(b:sy.hunks), 'v:val.start <= lnum && v:val.end >= lnum')
                            
                              if empty(hunks)
                                echomsg 'signify: Here is no hunk.'
                                return
                              endif
                            
                              execute hunks[0].start
                              normal! V
                            
                              if a:emptylines
                                let lnum = hunks[0].end
                                while getline(lnum+1) =~ '^$'
                                  let lnum += 1
                                endwhile
                                execute lnum
                              else
                                execute hunks[0].end
                              endif
                            endfunction
                            
                            " #shell_redirect {{{1
    1              0.000001 function! sy#util#shell_redirect(path) abort
                              " if shellredir contains a %s it is replaced with the path
                              " otherwise, just append it (from :help shellredir:
                              "   The name of the temporary file can be represented by '%s' if necessary
                              "   (the file name is appended automatically if no %s appears in the value
                              "   of this option)
                              if &shellredir =~# '%s'
                                return substitute(&shellredir, '\C%s', a:path, 'g')
                              else
                                return &shellredir .' '. a:path
                              endif
                            endfunction
                            
                            " #chdir {{{1
    1              0.000001 function! sy#util#chdir() abort
                              let chdir = haslocaldir()
                                    \ ? 'lcd'
                                    \ : (exists(':tcd') && haslocaldir(-1, 0)) ? 'tcd' : 'cd'
                              return [getcwd(), chdir]
                            endfunction
                            
                            " #return_if_no_changes {{{1
    1              0.000001 function! sy#util#return_if_no_changes() abort
                              let sy = getbufvar(bufnr(''), 'sy')
                              if empty(sy) || empty(sy.hunks)
                                echomsg 'signify: There are no changes.'
                                return 'return'
                              endif
                              return ''
                            endfunction
                            
                            " #execute {{{1
    1              0.000001 function! sy#util#execute(cmd) abort
                              let lang = v:lang
                              redir => output
                                silent! execute a:cmd
                              redir END
                              silent! execute 'language message' lang
                              return output
                            endfunction
                            
    1              0.000001 let s:popup_window = 0
                            
                            " #get_hunk_stats {{{1
    1              0.000001 function! sy#util#get_hunk_stats() abort
                              execute sy#util#return_if_no_changes()
                            
                              let curline = line('.')
                              let total_hunks = len(b:sy.hunks)
                            
                              for i in range(total_hunks)
                                if b:sy.hunks[i].start <= curline && b:sy.hunks[i].end >= curline
                                  return { 'total_hunks': total_hunks, 'current_hunk': i + 1 }
                                endif
                              endfor
                            
                              return {}
                            endfunction
                            
                            " #popup_close {{{1
    1              0.000001 function! sy#util#popup_close() abort
                              if s:popup_window
                                if nvim_win_is_valid(s:popup_window)
                                  call nvim_win_close(s:popup_window, 1)
                                endif
                                let s:popup_window = 0
                              endif
                            endfunction
                            
                            " #popup_create {{{1
    1              0.000001 function! sy#util#popup_create(hunkdiff) abort
                              let offset      = s:offset()
                              let winline     = winline()
                              let min_height  = 6
                              let max_height  = winheight('%') - winline
                              let diff_height = len(a:hunkdiff)
                              let height      = min([diff_height, max_height])
                            
                              if diff_height > max_height && max_height < min_height
                                let max_scroll = min_height - max_height
                                let scroll     = min([max_scroll, diff_height - max_height])
                                " Old versions don't have feedkeys(..., 'x')
                                execute 'normal!' scroll.''
                                let winline -= scroll
                                let height  += scroll
                              endif
                            
                              let padding = repeat(' ', offset - 1)
                            
                              if exists('*nvim_open_win')
                                call sy#util#popup_close()
                                let buf = nvim_create_buf(0, 1)
                                call nvim_buf_set_option(buf, 'syntax', 'diff')
                                call nvim_buf_set_lines(buf, 0, -1, 0, map(a:hunkdiff, 'v:val[0].padding.v:val[1:]'))
                                let s:popup_window = nvim_open_win(buf, v:false, {
                                      \ 'relative': 'win',
                                      \ 'row': winline,
                                      \ 'col': 0,
                                      \ 'width': winwidth('%'),
                                      \ 'height': height,
                                      \ })
                                call nvim_win_set_option(s:popup_window, 'cursorline', v:false)
                                call nvim_win_set_option(s:popup_window, 'foldcolumn', has('nvim-0.5') ? '0' : 0)
                                call nvim_win_set_option(s:popup_window, 'foldenable', v:false)
                                call nvim_win_set_option(s:popup_window, 'number', v:false)
                                call nvim_win_set_option(s:popup_window, 'relativenumber', v:false)
                                call nvim_win_set_option(s:popup_window, 'wrap', v:true)
                                autocmd CursorMoved <buffer> ++once call sy#util#popup_close()
                              elseif exists('*popup_create')
                                let s:popup_window = popup_create(map(a:hunkdiff, 'v:val[0].padding.v:val[1:]'), {
                                      \ 'line': 'cursor+1',
                                      \ 'col': 0,
                                      \ 'minwidth': winwidth('%'),
                                      \ 'maxheight': height,
                                      \ 'moved': 'any',
                                      \ 'zindex': 1000,
                                      \ })
                                call setbufvar(winbufnr(s:popup_window), '&syntax', 'diff')
                              else
                                return 0
                              endif
                            
                              return 1
                            endfunction
                            
                            " #numhl {{{1
    1              0.000000 try
    1              0.000003   sign define SyTest numhl=Number
    1              0.000001   let s:use_numhl = 1
    1              0.000001   sign undefine SyTest
                            catch
                              let s:use_numhl = 0
    1              0.000000 endtry
                            
    1              0.000001 function! sy#util#numhl(hlgroup) abort
                              if !s:use_numhl
                                return ''
                              endif
                            
                              if get(g:, 'signify_number_highlight')
                                return printf('numhl=%s', a:hlgroup)
                              else
                                return 'numhl='
                              endif
                            endfunction
                            
                            " s:offset {{{1
    1              0.000001 function! s:offset() abort
                              let offset = &foldcolumn
                              let offset += 2  " FIXME: Find better way to calculate the sign column width.
                              if &number
                                let l = len(line('$')) + 1
                                let offset += (&numberwidth > l) ? &numberwidth : l
                              elseif &relativenumber
                                let l = len(winheight('%')) + 1
                                let offset += (&numberwidth > l) ? &numberwidth : l
                              endif
                              return offset
                            endfunction
                            
                            " #get_signs {{{1
    1              0.000001 if exists('*sign_getplaced')
    1              0.000001   function! sy#util#get_signs(bufnr)
                                return sign_getplaced(a:bufnr)[0].signs
                              endfunction
                            else
                              function! sy#util#get_signs(bufnr)
                                let buf = bufnr(a:bufnr)
                                let signs = []
                            
                                let signlist = execute('sign place buffer='. buf)
                                for signline in split(signlist, '\n')[2:]
                                  let tokens = matchlist(signline, '\v^\s+\S+\=(\d+)\s+\S+\=(\d+)\s+\S+\=(.{-})%(\s+\S+\=(\d+))=$')
                                  let line   = str2nr(tokens[1])
                                  let id     = str2nr(tokens[2])
                                  let name   = tokens[3]
                                  let priority = tokens[4]
                                  if empty(priority)
                                    " Older Vim versions didn't report priority, so set the default value
                                    " manually
                                    let priority = '10'
                                  endif
                                  let priority = str2nr(priority)
                                  call add(signs, {
                                        \ 'lnum': line,
                                        \ 'id': id,
                                        \ 'name': name,
                                        \ 'priority': priority,
                                        \ 'group': ''
                                        \ })
                                endfor
                            
                                return signs
                              endfunction
    1              0.000001 endif

SCRIPT  /home/francois/.local/share/nvim/lazy/vim-signify/autoload/sy/repo.vim
Sourced 1 time
Total time:   0.000444
 Self time:   0.000430

count  total (s)   self (s)
                            " vim: et sw=2 sts=2 fdm=marker
                            
    1              0.000001 scriptencoding utf-8
                            
                            " #detect {{{1
    1              0.000001 function! sy#repo#detect(bufnr) abort
                              let sy = getbufvar(a:bufnr, 'sy')
                              for vcs in s:vcs_list
                                let sy.detecting += 1
                                let g:signify_detecting += 1
                                call sy#repo#get_diff(a:bufnr, vcs, function('sy#sign#set_signs'))
                              endfor
                            endfunction
                            
                            " s:callback_nvim_stdout{{{1
    1              0.000001 function! s:callback_nvim_stdout(_job_id, data, _event) dict abort
                              let self.stdoutbuf[-1] .= a:data[0]
                              call extend(self.stdoutbuf, a:data[1:])
                            endfunction
                            
                            " s:callback_nvim_exit {{{1
    1              0.000001 function! s:callback_nvim_exit(_job_id, exitval, _event) dict abort
                              return s:handle_diff(self, a:exitval)
                            endfunction
                            
                            " s:callback_vim_stdout {{{1
    1              0.000001 function! s:callback_vim_stdout(_job_id, data) dict abort
                              let self.stdoutbuf += [a:data]
                            endfunction
                            
                            " s:callback_vim_close {{{1
    1              0.000001 function! s:callback_vim_close(channel) dict abort
                              let job = ch_getjob(a:channel)
                              while 1
                                if job_status(job) == 'dead'
                                  let exitval = job_info(job).exitval
                                  break
                                endif
                                sleep 10m
                              endwhile
                              return s:handle_diff(self, exitval)
                            endfunction
                            
                            " s:write_buffer {{{1
    1              0.000001 function! s:write_buffer(bufnr, file)
                              let bufcontents = getbufline(a:bufnr, 1, '$')
                            
                              if bufcontents == [''] && line2byte(1) == -1
                                " Special case: completely empty buffer.
                                " A nearly empty buffer of only a newline has line2byte(1) == 1.
                                call writefile([], a:file)
                                return
                              endif
                            
                              if getbufvar(a:bufnr, '&fileformat') ==# 'dos'
                                call map(bufcontents, 'v:val."\r"')
                              endif
                            
                              let fenc = getbufvar(a:bufnr, '&fileencoding')
                              let enc  = getbufvar(a:bufnr, '&encoding')
                              if fenc !=# enc
                                call map(bufcontents, 'iconv(v:val, "'.enc.'", "'.fenc.'")')
                              endif
                            
                              if getbufvar(a:bufnr, '&bomb')
                                let bufcontents[0]='﻿'.bufcontents[0]
                              endif
                            
                              call writefile(bufcontents, a:file)
                            endfunction
                            
                            " sy#get_diff {{{1
    1              0.000001 function! sy#repo#get_diff(bufnr, vcs, func) abort
                              call sy#verbose('sy#repo#get_diff()', a:vcs)
                            
                              let job_id = getbufvar(a:bufnr, 'sy_job_id_'.a:vcs)
                            
                              if getbufvar(a:bufnr, '&modified')
                                let [cmd, options] = s:initialize_buffer_job(a:bufnr, a:vcs)
                                let options.difftool = 'diff'
                              else
                                let [cmd, options] = s:initialize_job(a:bufnr, a:vcs)
                                let options.difftool = a:vcs
                              endif
                            
                              let options.func = a:func
                            
                              if has('nvim')
                                if job_id
                                  silent! call jobstop(job_id)
                                endif
                                let job_id = jobstart(cmd, extend(options, {
                                      \ 'cwd':       getbufvar(a:bufnr, 'sy').info.dir,
                                      \ 'on_stdout': function('s:callback_nvim_stdout'),
                                      \ 'on_exit':   function('s:callback_nvim_exit'),
                                      \ }))
                                call setbufvar(a:bufnr, 'sy_job_id_'.a:vcs, job_id)
                              elseif has('patch-8.0.902')
                                if type(job_id) != type(0)
                                  silent! call job_stop(job_id)
                                endif
                                let opts = {
                                      \ 'cwd':      getbufvar(a:bufnr, 'sy').info.dir,
                                      \ 'in_io':    'null',
                                      \ 'out_cb':   function('s:callback_vim_stdout', options),
                                      \ 'close_cb': function('s:callback_vim_close', options),
                                      \ }
                                let job_id = job_start(cmd, opts)
                                call setbufvar(a:bufnr, 'sy_job_id_'.a:vcs, job_id)
                              else
                                let options.stdoutbuf = split(s:run(a:vcs), '\n')
                                call s:handle_diff(options, v:shell_error)
                              endif
                            endfunction
                            
                            " s:handle_diff {{{1
    1              0.000001 function! s:handle_diff(options, exitval) abort
                              call sy#verbose('s:handle_diff()', a:options.vcs)
                            
                              if has_key(a:options, 'tempfiles')
                                for f in a:options.tempfiles
                                  call delete(f)
                                endfor
                              endif
                            
                              let sy = getbufvar(a:options.bufnr, 'sy')
                              if empty(sy)
                                call sy#verbose(printf('No b:sy found for %s', bufname(a:options.bufnr)), a:options.vcs)
                                return
                              elseif !empty(sy.updated_by) && sy.updated_by != a:options.vcs
                                call sy#verbose(printf('Signs already got updated by %s.', sy.updated_by), a:options.vcs)
                                return
                              elseif empty(sy.vcs)
                                let g:signify_detecting -= 1
                                let sy.detecting -= 1
                              endif
                            
                              let fenc = getbufvar(a:options.bufnr, '&fenc')
                              let enc  = getbufvar(a:options.bufnr, '&enc')
                              if (fenc != enc) && has('iconv')
                                call map(a:options.stdoutbuf, printf('iconv(v:val, "%s", "%s")', fenc, enc))
                              endif
                            
                              let [found_diff, diff] = s:check_diff_{a:options.difftool}(a:exitval, a:options.stdoutbuf)
                              if found_diff
                                if index(sy.vcs, a:options.vcs) == -1
                                  let sy.vcs += [a:options.vcs]
                                endif
                                call a:options.func(sy, a:options.vcs, diff)
                              else
                                call sy#verbose('No valid diff found. Disabling this VCS.', a:options.vcs)
                              endif
                            
                              call setbufvar(a:options.bufnr, 'sy_job_id_'.a:options.vcs, 0)
                            endfunction
                            
                            " s:check_diff_diff {{{1
    1              0.000001 function! s:check_diff_diff(exitval, diff) abort
                              return a:exitval <= 1 ? [1, a:diff] : [0, []]
                            endfunction
                            
                            " s:check_diff_git {{{1
    1              0.000001 function! s:check_diff_git(exitval, diff) abort
                              return a:exitval ? [0, []] : [1, a:diff]
                            endfunction
                            
                            " s:check_diff_yadm {{{1
    1              0.000001 function! s:check_diff_yadm(exitval, diff) abort
                              return a:exitval ? [0, []] : [1, a:diff]
                            endfunction
                            
                            " s:check_diff_hg {{{1
    1              0.000001 function! s:check_diff_hg(exitval, diff) abort
                              return a:exitval ? [0, []] : [1, a:diff]
                            endfunction
                            
                            " s:check_diff_svn {{{1
    1              0.000001 function! s:check_diff_svn(exitval, diff) abort
                              return a:exitval ? [0, []] : [1, a:diff]
                            endfunction
                            
                            " s:check_diff_bzr {{{1
    1              0.000001 function! s:check_diff_bzr(exitval, diff) abort
                              return (a:exitval =~ '[012]') ? [1, a:diff] : [0, []]
                            endfunction
                            
                            " s:check_diff_darcs {{{1
    1              0.000001 function! s:check_diff_darcs(exitval, diff) abort
                              return a:exitval ? [0, []] : [1, a:diff]
                            endfunction
                            
                            " s:check_diff_fossil {{{1
    1              0.000001 function! s:check_diff_fossil(exitval, diff) abort
                              return a:exitval ? [0, []] : [1, a:diff]
                            endfunction
                            
                            " s:check_diff_cvs {{{1
    1              0.000001 function! s:check_diff_cvs(exitval, diff) abort
                              let [found_diff, diff] = [0, []]
                              if a:exitval == 1
                                for diffline in a:diff
                                  if diffline =~ '^+++'
                                    let [found_diff, diff] = [1, a:diff]
                                    break
                                  endif
                                endfor
                              elseif a:exitval == 0 && len(a:diff) == 0
                                let found_diff = 1
                              endif
                              return [found_diff, diff]
                            endfunction
                            
                            " s:check_diff_rcs {{{1
    1              0.000001 function! s:check_diff_rcs(exitval, diff) abort
                              return (a:exitval == 2) ? [0, []] : [1, a:diff]
                            endfunction
                            
                            " s:check_diff_accurev {{{1
    1              0.000001 function! s:check_diff_accurev(exitval, diff) abort
                              return (a:exitval >= 2) ? [0, []] : [1, a:diff]
                            endfunction
                            
                            " s:check_diff_perforce {{{1
    1              0.000001 function! s:check_diff_perforce(exitval, diff) abort
                              return a:exitval ? [0, []] : [1, a:diff]
                            endfunction
                            
                            " s:check_diff_tfs {{{1
    1              0.000001 function! s:check_diff_tfs(exitval, diff) abort
                              return a:exitval ? [0, []] : [1, s:strip_context(a:diff)]
                            endfunction
                            
                            " #get_stats {{{1
    1              0.000001 function! sy#repo#get_stats(...) abort
                              let sy = getbufvar(a:0 ? a:1 : bufnr(''), 'sy')
                              return empty(sy) ? [-1, -1, -1] : sy.stats
                            endfunction
                            
                            " #get_stats_decorated {{{1
    1              0.000001 function! sy#repo#get_stats_decorated(...)
                              let bufnr = a:0 ? a:1 : bufnr('')
                              let [added, modified, removed] = sy#repo#get_stats(bufnr)
                              let symbols = ['+', '-', '~']
                              let stats = [added, removed, modified]  " reorder
                              let statline = ''
                            
                              for i in range(3)
                                if stats[i] > 0
                                  let statline .= printf('%s%s ', symbols[i], stats[i])
                                endif
                              endfor
                            
                              if !empty(statline)
                                let statline = printf('[%s]', statline[:-2])
                              endif
                            
                              return statline
                            endfunction
                            
                            " #debug_detection {{{1
    1              0.000001 function! sy#repo#debug_detection()
                              if empty(getbufvar(bufnr(''), 'sy'))
                                echomsg 'signify: I cannot detect any changes!'
                                return
                              endif
                            
                              for vcs in s:vcs_list
                                let cmd = s:get_base_cmd(bufnr(''), vcs, g:signify_vcs_cmds)
                                echohl Statement
                                echo cmd
                                echo repeat('=', len(cmd))
                                echohl NONE
                            
                                let diff = s:run(vcs)
                                if v:shell_error
                                  echohl ErrorMsg
                                  echo diff
                                  echohl NONE
                                else
                                  echo empty(diff) ? "<none>" : diff
                                endif
                                echo "\n"
                              endfor
                            endfunction
                            
    1              0.000001 function! s:system_in_dir(cmd) abort
                              let [cwd, chdir] = sy#util#chdir()
                              try
                                execute chdir fnameescape(b:sy.info.dir)
                                return system(a:cmd)
                              finally
                                execute chdir fnameescape(cwd)
                              endtry
                            endfunction
                            
                            " #diffmode {{{1
    1              0.000001 function! sy#repo#diffmode(do_tab) abort
                              execute sy#util#return_if_no_changes()
                            
                              let vcs = b:sy.updated_by
                            
                              call sy#verbose('SignifyDiff', vcs)
                              let ft = &filetype
                              let fenc = &fenc
                              if a:do_tab
                                tabedit %
                              endif
                              diffthis
                            
                              let base = s:get_base(bufnr(''), vcs)
                            
                              leftabove vnew
                            
                              let undolevels = &l:undolevels
                              setlocal undolevels=-1
                            
                              if (fenc != &enc) && has('iconv')
                                silent put =iconv(base, fenc, &enc)
                              else
                                silent put =base
                              endif
                            
                              silent 1delete
                              set buftype=nofile bufhidden=wipe nomodified
                              let &filetype = ft
                              let &l:undolevels = undolevels
                              diffthis
                              wincmd p
                              normal! ]czt
                            endfunction
                            
                            " s:extract_current_hunk {{{1
    1              0.000001 function! s:extract_current_hunk(diff) abort
                              let header = ''
                              let hunk = []
                            
                              for line in a:diff
                                if header != ''
                                  if line[:2] == '@@ ' || empty(line)
                                    break
                                  endif
                                  call add(hunk, line)
                                elseif line[:2] == '@@ ' && s:is_cur_line_in_hunk(line)
                                  let header = line
                                endif
                              endfor
                            
                              return [header, hunk]
                            endfunction
                            
    1              0.000001 function! s:is_cur_line_in_hunk(hunkline) abort
                              let cur_line = line('.')
                              let [_old_line, old_count, new_line, new_count] = sy#sign#parse_hunk(a:hunkline)
                            
                              if cur_line == 1 && new_line == 0
                                " deleted first line
                                return 1
                              endif
                            
                              if cur_line == new_line && new_count < old_count
                                " deleted lines
                                return 1
                              endif
                            
                              if cur_line >= new_line && cur_line < (new_line + new_count)
                                " added/changed lines
                                return 1
                              endif
                            
                              return 0
                            endfunction
                            
                            " #diff_hunk {{{1
    1              0.000001 function! sy#repo#diff_hunk() abort
                              let bufnr = bufnr('')
                              let sy = getbufvar(bufnr, 'sy')
                              if !empty(sy) && !empty(sy.updated_by)
                                call sy#repo#get_diff(bufnr, sy.updated_by, function('s:diff_hunk'))
                              endif
                            endfunction
                            
    1              0.000001 function! s:diff_hunk(_sy, vcs, diff) abort
                              call sy#verbose('s:preview_hunk()', a:vcs)
                            
                              let [_, hunk] = s:extract_current_hunk(a:diff)
                              if empty(hunk)
                                return
                              endif
                            
                              if sy#util#popup_create(hunk)
                                return
                              endif
                            
                              silent! wincmd P
                              if !&previewwindow
                                noautocmd botright new
                              endif
                              call setline(1, hunk)
                              silent! %foldopen!
                              setlocal previewwindow filetype=diff buftype=nofile bufhidden=delete
                              " With :noautocmd wincmd p, the first line of the preview window would show
                              " the 'cursorline', although it's not focused. Use feedkeys() instead.
                              noautocmd call feedkeys("\<c-w>p", 'nt')
                            endfunction
                            
                            " #undo_hunk {{{1
    1              0.000000 function! sy#repo#undo_hunk() abort
                              let bufnr = bufnr('')
                              let sy = getbufvar(bufnr, 'sy')
                              if !empty(sy) && !empty(sy.updated_by)
                                call sy#repo#get_diff(bufnr, sy.updated_by, function('s:undo_hunk'))
                              endif
                            endfunction
                            
    1              0.000001 function! s:undo_hunk(sy, vcs, diff) abort
                              call sy#verbose('s:undo_hunk()', a:vcs)
                            
                              let [header, hunk] = s:extract_current_hunk(a:diff)
                              if empty(hunk)
                                return
                              endif
                            
                              let [_old_line, _old_count, new_line, new_count] = sy#sign#parse_hunk(header)
                            
                              for line in hunk
                                let op = line[0]
                                let text = line[1:]
                                if op == ' '
                                  if text != getline(new_line)
                                    echoerr 'Could not apply context hunk for undo. Try saving the buffer first.'
                                    return
                                  endif
                                  let new_line += 1
                                elseif op == '-'
                                  call append(new_count == 0 ? new_line : new_line - 1, text)
                                  let new_line += 1
                                elseif op == '+'
                                  if text != getline(new_line)
                                    echoerr 'Could not apply addition hunk for undo. Try saving the buffer first.'
                                    return
                                  endif
                                  execute 'silent' new_line 'delete _'
                                else
                                  echoer 'Unknown diff operation ' . line
                                  return
                                endif
                              endfor
                            
                              " Undoing altered the buffer, so update signs.
                              call setbufvar(a:sy.buffer, 'sy_job_id_'.a:vcs, 0)
                              return sy#start()
                            endfunction
                            
                            " s:initialize_job {{{1
    1              0.000001 function! s:initialize_job(bufnr, vcs) abort
                              return s:wrap_cmd(a:bufnr, a:vcs, s:get_base_cmd(a:bufnr, a:vcs, g:signify_vcs_cmds))
                            endfunction
                            
                            " s:initialize_buffer_job {{{1
    1              0.000001 function! s:initialize_buffer_job(bufnr, vcs) abort
                              let bufferfile = tempname()
                              call s:write_buffer(a:bufnr, bufferfile)
                            
                              let basefile = tempname()
                              let base_cmd = s:get_base_cmd(a:bufnr, a:vcs, g:signify_vcs_cmds_diffmode) . '>' . fnameescape(basefile) . ' && '
                            
                              let diff_cmd = base_cmd .  s:difftool . ' -U0 ' . fnameescape(basefile) . ' ' . fnameescape(bufferfile)
                              let [cmd, options] = s:wrap_cmd(a:bufnr, a:vcs, diff_cmd)
                            
                              let options.tempfiles = [basefile, bufferfile]
                            
                              return [cmd, options]
                            endfunction
                            
                            " s:wrap_cmd {{{1
    1              0.000001 function! s:wrap_cmd(bufnr, vcs, cmd) abort
                              if has('win32')
                                if has('nvim')
                                  let cmd = &shell =~ '\v%(cmd|powershell|pwsh)' ? a:cmd : ['sh', '-c', a:cmd]
                                else
                                  if &shell =~ 'cmd'
                                    let cmd = join([&shell, &shellcmdflag, '(', a:cmd, ')'])
                                  elseif empty(&shellxquote)
                                    let cmd = join([&shell, &shellcmdflag, &shellquote, a:cmd, &shellquote])
                                  else
                                    let cmd = join([&shell, &shellcmdflag, &shellxquote, a:cmd, &shellxquote])
                                  endif
                                endif
                              else
                                let cmd = ['sh', '-c', a:cmd]
                              endif
                              let options = {
                                    \ 'stdoutbuf': [''],
                                    \ 'vcs': a:vcs,
                                    \ 'bufnr': a:bufnr,
                                    \ }
                              return [cmd, options]
                            endfunction
                            
                            " s:get_vcs_path {{{1
    1              0.000001 function! s:get_vcs_path(bufnr, vcs) abort
                              return (a:vcs =~# '\v(git|cvs|accurev|tfs|yadm)')
                                    \ ? getbufvar(a:bufnr, 'sy').info.file
                                    \ : getbufvar(a:bufnr, 'sy').info.path
                            endfunction
                            
                            " s:get_base_cmd {{{1
    1              0.000001 function! s:get_base_cmd(bufnr, vcs, vcs_cmds) abort
                              let cmd = a:vcs_cmds[a:vcs]
                              let cmd = s:replace(cmd, '%f', s:get_vcs_path(a:bufnr, a:vcs))
                              let cmd = s:replace(cmd, '%d', s:difftool)
                              let cmd = s:replace(cmd, '%n', s:devnull)
                              return cmd
                            endfunction
                            
                            " s:get_base {{{1
                            " Get the "base" version of the current buffer as a string.
    1              0.000001 function! s:get_base(bufnr, vcs) abort
                              return s:system_in_dir(s:get_base_cmd(a:bufnr, a:vcs, g:signify_vcs_cmds_diffmode))
                            endfunction
                            
                            " s:run {{{1
    1              0.000001 function! s:run(vcs)
                              try
                                let ret = s:system_in_dir(s:get_base_cmd(bufnr(''), a:vcs, g:signify_vcs_cmds))
                              catch
                                " This exception message can be seen via :SignifyDebugUnknown.
                                " E.g. unquoted VCS programs in vcd_cmds can lead to E484.
                                let ret = v:exception .' at '. v:throwpoint
                              finally
                                return ret
                              endtry
                            endfunction
                            
                            " s:replace {{{1
    1              0.000001 function! s:replace(cmd, pat, sub)
                              let parts = split(a:cmd, a:pat, 1)
                              return join(parts, a:sub)
                            endfunction
                            
                            " s:strip_context {{{1
    1              0.000001 function! s:strip_context(context)
                              let diff = []
                              let hunk = []
                              let state = 0
                              let lines = a:context
                              let linenr = 0
                            
                              while linenr < len(lines)
                                let line = lines[linenr]
                            
                                if state == 0
                                  if line =~ "^@@ "
                                    let [old_line, old_count, new_line, new_count] = sy#sign#parse_hunk(line)
                                    let hunk = []
                                    let state = 1
                                  else
                                    call add(diff,line)
                                  endif
                                  let linenr += 1
                                elseif index([1,2,3],state) >= 0 && index(['\','/'],line[0]) >= 0
                                  let linenr += 1
                                  call add(hunk,line)
                                elseif state == 1
                                  if line[0] == ' '
                                    let old_line += 1
                                    let new_line += 1
                                    let old_count -= 1
                                    let new_count -= 1
                                    let linenr += 1
                                  else
                                    let old_count_part = 0
                                    let new_count_part = 0
                                    let state = 2
                                  endif
                                elseif state == 2
                                  if line[0] == '-'
                                    call add(hunk,line)
                                    let old_count_part += 1
                                    let linenr += 1
                                  else
                                    let state = 3
                                  endif
                                elseif state == 3
                                  if line[0] == '+'
                                    call add(hunk,line)
                                    let new_count_part += 1
                                    let linenr += 1
                                  else
                                    call add(diff, printf("@@ -%d%s +%d%s @@",(old_count_part == 0 && old_line > 0) ? old_line -1 : old_line, old_count_part == 1 ? "" : printf(",%d", old_count_part), (new_count_part == 0 && new_line > 0) ? new_line - 1 : new_line, new_count_part == 1 ? "" : printf(",%d", new_count_part)))
                                    let diff += hunk
                                    let hunk = []
                                    let old_count -= old_count_part
                                    let new_count -= new_count_part
                                    let old_line += old_count_part
                                    let new_line += new_count_part
                                    let state = 1
                                  endif
                                endif
                            
                                if state > 0 && new_count <= 0 && old_count <= 0
                                  if len(hunk) > 0
                                    call add(diff, printf("@@ -%d%s +%d%s @@",(old_count_part == 0 && old_line > 0) ? old_line -1 : old_line, old_count_part == 1 ? "" : printf(",%d", old_count_part), (new_count_part == 0 && new_line > 0) ? new_line - 1 : new_line, new_count_part == 1 ? "" : printf(",%d", new_count_part)))
                                    let diff = diff + hunk
                                    let hunk = []
                                  endif
                                  let state = 0
                                endif
                              endwhile
                              if len(hunk) > 0
                                call add(diff, printf("@@ -%d%s +%d%s @@",(old_count_part == 0 && old_line > 0) ? old_line -1 : old_line, old_count_part == 1 ? "" : printf(",%d", old_count_part), (new_count_part == 0 && new_line > 0) ? new_line - 1 : new_line, new_count_part == 1 ? "" : printf(",%d", new_count_part)))
                                let diff = diff + hunk
                                let hunk = []
                              endif
                              return diff
                            endfunction
                            " 1}}}
                            
                            " Variables {{{1
    1   0.000022   0.000015 let s:default_vcs_cmds = {
                                  \ 'git':      'git diff --no-color --no-ext-diff -U0 -- %f',
                                  \ 'yadm':     'yadm diff --no-color --no-ext-diff -U0 -- %f',
                                  \ 'hg':       'hg --config alias.diff=diff diff --color=never --nodates -U0 -- %f',
                                  \ 'svn':      'svn diff --diff-cmd %d -x -U0 -- %f',
                                  \ 'bzr':      'bzr diff --using %d --diff-options=-U0 -- %f',
                                  \ 'darcs':    'darcs diff --no-pause-for-gui --no-unified --diff-opts=-U0 -- %f',
                                  \ 'fossil':   'fossil diff --unified -c 0 -- %f',
                                  \ 'cvs':      'cvs diff -U0 -- %f',
                                  \ 'rcs':      'rcsdiff -U0 %f 2>%n',
                                  \ 'accurev':  'accurev diff %f -- -U0',
                                  \ 'perforce': 'p4 info '. sy#util#shell_redirect('%n') . (has('win32') ? ' &&' : ' && env P4DIFF= P4COLORS=') .' p4 diff -du0 %f',
                                  \ 'tfs':      'tf diff -version:W -noprompt -format:Unified %f'
                                  \ }
                            
    1              0.000006 let s:default_vcs_cmds_diffmode = {
                                  \ 'git':      'git show HEAD:./%f',
                                  \ 'yadm':     'yadm show HEAD:./%f',
                                  \ 'hg':       'hg cat %f',
                                  \ 'svn':      'svn cat %f',
                                  \ 'bzr':      'bzr cat %f',
                                  \ 'darcs':    'darcs show contents -- %f',
                                  \ 'fossil':   'fossil cat %f',
                                  \ 'cvs':      'cvs up -p -- %f 2>%n',
                                  \ 'rcs':      'co -q -p %f',
                                  \ 'accurev':  'accurev cat %f',
                                  \ 'perforce': 'p4 print %f',
                                  \ 'tfs':      'tf view -version:W -noprompt %f',
                                  \ }
                            
    1              0.000001 if exists('g:signify_vcs_cmds')
                              call extend(g:signify_vcs_cmds, s:default_vcs_cmds, 'keep')
    1              0.000000 else
    1              0.000001   let g:signify_vcs_cmds = s:default_vcs_cmds
    1              0.000000 endif
    1              0.000001 if exists('g:signify_vcs_cmds_diffmode')
                              call extend(g:signify_vcs_cmds_diffmode, s:default_vcs_cmds_diffmode, 'keep')
    1              0.000000 else
    1              0.000001   let g:signify_vcs_cmds_diffmode = s:default_vcs_cmds_diffmode
    1              0.000000 endif
                            
    1              0.000053 let s:vcs_dict = map(copy(g:signify_vcs_cmds), 'split(v:val)[0]')
                            
    1              0.000001 if exists('g:signify_skip') && has_key(g:signify_skip, 'vcs')
                              if has_key(g:signify_skip.vcs, 'allow')
                                let s:vcs_list = filter(copy(g:signify_skip.vcs.allow), 'executable(s:vcs_dict[v:val])')
                              elseif has_key(g:signify_skip.vcs, 'deny')
                                for vcs in g:signify_skip.vcs.deny
                                  silent! call remove(s:vcs_dict, vcs)
                                endfor
                                let s:vcs_list = keys(filter(s:vcs_dict, 'executable(v:val)'))
                              end
    1              0.000000 else
    1              0.000188   let s:vcs_list = keys(filter(s:vcs_dict, 'executable(v:val)'))
    1              0.000000 endif
                            
    1   0.000011   0.000004 let s:difftool = sy#util#escape(get(g:, 'signify_difftool', 'diff'))
    1              0.000003 let s:devnull  = has('win32') || has ('win64') ? 'NUL' : '/dev/null'

SCRIPT  /home/francois/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/async.vim
Sourced 1 time
Total time:   0.000040
 Self time:   0.000040

count  total (s)   self (s)
    1              0.000006 let s:available = has('nvim') || (
                                  \   has('job') && (
                                  \     (has('patch-7.4.1826') && !has('gui_running')) ||
                                  \     (has('patch-7.4.1850') &&  has('gui_running')) ||
                                  \     (has('patch-7.4.1832') &&  has('gui_macvim'))
                                  \   )
                                  \ )
                            
    1              0.000001 let s:jobs = {}
                            
    1              0.000001 function! gitgutter#async#available()
                              return s:available
                            endfunction
                            
                            
    1              0.000001 function! gitgutter#async#execute(cmd, bufnr, handler) abort
                              call gitgutter#debug#log('[async] '.a:cmd)
                            
                              let options = {
                                    \   'stdoutbuffer': [],
                                    \   'buffer': a:bufnr,
                                    \   'handler': a:handler
                                    \ }
                              let command = s:build_command(a:cmd)
                            
                              if has('nvim')
                                call jobstart(command, extend(options, {
                                      \   'on_stdout': function('s:on_stdout_nvim'),
                                      \   'on_stderr': function('s:on_stderr_nvim'),
                                      \   'on_exit':   function('s:on_exit_nvim')
                                      \ }))
                              else
                                let job = job_start(command, {
                                      \   'out_cb':   function('s:on_stdout_vim', options),
                                      \   'err_cb':   function('s:on_stderr_vim', options),
                                      \   'close_cb': function('s:on_exit_vim', options)
                                      \ })
                                let s:jobs[s:job_id(job)] = 1
                              endif
                            endfunction
                            
                            
    1              0.000001 function! s:build_command(cmd)
                              if has('unix')
                                return ['sh', '-c', a:cmd]
                              endif
                            
                              if has('win32')
                                return has('nvim') ? a:cmd : 'cmd.exe /c '.a:cmd
                              endif
                            
                              throw 'unknown os'
                            endfunction
                            
                            
    1              0.000001 function! s:on_stdout_nvim(_job_id, data, _event) dict abort
                              if empty(self.stdoutbuffer)
                                let self.stdoutbuffer = a:data
                              else
                                let self.stdoutbuffer = self.stdoutbuffer[:-2] +
                                      \ [self.stdoutbuffer[-1] . a:data[0]] +
                                      \ a:data[1:]
                              endif
                            endfunction
                            
    1              0.000001 function! s:on_stderr_nvim(_job_id, data, _event) dict abort
                              if a:data != ['']  " With Neovim there is always [''] reported on stderr.
                                call self.handler.err(self.buffer)
                              endif
                            endfunction
                            
    1              0.000001 function! s:on_exit_nvim(_job_id, exit_code, _event) dict abort
                              if !a:exit_code
                                call self.handler.out(self.buffer, join(self.stdoutbuffer, "\n"))
                              endif
                            endfunction
                            
                            
    1              0.000001 function! s:on_stdout_vim(_channel, data) dict abort
                              call add(self.stdoutbuffer, a:data)
                            endfunction
                            
    1              0.000001 function! s:on_stderr_vim(channel, _data) dict abort
                              call self.handler.err(self.buffer)
                            endfunction
                            
    1              0.000001 function! s:on_exit_vim(channel) dict abort
                              let job = ch_getjob(a:channel)
                              let jobid = s:job_id(job)
                              if has_key(s:jobs, jobid) | unlet s:jobs[jobid] | endif
                              while 1
                                if job_status(job) == 'dead'
                                  let exit_code = job_info(job).exitval
                                  break
                                endif
                                sleep 5m
                              endwhile
                            
                              if !exit_code
                                call self.handler.out(self.buffer, join(self.stdoutbuffer, "\n"))
                              endif
                            endfunction
                            
    1              0.000001 function! s:job_id(job)
                              " Vim
                              return job_info(a:job).process
                            endfunction

SCRIPT  /home/francois/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/debug.vim
Sourced 1 time
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
    1              0.000004 let s:plugin_dir  = expand('<sfile>:p:h:h:h').'/'
    1              0.000001 let s:log_file    = s:plugin_dir.'gitgutter.log'
    1              0.000001 let s:channel_log = s:plugin_dir.'channel.log'
    1              0.000001 let s:new_log_session = 1
                            
                            
    1              0.000001 function! gitgutter#debug#debug()
                              " Open a scratch buffer
                              vsplit __GitGutter_Debug__
                              normal! ggdG
                              setlocal buftype=nofile
                              setlocal bufhidden=delete
                              setlocal noswapfile
                            
                              call s:vim_version()
                              call s:separator()
                            
                              call s:git_version()
                              call s:separator()
                            
                              call s:grep_version()
                              call s:separator()
                            
                              call s:option('updatetime')
                            endfunction
                            
                            
    1              0.000001 function! s:separator()
                              call s:output('')
                            endfunction
                            
    1              0.000001 function! s:vim_version()
                              redir => version_info
                                silent execute 'version'
                              redir END
                              call s:output(split(version_info, '\n')[0:2])
                            endfunction
                            
    1              0.000000 function! s:git_version()
                              let v = system(g:gitgutter_git_executable.' --version')
                              call s:output( substitute(v, '\n$', '', '') )
                            endfunction
                            
    1              0.000000 function! s:grep_version()
                              let v = system(g:gitgutter_grep.' --version')
                              call s:output( substitute(v, '\n$', '', '') )
                            
                              let v = system(g:gitgutter_grep.' --help')
                              call s:output( substitute(v, '\%x00', '', 'g') )
                            endfunction
                            
    1              0.000001 function! s:option(name)
                              if exists('+' . a:name)
                                let v = eval('&' . a:name)
                                call s:output(a:name . '=' . v)
                                " redir => output
                                "   silent execute "verbose set " . a:name . "?"
                                " redir END
                                " call s:output(a:name . '=' . output)
                              else
                                call s:output(a:name . ' [n/a]')
                              end
                            endfunction
                            
    1              0.000000 function! s:output(text)
                              call append(line('$'), a:text)
                            endfunction
                            
                            " assumes optional args are calling function's optional args
    1              0.000001 function! gitgutter#debug#log(message, ...) abort
                              if g:gitgutter_log
                                if s:new_log_session && gitgutter#async#available()
                                  if exists('*ch_logfile')
                                    call ch_logfile(s:channel_log, 'w')
                                  endif
                                endif
                            
                                if s:new_log_session
                                  let s:start = reltime()
                                  call writefile(['', '========== start log session '.strftime('%d.%m.%Y %H:%M:%S').' =========='], s:log_file, 'a')
                                endif
                            
                                let elapsed = reltimestr(reltime(s:start)).' '
                                call writefile([''], s:log_file, 'a')
                                " callers excluding this function
                                call writefile([elapsed.expand('<sfile>')[:-22].':'], s:log_file, 'a')
                                call writefile([elapsed.s:format_for_log(a:message)], s:log_file, 'a')
                                if a:0 && !empty(a:1)
                                  for msg in a:000
                                    call writefile([elapsed.s:format_for_log(msg)], s:log_file, 'a')
                                  endfor
                                endif
                            
                                let s:new_log_session = 0
                              endif
                            endfunction
                            
    1              0.000001 function! s:format_for_log(data) abort
                              if type(a:data) == 1
                                return join(split(a:data,'\n'),"\n")
                              elseif type(a:data) == 3
                                return '['.join(a:data,"\n").']'
                              else
                                return a:data
                              endif
                            endfunction
                            

SCRIPT  /usr/share/nvim/runtime/ftplugin/python.vim
Sourced 1 time
Total time:   0.000205
 Self time:   0.000205

count  total (s)   self (s)
                            " Vim filetype plugin file
                            " Language:	python
                            " Maintainer:	Tom Picton <tom@tompicton.com>
                            " Previous Maintainer: James Sully <sullyj3@gmail.com>
                            " Previous Maintainer: Johannes Zellner <johannes@zellner.org>
                            " Last Change:	2024/05/13
                            " https://github.com/tpict/vim-ftplugin-python
                            
    1              0.000003 if exists("b:did_ftplugin") | finish | endif
    1              0.000001 let b:did_ftplugin = 1
    1              0.000001 let s:keepcpo= &cpo
    1              0.000004 set cpo&vim
                            
    1              0.000002 setlocal cinkeys-=0#
    1              0.000002 setlocal indentkeys-=0#
    1              0.000002 setlocal include=^\\s*\\(from\\\|import\\)
    1              0.000001 setlocal define=^\\s*\\(\\(async\\s\\+\\)\\?def\\\|class\\)
                            
                            " For imports with leading .., append / and replace additional .s with ../
    1              0.000001 let b:grandparent_match = '^\(.\.\)\(\.*\)'
    1              0.000001 let b:grandparent_sub = '\=submatch(1)."/".repeat("../",strlen(submatch(2)))'
                            
                            " For imports with a single leading ., replace it with ./
    1              0.000001 let b:parent_match = '^\.\(\.\)\@!'
    1              0.000001 let b:parent_sub = './'
                            
                            " Replace any . sandwiched between word characters with /
    1              0.000001 let b:child_match = '\(\w\)\.\(\w\)'
    1              0.000001 let b:child_sub = '\1/\2'
                            
    1              0.000003 setlocal includeexpr=substitute(substitute(substitute(
                                  \v:fname,
                                  \b:grandparent_match,b:grandparent_sub,''),
                                  \b:parent_match,b:parent_sub,''),
                                  \b:child_match,b:child_sub,'g')
                            
    1              0.000002 setlocal suffixesadd=.py
    1              0.000002 setlocal comments=b:#,fb:-
    1              0.000002 setlocal commentstring=#\ %s
                            
    1              0.000002 if has('python3')
    1              0.000003   setlocal omnifunc=python3complete#Complete
                            elseif has('python')
                              setlocal omnifunc=pythoncomplete#Complete
    1              0.000000 endif
                            
    1              0.000002 set wildignore+=*.pyc
                            
    1              0.000001 let b:next_toplevel='\v%$\|^(class\|def\|async def)>'
    1              0.000001 let b:prev_toplevel='\v^(class\|def\|async def)>'
    1              0.000001 let b:next_endtoplevel='\v%$\|\S.*\n+(def\|class)'
    1              0.000001 let b:prev_endtoplevel='\v\S.*\n+(def\|class)'
    1              0.000001 let b:next='\v%$\|^\s*(class\|def\|async def)>'
    1              0.000001 let b:prev='\v^\s*(class\|def\|async def)>'
    1              0.000001 let b:next_end='\v\S\n*(%$\|^(\s*\n*)*(class\|def\|async def)\|^\S)'
    1              0.000001 let b:prev_end='\v\S\n*(^(\s*\n*)*(class\|def\|async def)\|^\S)'
                            
    1              0.000002 if !exists('g:no_plugin_maps') && !exists('g:no_python_maps')
    1              0.000006     execute "nnoremap <silent> <buffer> ]] :<C-U>call <SID>Python_jump('n', '". b:next_toplevel."', 'W', v:count1)<cr>"
    1              0.000005     execute "nnoremap <silent> <buffer> [[ :<C-U>call <SID>Python_jump('n', '". b:prev_toplevel."', 'Wb', v:count1)<cr>"
    1              0.000003     execute "nnoremap <silent> <buffer> ][ :<C-U>call <SID>Python_jump('n', '". b:next_endtoplevel."', 'W', v:count1, 0)<cr>"
    1              0.000004     execute "nnoremap <silent> <buffer> [] :<C-U>call <SID>Python_jump('n', '". b:prev_endtoplevel."', 'Wb', v:count1, 0)<cr>"
    1              0.000003     execute "nnoremap <silent> <buffer> ]m :<C-U>call <SID>Python_jump('n', '". b:next."', 'W', v:count1)<cr>"
    1              0.000003     execute "nnoremap <silent> <buffer> [m :<C-U>call <SID>Python_jump('n', '". b:prev."', 'Wb', v:count1)<cr>"
    1              0.000004     execute "nnoremap <silent> <buffer> ]M :<C-U>call <SID>Python_jump('n', '". b:next_end."', 'W', v:count1, 0)<cr>"
    1              0.000003     execute "nnoremap <silent> <buffer> [M :<C-U>call <SID>Python_jump('n', '". b:prev_end."', 'Wb', v:count1, 0)<cr>"
                            
    1              0.000003     execute "onoremap <silent> <buffer> ]] :call <SID>Python_jump('o', '". b:next_toplevel."', 'W', v:count1)<cr>"
    1              0.000003     execute "onoremap <silent> <buffer> [[ :call <SID>Python_jump('o', '". b:prev_toplevel."', 'Wb', v:count1)<cr>"
    1              0.000003     execute "onoremap <silent> <buffer> ][ :call <SID>Python_jump('o', '". b:next_endtoplevel."', 'W', v:count1, 0)<cr>"
    1              0.000003     execute "onoremap <silent> <buffer> [] :call <SID>Python_jump('o', '". b:prev_endtoplevel."', 'Wb', v:count1, 0)<cr>"
    1              0.000003     execute "onoremap <silent> <buffer> ]m :call <SID>Python_jump('o', '". b:next."', 'W', v:count1)<cr>"
    1              0.000003     execute "onoremap <silent> <buffer> [m :call <SID>Python_jump('o', '". b:prev."', 'Wb', v:count1)<cr>"
    1              0.000003     execute "onoremap <silent> <buffer> ]M :call <SID>Python_jump('o', '". b:next_end."', 'W', v:count1, 0)<cr>"
    1              0.000004     execute "onoremap <silent> <buffer> [M :call <SID>Python_jump('o', '". b:prev_end."', 'Wb', v:count1, 0)<cr>"
                            
    1              0.000003     execute "xnoremap <silent> <buffer> ]] :call <SID>Python_jump('x', '". b:next_toplevel."', 'W', v:count1)<cr>"
    1              0.000004     execute "xnoremap <silent> <buffer> [[ :call <SID>Python_jump('x', '". b:prev_toplevel."', 'Wb', v:count1)<cr>"
    1              0.000003     execute "xnoremap <silent> <buffer> ][ :call <SID>Python_jump('x', '". b:next_endtoplevel."', 'W', v:count1, 0)<cr>"
    1              0.000003     execute "xnoremap <silent> <buffer> [] :call <SID>Python_jump('x', '". b:prev_endtoplevel."', 'Wb', v:count1, 0)<cr>"
    1              0.000003     execute "xnoremap <silent> <buffer> ]m :call <SID>Python_jump('x', '". b:next."', 'W', v:count1)<cr>"
    1              0.000003     execute "xnoremap <silent> <buffer> [m :call <SID>Python_jump('x', '". b:prev."', 'Wb', v:count1)<cr>"
    1              0.000003     execute "xnoremap <silent> <buffer> ]M :call <SID>Python_jump('x', '". b:next_end."', 'W', v:count1, 0)<cr>"
    1              0.000003     execute "xnoremap <silent> <buffer> [M :call <SID>Python_jump('x', '". b:prev_end."', 'Wb', v:count1, 0)<cr>"
    1              0.000000 endif
                            
    1              0.000002 if !exists('*<SID>Python_jump')
    1              0.000002   fun! <SID>Python_jump(mode, motion, flags, count, ...) range
                                  let l:startofline = (a:0 >= 1) ? a:1 : 1
                            
                                  if a:mode == 'x'
                                      normal! gv
                                  endif
                            
                                  if l:startofline == 1
                                      normal! 0
                                  endif
                            
                                  let cnt = a:count
                                  mark '
                                  while cnt > 0
                                      call search(a:motion, a:flags)
                                      let cnt = cnt - 1
                                  endwhile
                            
                                  if l:startofline == 1
                                      normal! ^
                                  endif
                              endfun
    1              0.000000 endif
                            
    1              0.000002 if has("browsefilter") && !exists("b:browsefilter")
    1              0.000001     let b:browsefilter = "Python Files (*.py)\t*.py\n"
    1              0.000001     if has("win32")
                            	let b:browsefilter .= "All Files (*.*)\t*\n"
    1              0.000000     else
    1              0.000001 	let b:browsefilter .= "All Files (*)\t*\n"
    1              0.000000     endif
    1              0.000000 endif
                            
    1              0.000002 if !exists("g:python_recommended_style") || g:python_recommended_style != 0
                                " As suggested by PEP8.
    1              0.000004     setlocal expandtab tabstop=4 softtabstop=4 shiftwidth=4
    1              0.000000 endif
                            
                            " Use pydoc for keywordprg.
                            " Unix users preferentially get pydoc3, then pydoc2.
                            " Windows doesn't have a standalone pydoc executable in $PATH by default, nor
                            " does it have separate python2/3 executables, so Windows users just get
                            " whichever version corresponds to their installed Python version.
    1              0.000011 if executable('python3')
    1              0.000002   setlocal keywordprg=python3\ -m\ pydoc
                            elseif executable('python')
                              setlocal keywordprg=python\ -m\ pydoc
    1              0.000000 endif
                            
                            " Script for filetype switching to undo the local stuff we may have changed
    1              0.000025 let b:undo_ftplugin = 'setlocal cinkeys<'
                                  \ . '|setlocal comments<'
                                  \ . '|setlocal commentstring<'
                                  \ . '|setlocal expandtab<'
                                  \ . '|setlocal include<'
                                  \ . '|setlocal includeexpr<'
                                  \ . '|setlocal indentkeys<'
                                  \ . '|setlocal keywordprg<'
                                  \ . '|setlocal omnifunc<'
                                  \ . '|setlocal shiftwidth<'
                                  \ . '|setlocal softtabstop<'
                                  \ . '|setlocal suffixesadd<'
                                  \ . '|setlocal tabstop<'
                                  \ . '|silent! nunmap <buffer> [M'
                                  \ . '|silent! nunmap <buffer> [['
                                  \ . '|silent! nunmap <buffer> []'
                                  \ . '|silent! nunmap <buffer> [m'
                                  \ . '|silent! nunmap <buffer> ]M'
                                  \ . '|silent! nunmap <buffer> ]['
                                  \ . '|silent! nunmap <buffer> ]]'
                                  \ . '|silent! nunmap <buffer> ]m'
                                  \ . '|silent! ounmap <buffer> [M'
                                  \ . '|silent! ounmap <buffer> [['
                                  \ . '|silent! ounmap <buffer> []'
                                  \ . '|silent! ounmap <buffer> [m'
                                  \ . '|silent! ounmap <buffer> ]M'
                                  \ . '|silent! ounmap <buffer> ]['
                                  \ . '|silent! ounmap <buffer> ]]'
                                  \ . '|silent! ounmap <buffer> ]m'
                                  \ . '|silent! xunmap <buffer> [M'
                                  \ . '|silent! xunmap <buffer> [['
                                  \ . '|silent! xunmap <buffer> []'
                                  \ . '|silent! xunmap <buffer> [m'
                                  \ . '|silent! xunmap <buffer> ]M'
                                  \ . '|silent! xunmap <buffer> ]['
                                  \ . '|silent! xunmap <buffer> ]]'
                                  \ . '|silent! xunmap <buffer> ]m'
                                  \ . '|unlet! b:browsefilter'
                                  \ . '|unlet! b:child_match'
                                  \ . '|unlet! b:child_sub'
                                  \ . '|unlet! b:grandparent_match'
                                  \ . '|unlet! b:grandparent_sub'
                                  \ . '|unlet! b:next'
                                  \ . '|unlet! b:next_end'
                                  \ . '|unlet! b:next_endtoplevel'
                                  \ . '|unlet! b:next_toplevel'
                                  \ . '|unlet! b:parent_match'
                                  \ . '|unlet! b:parent_sub'
                                  \ . '|unlet! b:prev'
                                  \ . '|unlet! b:prev_end'
                                  \ . '|unlet! b:prev_endtoplevel'
                                  \ . '|unlet! b:prev_toplevel'
                                  \ . '|unlet! b:undo_ftplugin'
                            
    1              0.000002 let &cpo = s:keepcpo
    1              0.000001 unlet s:keepcpo

SCRIPT  /usr/share/nvim/runtime/indent/python.vim
Sourced 1 time
Total time:   0.000031
 Self time:   0.000031

count  total (s)   self (s)
                            " Vim indent file
                            " Language:	Python
                            " Maintainer:	The Vim Project <https://github.com/vim/vim>
                            " Last Change:	2023 Aug 10
                            " Former Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Original Author:	David Bustos <bustos@caltech.edu>
                            
                            " Only load this indent file when no other was loaded.
    1              0.000001 if exists("b:did_indent")
                              finish
    1              0.000000 endif
    1              0.000001 let b:did_indent = 1
                            
                            " Some preliminary settings
    1              0.000006 setlocal nolisp		" Make sure lisp indenting doesn't supersede us
    1              0.000001 setlocal autoindent	" indentexpr isn't much help otherwise
                            
    1              0.000002 setlocal indentexpr=python#GetIndent(v:lnum)
    1              0.000007 setlocal indentkeys+=<:>,=elif,=except
                            
    1              0.000001 let b:undo_indent = "setl ai< inde< indk< lisp<"
                            
                            " Only define the function once.
    1              0.000001 if exists("*GetPythonIndent")
                              finish
    1              0.000000 endif
                            
                            " Keep this for backward compatibility, new scripts should use
                            " python#GetIndent()
    1              0.000001 function GetPythonIndent(lnum)
                              return python#GetIndent(a:lnum)
                            endfunction
                            
                            " vim:sw=2

SCRIPT  /home/francois/.local/share/nvim/lazy/vim-signify/autoload/sy/sign.vim
Sourced 1 time
Total time:   0.000092
 Self time:   0.000092

count  total (s)   self (s)
                            " vim: et sw=2 sts=2 fdm=marker
                            
    1              0.000002 scriptencoding utf-8
                            
                            " Variables {{{1
    1              0.000003 let s:sign_delete = get(g:, 'signify_sign_delete', '_')
                            
                            " Support for sign priority was added together with sign_place().
    1              0.000002 if exists('*sign_place')
    1              0.000004   let s:sign_priority = printf('priority=%d', get(g:, 'signify_priority', 10))
                            else
                              let s:sign_priority = ''
    1              0.000000 endif
                            
    1              0.000001 let s:sign_show_count  = get(g:, 'signify_sign_show_count', 1)
    1              0.000001 let s:delete_highlight = ['', 'SignifyLineDelete']
                            " 1}}}
                            
                            " #id_next {{{1
    1              0.000002 function! sy#sign#id_next(sy) abort
                              let id = a:sy.signid
                              let a:sy.signid += 1
                              return id
                            endfunction
                            
                            " #get_current_signs {{{1
    1              0.000001 function! sy#sign#get_current_signs(sy) abort
                              let a:sy.internal = {}
                              let a:sy.external = {}
                            
                              let signlist = sy#util#get_signs(a:sy.buffer)
                            
                              for sign in signlist
                                if sign.name =~# '^Signify'
                                  " Handle ambiguous signs. Assume you have signs on line 3 and 4.
                                  " Removing line 3 would lead to the second sign to be shifted up
                                  " to line 3. Now there are still 2 signs, both one line 3.
                                  if has_key(a:sy.internal, sign.lnum)
                                    execute 'sign unplace' a:sy.internal[sign.lnum].id 'buffer='.a:sy.buffer
                                  endif
                                  let a:sy.internal[sign.lnum] = { 'type': sign.name, 'id': sign.id }
                                else
                                  let a:sy.external[sign.lnum] = sign.id
                                endif
                              endfor
                            endfunction
                            
                            
                            " #process_diff {{{1
    1              0.000001 function! sy#sign#process_diff(sy, vcs, diff) abort
                              let a:sy.signtable             = {}
                              let a:sy.hunks                 = []
                              let [added, modified, deleted] = [0, 0, 0]
                            
                              call sy#sign#get_current_signs(a:sy)
                            
                              " Determine where we have to put our signs.
                              for line in filter(a:diff, 'v:val =~ "^@@ "')
                                let a:sy.lines = []
                                let ids        = []
                            
                                let [old_line, old_count, new_line, new_count] = sy#sign#parse_hunk(line)
                            
                                " Workaround for non-conventional diff output in older Fossil versions:
                                " https://fossil-scm.org/forum/forumpost/834ce0f1e1
                                " Fixed as of: https://fossil-scm.org/index.html/info/7fd2a3652ea7368a
                                if a:vcs == 'fossil' && new_line == 0
                                  let new_line = old_line - 1 - deleted
                                endif
                            
                                " Pure add:
                            
                                " @@ -5,0 +6,2 @@ this is line 5
                                " +this is line 5
                                " +this is line 5
                                if old_count == 0 && new_count > 0
                                  let added += new_count
                                  let offset = 0
                                  while offset < new_count
                                    let line    = new_line + offset
                                    let offset += 1
                                    if s:external_sign_present(a:sy, line) | continue | endif
                                    call add(ids, s:add_sign(a:sy, line, 'SignifyAdd'))
                                  endwhile
                            
                                " Pure delete
                            
                                " @@ -6,2 +5,0 @@ this is line 5
                                " -this is line 6
                                " -this is line 7
                                elseif old_count > 0 && new_count == 0
                                  if s:external_sign_present(a:sy, new_line) | continue | endif
                                  let deleted += old_count
                                  if new_line == 0
                                    call add(ids, s:add_sign(a:sy, 1, 'SignifyRemoveFirstLine'))
                                  elseif s:sign_show_count
                                    if old_count > 99
                                      let text = s:sign_delete . '>'
                                    elseif old_count < 2
                                      let text = s:sign_delete
                                    else
                                      let text = s:sign_delete . old_count
                                    endif
                                    while strwidth(text) > 2
                                      let text = substitute(text, '.', '', '')
                                    endwhile
                                    call add(ids, s:add_sign(a:sy, new_line, 'SignifyDelete'. old_count, text))
                                  else
                                    call add(ids, s:add_sign(a:sy, new_line, 'SignifyDeleteMore', s:sign_delete))
                                  endif
                                " All lines are modified.
                                elseif old_count > 0 && new_count > 0 && old_count == new_count
                                  let modified += new_count
                                  let offset = 0
                                  while offset < new_count
                                    let line    = new_line + offset
                                    let offset += 1
                                    if s:external_sign_present(a:sy, line) | continue | endif
                                    call add(ids, s:add_sign(a:sy, line, 'SignifyChange'))
                                  endwhile
                                " Some lines are modified and some new lines are added.
                                elseif old_count > 0 && new_count > 0 && old_count < new_count
                                  let modified += old_count
                                  let added += new_count - old_count
                                  let offset = 0
                                  while offset < old_count
                                    let line    = new_line + offset
                                    let offset += 1
                                    if s:external_sign_present(a:sy, line) | continue | endif
                                    call add(ids, s:add_sign(a:sy, line, 'SignifyChange'))
                                  endwhile
                                  while offset < new_count
                                    let line    = new_line + offset
                                    let offset += 1
                                    if s:external_sign_present(a:sy, line) | continue | endif
                                    call add(ids, s:add_sign(a:sy, line, 'SignifyAdd'))
                                  endwhile
                                " Some lines are modified and some lines are deleted.
                                elseif old_count > 0 && new_count > 0 && old_count > new_count
                                  let modified += new_count
                                  let deleted_count = old_count - new_count
                                  let deleted += deleted_count
                            
                                  let prev_line_available = new_line > 1 && !get(a:sy.signtable, new_line - 1, 0)
                                  if prev_line_available
                                    if s:sign_show_count
                                      if deleted_count > 99
                                        let text = s:sign_delete . '>'
                                      elseif deleted_count < 2
                                        let text = s:sign_delete
                                      else
                                        let text = s:sign_delete . deleted_count
                                      endif
                                      while strwidth(text) > 2
                                        let text = substitute(text, '.', '', '')
                                      endwhile
                                      call add(ids, s:add_sign(a:sy, new_line - 1, 'SignifyDelete'. deleted_count, text))
                                    else
                                      call add(ids, s:add_sign(a:sy, new_line - 1, 'SignifyDeleteMore', s:sign_delete))
                                    endif
                                  endif
                            
                                  let offset = 0
                                  while offset < new_count
                                    let line    = new_line + offset
                                    if s:external_sign_present(a:sy, line) | continue | endif
                                    if !prev_line_available && offset == 0
                                      call add(ids, s:add_sign(a:sy, line, 'SignifyChangeDelete'))
                                    else
                                      call add(ids, s:add_sign(a:sy, line, 'SignifyChange'))
                                    endif
                                    let offset += 1
                                  endwhile
                                endif
                            
                                if !empty(ids)
                                  call add(a:sy.hunks, {
                                        \ 'ids'  : ids,
                                        \ 'start': a:sy.lines[0],
                                        \ 'end'  : a:sy.lines[-1] })
                                endif
                              endfor
                            
                              " Remove obsoleted signs.
                              for line in filter(keys(a:sy.internal), '!has_key(a:sy.signtable, v:val)')
                                execute 'sign unplace' a:sy.internal[line].id 'buffer='.a:sy.buffer
                              endfor
                            
                              if empty(a:sy.updated_by) && empty(a:sy.hunks)
                                call sy#verbose('Successful exit value, but no diff. Keep VCS for time being.', a:vcs)
                                return
                              endif
                            
                              call sy#verbose('Signs updated.', a:vcs)
                              let a:sy.updated_by = a:vcs
                              if len(a:sy.vcs) > 1
                                call sy#verbose('Disable all other VCS.', a:vcs)
                                let a:sy.vcs = [a:vcs]
                              endif
                            
                              let a:sy.stats = [added, modified, deleted]
                            endfunction
                            
                            " #remove_all_signs {{{1
    1              0.000001 function! sy#sign#remove_all_signs(bufnr) abort
                              let sy = getbufvar(a:bufnr, 'sy', {})
                            
                              for hunk in get(sy, 'hunks', [])
                                for id in get(hunk, 'ids', [])
                                  execute 'sign unplace' id 'buffer='.a:bufnr
                                endfor
                              endfor
                            
                              let sy.hunks = []
                            endfunction
                            
                            " #parse_hunk {{{1
                            " Parse a hunk as '@@ -273,3 +267,14' into [old_line, old_count, new_line, new_count]
    1              0.000001 function! sy#sign#parse_hunk(diffline) abort
                              let tokens = matchlist(a:diffline, '^@@ -\v(\d+),?(\d*) \+(\d+),?(\d*)')
                              return [
                                    \ str2nr(tokens[1]),
                                    \ empty(tokens[2]) ? 1 : str2nr(tokens[2]),
                                    \ str2nr(tokens[3]),
                                    \ empty(tokens[4]) ? 1 : str2nr(tokens[4])
                                    \ ]
                            endfunction
                            
                            " #set_signs {{{1
    1              0.000001 function! sy#sign#set_signs(sy, vcs, diff) abort
                              call sy#verbose('sy#sign#set_signs()', a:vcs)
                            
                              if a:sy.stats == [-1, -1, -1]
                                let a:sy.stats = [0, 0, 0]
                              endif
                            
                              if empty(a:diff)
                                call sy#verbose('No changes found.', a:vcs)
                                let a:sy.stats = [0, 0, 0]
                                call sy#sign#remove_all_signs(a:sy.buffer)
                                return
                              endif
                            
                              if get(g:, 'signify_line_highlight')
                                call sy#highlight#line_enable()
                              else
                                call sy#highlight#line_disable()
                              endif
                            
                              call sy#sign#process_diff(a:sy, a:vcs, a:diff)
                            
                              if exists('#User#Signify')
                                doautocmd <nomodeline> User Signify
                              endif
                            endfunction
                            
                            " s:add_sign {{{1
    1              0.000001 function! s:add_sign(sy, line, type, ...) abort
                              call add(a:sy.lines, a:line)
                              let a:sy.signtable[a:line] = 1
                            
                              if has_key(a:sy.internal, a:line)
                                " There is a sign on this line already.
                                if a:type == a:sy.internal[a:line].type
                                  " Keep current sign since the new one is of the same type.
                                  return a:sy.internal[a:line].id
                                else
                                  " Update sign by overwriting the ID of the current sign.
                                  let id = a:sy.internal[a:line].id
                                endif
                              endif
                            
                              if !exists('id')
                                let id = sy#sign#id_next(a:sy)
                              endif
                            
                              if a:type =~# 'SignifyDelete'
                                execute printf('sign define %s text=%s texthl=SignifySignDelete linehl=%s %s',
                                      \ a:type,
                                      \ a:1,
                                      \ s:delete_highlight[g:signify_line_highlight],
                                      \ sy#util#numhl('SignifySignDelete'))
                              endif
                              execute printf('sign place %d line=%d name=%s %s buffer=%s',
                                    \ id,
                                    \ a:line,
                                    \ a:type,
                                    \ s:sign_priority,
                                    \ a:sy.buffer)
                            
                              return id
                            endfunction
                            
                            " s:external_sign_present {{{1
    1              0.000001 function! s:external_sign_present(sy, line) abort
                              " If sign priority is supported, so are multiple signs per line.
                              " Therefore, we can report no external signs present and let
                              " g:signify_priority control whether Sy's signs are shown.
                              if !empty(s:sign_priority)
                                return
                              endif
                              if has_key(a:sy.external, a:line)
                                if has_key(a:sy.internal, a:line)
                                  " Remove Sy signs from lines with other signs.
                                  execute 'sign unplace' a:sy.internal[a:line].id 'buffer='.a:sy.buffer
                                endif
                                return 1
                              endif
                            endfunction

SCRIPT  /home/francois/.local/share/nvim/lazy/vim-signify/autoload/sy/highlight.vim
Sourced 1 time
Total time:   0.000092
 Self time:   0.000038

count  total (s)   self (s)
                            " vim: et sw=2 sts=2 fdm=marker
                            
    1              0.000001 scriptencoding utf-8
                            
                            " Variables {{{1
    1              0.000002 let s:sign_add               = get(g:, 'signify_sign_add',               '+')
    1              0.000002 let s:sign_delete_first_line = get(g:, 'signify_sign_delete_first_line', '‾')
    1              0.000001 let s:sign_change            = get(g:, 'signify_sign_change',            '!')
    1              0.000002 let s:sign_change_delete     = get(g:, 'signify_sign_change_delete', s:sign_change . s:sign_delete_first_line)
    1              0.000002 if strdisplaywidth(s:sign_change_delete) > 2
                              call sy#verbose(printf('Changing g:signify_sign_change_delete from %s to !- to avoid E239', s:sign_change_delete))
                              let s:sign_change_delete = '!-'
    1              0.000000 endif
    1              0.000001 let s:sign_show_count = get(g:, 'signify_sign_show_count', 1)
                            " 1}}}
                            
                            " #setup {{{1
    1              0.000001 function! sy#highlight#setup() abort
                              highlight default link SignifyLineAdd             DiffAdd
                              highlight default link SignifyLineDelete          DiffDelete
                              highlight default link SignifyLineDeleteFirstLine SignifyLineDelete
                              highlight default link SignifyLineChange          DiffChange
                              highlight default link SignifyLineChangeDelete    SignifyLineChange
                            
                              highlight default link SignifySignAdd             DiffAdd
                              highlight default link SignifySignDelete          DiffDelete
                              highlight default link SignifySignDeleteFirstLine SignifySignDelete
                              highlight default link SignifySignChange          DiffChange
                              highlight default link SignifySignChangeDelete    SignifySignChange
                            endfunction
                            
                            " #line_enable {{{1
    1              0.000001 function! sy#highlight#line_enable() abort
                              execute 'sign define SignifyAdd text='. s:sign_add ' texthl=SignifySignAdd linehl=SignifyLineAdd '. sy#util#numhl('SignifySignAdd')
                              execute 'sign define SignifyChange text='. s:sign_change ' texthl=SignifySignChange linehl=SignifyLineChange '. sy#util#numhl('SignifySignChange')
                              execute 'sign define SignifyChangeDelete text='. s:sign_change_delete ' texthl=SignifySignChangeDelete linehl=SignifyLineChangeDelete '. sy#util#numhl('SignifySignChangeDelete')
                              execute 'sign define SignifyRemoveFirstLine text='. s:sign_delete_first_line ' texthl=SignifySignDeleteFirstLine linehl=SignifyLineDeleteFirstLine '. sy#util#numhl('SignifySignDeleteFirstLine')
                              let g:signify_line_highlight = 1
                            endfunction
                            
                            " #line_disable {{{1
    1              0.000001 function! sy#highlight#line_disable() abort
                              execute 'sign define SignifyAdd text='. s:sign_add ' texthl=SignifySignAdd linehl= '. sy#util#numhl('SignifySignAdd')
                              execute 'sign define SignifyChange text='. s:sign_change ' texthl=SignifySignChange linehl= '. sy#util#numhl('SignifySignChange')
                              execute 'sign define SignifyChangeDelete text='. s:sign_change_delete ' texthl=SignifySignChangeDelete linehl= '. sy#util#numhl('SignifySignChangeDelete')
                              execute 'sign define SignifyRemoveFirstLine text='. s:sign_delete_first_line ' texthl=SignifySignDeleteFirstLine linehl= '. sy#util#numhl('SignifySignDeleteFirstLine')
                              let g:signify_line_highlight = 0
                            endfunction
                            
                            " #line_toggle {{{1
    1              0.000001 function! sy#highlight#line_toggle() abort
                              if get(g:, 'signify_line_highlight')
                                call sy#highlight#line_disable()
                              else
                                call sy#highlight#line_enable()
                              endif
                            
                              redraw!
                              call sy#start()
                            endfunction
                            " }}}
                            
    1   0.000059   0.000004 call sy#highlight#setup()

SCRIPT  /home/francois/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/diff.vim
Sourced 1 time
Total time:   0.000103
 Self time:   0.000103

count  total (s)   self (s)
    1              0.000001 scriptencoding utf8
                            
    1              0.000003 let s:nomodeline = (v:version > 703 || (v:version == 703 && has('patch442'))) ? '<nomodeline>' : ''
                            
    1              0.000001 let s:hunk_re = '^@@ -\(\d\+\),\?\(\d*\) +\(\d\+\),\?\(\d*\) @@'
                            
    1              0.000005 let s:temp_from = tempname()
    1              0.000002 let s:temp_buffer = tempname()
    1              0.000001 let s:counter = 0
                            
                            " Returns a diff of the buffer against the index or the working tree.
                            "
                            " After running the diff we pass it through grep where available to reduce
                            " subsequent processing by the plugin.  If grep is not available the plugin
                            " does the filtering instead.
                            "
                            " When diffing against the index:
                            "
                            " The buffer contents is not the same as the file on disk so we need to pass
                            " two instances of the file to git-diff:
                            "
                            "     git diff myfileA myfileB
                            "
                            " where myfileA comes from
                            "
                            "     git show :myfile > myfileA
                            "
                            " and myfileB is the buffer contents.
                            "
                            " Regarding line endings:
                            "
                            " git-show does not convert line endings.
                            " git-diff FILE FILE does convert line endings for the given files.
                            "
                            " If a file has CRLF line endings and git's core.autocrlf is true,
                            " the file in git's object store will have LF line endings.  Writing
                            " it out via git-show will produce a file with LF line endings.
                            "
                            " If this last file is one of the files passed to git-diff, git-diff will
                            " convert its line endings to CRLF before diffing -- which is what we want --
                            " but also by default output a warning on stderr.
                            "
                            "   warning: LF will be replace by CRLF in <temp file>.
                            "   The file will have its original line endings in your working directory.
                            "
                            " When running the diff asynchronously, the warning message triggers the stderr
                            " callbacks which assume the overall command has failed and reset all the
                            " signs.  As this is not what we want, and we can safely ignore the warning,
                            " we turn it off by passing the '-c "core.safecrlf=false"' argument to
                            " git-diff.
                            "
                            " When writing the temporary files we preserve the original file's extension
                            " so that repos using .gitattributes to control EOL conversion continue to
                            " convert correctly.
                            "
                            " Arguments:
                            "
                            " bufnr              - the number of the buffer to be diffed
                            " from               - 'index' or 'working_tree'; what the buffer is diffed against
                            " preserve_full_diff - truthy to return the full diff or falsey to return only
                            "                      the hunk headers (@@ -x,y +m,n @@); only possible if
                            "                      grep is available.
    1              0.000001 function! gitgutter#diff#run_diff(bufnr, from, preserve_full_diff) abort
                              if gitgutter#utility#repo_path(a:bufnr, 0) == -1
                                throw 'gitgutter path not set'
                              endif
                            
                              if gitgutter#utility#repo_path(a:bufnr, 0) == -2
                                throw 'gitgutter not tracked'
                              endif
                            
                              if gitgutter#utility#repo_path(a:bufnr, 0) == -3
                                throw 'gitgutter assume unchanged'
                              endif
                            
                              " Wrap compound commands in parentheses to make Windows happy.
                              " bash doesn't mind the parentheses.
                              let cmd = '('
                            
                              " Append buffer number to temp filenames to avoid race conditions between
                              " writing and reading the files when asynchronously processing multiple
                              " buffers.
                            
                              " Without the buffer number, buff_file would have a race between the
                              " second gitgutter#process_buffer() writing the file (synchronously, below)
                              " and the first gitgutter#process_buffer()'s async job reading it (with
                              " git-diff).
                              let buff_file = s:temp_buffer.'.'.a:bufnr
                            
                              " Add a counter to avoid a similar race with two quick writes of the same buffer.
                              " Use a modulus greater than a maximum reasonable number of visible buffers.
                              let s:counter = (s:counter + 1) % 20
                              let buff_file .= '.'.s:counter
                            
                              let extension = gitgutter#utility#extension(a:bufnr)
                              if !empty(extension)
                                let buff_file .= '.'.extension
                              endif
                            
                              " Write buffer to temporary file.
                              " Note: this is synchronous.
                              call s:write_buffer(a:bufnr, buff_file)
                            
                              if a:from ==# 'index'
                                " Without the buffer number, from_file would have a race in the shell
                                " between the second process writing it (with git-show) and the first
                                " reading it (with git-diff).
                                let from_file = s:temp_from.'.'.a:bufnr
                            
                                " Add a counter to avoid a similar race with two quick writes of the same buffer.
                                let from_file .= '.'.s:counter
                            
                                if !empty(extension)
                                  let from_file .= '.'.extension
                                endif
                            
                                " Write file from index to temporary file.
                                let index_name = gitgutter#utility#get_diff_base(a:bufnr).':'.gitgutter#utility#base_path(a:bufnr)
                                let cmd .= gitgutter#git(a:bufnr).' --no-pager show --textconv '.index_name.' > '.from_file.' || exit 0) && ('
                            
                              elseif a:from ==# 'working_tree'
                                let from_file = gitgutter#utility#repo_path(a:bufnr, 1)
                              endif
                            
                              " Call git-diff.
                              let cmd .= gitgutter#git(a:bufnr).' --no-pager'
                              if gitgutter#utility#git_supports_command_line_config_override()
                                let cmd .= ' -c "diff.autorefreshindex=0"'
                                let cmd .= ' -c "diff.noprefix=false"'
                                let cmd .= ' -c "core.safecrlf=false"'
                              endif
                              let cmd .= ' diff --no-ext-diff --no-color -U0 '.g:gitgutter_diff_args.' -- '.from_file.' '.buff_file
                            
                              " Pipe git-diff output into grep.
                              if !a:preserve_full_diff && !empty(g:gitgutter_grep)
                                let cmd .= ' | '.g:gitgutter_grep.' '.gitgutter#utility#shellescape('^@@ ')
                              endif
                            
                              " grep exits with 1 when no matches are found; git-diff exits with 1 when
                              " differences are found.  However we want to treat non-matches and
                              " differences as non-erroneous behaviour; so we OR the command with one
                              " which always exits with success (0).
                              let cmd .= ' || exit 0'
                            
                              let cmd .= ')'
                            
                              if g:gitgutter_async && gitgutter#async#available()
                                call gitgutter#async#execute(cmd, a:bufnr, {
                                      \   'out': function('gitgutter#diff#handler'),
                                      \   'err': function('gitgutter#hunk#reset'),
                                      \ })
                                return 'async'
                            
                              else
                                let [diff, error_code] = gitgutter#utility#system(cmd)
                            
                                if error_code
                                  call gitgutter#debug#log(diff)
                                  throw 'gitgutter diff failed'
                                endif
                            
                                return diff
                              endif
                            endfunction
                            
                            
    1              0.000001 function! gitgutter#diff#handler(bufnr, diff) abort
                              call gitgutter#debug#log(a:diff)
                            
                              if !bufexists(a:bufnr)
                                return
                              endif
                            
                              call gitgutter#hunk#set_hunks(a:bufnr, gitgutter#diff#parse_diff(a:diff))
                              let modified_lines = gitgutter#diff#process_hunks(a:bufnr, gitgutter#hunk#hunks(a:bufnr))
                            
                              let signs_count = len(modified_lines)
                              if g:gitgutter_max_signs != -1 && signs_count > g:gitgutter_max_signs
                                call gitgutter#utility#warn_once(a:bufnr, printf(
                                      \ 'exceeded maximum number of signs (%d > %d, configured by g:gitgutter_max_signs).',
                                      \ signs_count, g:gitgutter_max_signs), 'max_signs')
                                call gitgutter#sign#clear_signs(a:bufnr)
                            
                              else
                                if g:gitgutter_signs || g:gitgutter_highlight_lines || g:gitgutter_highlight_linenrs
                                  call gitgutter#sign#update_signs(a:bufnr, modified_lines)
                                endif
                              endif
                            
                              call s:save_last_seen_change(a:bufnr)
                              if exists('#User#GitGutter')
                                let g:gitgutter_hook_context = {'bufnr': a:bufnr}
                                execute 'doautocmd' s:nomodeline 'User GitGutter'
                                unlet g:gitgutter_hook_context
                              endif
                            endfunction
                            
                            
    1              0.000001 function! gitgutter#diff#parse_diff(diff) abort
                              let hunks = []
                              for line in split(a:diff, '\n')
                                let hunk_info = gitgutter#diff#parse_hunk(line)
                                if len(hunk_info) == 4
                                  call add(hunks, hunk_info)
                                endif
                              endfor
                              return hunks
                            endfunction
                            
    1              0.000001 function! gitgutter#diff#parse_hunk(line) abort
                              let matches = matchlist(a:line, s:hunk_re)
                              if len(matches) > 0
                                let from_line  = str2nr(matches[1])
                                let from_count = (matches[2] == '') ? 1 : str2nr(matches[2])
                                let to_line    = str2nr(matches[3])
                                let to_count   = (matches[4] == '') ? 1 : str2nr(matches[4])
                                return [from_line, from_count, to_line, to_count]
                              else
                                return []
                              end
                            endfunction
                            
                            " This function is public so it may be used by other plugins
                            " e.g. vim-signature.
    1              0.000001 function! gitgutter#diff#process_hunks(bufnr, hunks) abort
                              let modified_lines = []
                              for hunk in a:hunks
                                call extend(modified_lines, s:process_hunk(a:bufnr, hunk))
                              endfor
                              return modified_lines
                            endfunction
                            
                            " Returns [ [<line_number (number)>, <name (string)>], ...]
    1              0.000001 function! s:process_hunk(bufnr, hunk) abort
                              let modifications = []
                              let from_line  = a:hunk[0]
                              let from_count = a:hunk[1]
                              let to_line    = a:hunk[2]
                              let to_count   = a:hunk[3]
                            
                              if s:is_added(from_count, to_count)
                                call s:process_added(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_added(a:bufnr, to_count)
                            
                              elseif s:is_removed(from_count, to_count)
                                call s:process_removed(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count)
                            
                              elseif s:is_modified(from_count, to_count)
                                call s:process_modified(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
                            
                              elseif s:is_modified_and_added(from_count, to_count)
                                call s:process_modified_and_added(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_added(a:bufnr, to_count - from_count)
                                call gitgutter#hunk#increment_lines_modified(a:bufnr, from_count)
                            
                              elseif s:is_modified_and_removed(from_count, to_count)
                                call s:process_modified_and_removed(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
                                call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count - to_count)
                            
                              endif
                              return modifications
                            endfunction
                            
    1              0.000001 function! s:is_added(from_count, to_count) abort
                              return a:from_count == 0 && a:to_count > 0
                            endfunction
                            
    1              0.000001 function! s:is_removed(from_count, to_count) abort
                              return a:from_count > 0 && a:to_count == 0
                            endfunction
                            
    1              0.000001 function! s:is_modified(from_count, to_count) abort
                              return a:from_count > 0 && a:to_count > 0 && a:from_count == a:to_count
                            endfunction
                            
    1              0.000001 function! s:is_modified_and_added(from_count, to_count) abort
                              return a:from_count > 0 && a:to_count > 0 && a:from_count < a:to_count
                            endfunction
                            
    1              0.000001 function! s:is_modified_and_removed(from_count, to_count) abort
                              return a:from_count > 0 && a:to_count > 0 && a:from_count > a:to_count
                            endfunction
                            
    1              0.000001 function! s:process_added(modifications, from_count, to_count, to_line) abort
                              let offset = 0
                              while offset < a:to_count
                                let line_number = a:to_line + offset
                                call add(a:modifications, [line_number, 'added'])
                                let offset += 1
                              endwhile
                            endfunction
                            
    1              0.000001 function! s:process_removed(modifications, from_count, to_count, to_line) abort
                              if a:to_line == 0
                                call add(a:modifications, [1, 'removed_first_line'])
                              else
                                call add(a:modifications, [a:to_line, 'removed'])
                              endif
                            endfunction
                            
    1              0.000001 function! s:process_modified(modifications, from_count, to_count, to_line) abort
                              let offset = 0
                              while offset < a:to_count
                                let line_number = a:to_line + offset
                                call add(a:modifications, [line_number, 'modified'])
                                let offset += 1
                              endwhile
                            endfunction
                            
    1              0.000001 function! s:process_modified_and_added(modifications, from_count, to_count, to_line) abort
                              let offset = 0
                              while offset < a:from_count
                                let line_number = a:to_line + offset
                                call add(a:modifications, [line_number, 'modified'])
                                let offset += 1
                              endwhile
                              while offset < a:to_count
                                let line_number = a:to_line + offset
                                call add(a:modifications, [line_number, 'added'])
                                let offset += 1
                              endwhile
                            endfunction
                            
    1              0.000001 function! s:process_modified_and_removed(modifications, from_count, to_count, to_line) abort
                              let offset = 0
                              while offset < a:to_count
                                let line_number = a:to_line + offset
                                call add(a:modifications, [line_number, 'modified'])
                                let offset += 1
                              endwhile
                              let a:modifications[-1] = [a:to_line + offset - 1, 'modified_removed']
                            endfunction
                            
                            
                            " Returns a diff for the current hunk.
                            " Assumes there is only 1 current hunk unless the optional argument is given,
                            " in which case the cursor is in two hunks and the argument specifies the one
                            " to choose.
                            "
                            " Optional argument: 0 (to use the first hunk) or 1 (to use the second).
    1              0.000001 function! gitgutter#diff#hunk_diff(bufnr, full_diff, ...)
                              let modified_diff = []
                              let hunk_index = 0
                              let keep_line = 1
                              " Don't keepempty when splitting because the diff we want may not be the
                              " final one.  Instead add trailing NL at end of function.
                              for line in split(a:full_diff, '\n')
                                let hunk_info = gitgutter#diff#parse_hunk(line)
                                if len(hunk_info) == 4  " start of new hunk
                                  let keep_line = gitgutter#hunk#cursor_in_hunk(hunk_info)
                            
                                  if a:0 && hunk_index != a:1
                                    let keep_line = 0
                                  endif
                            
                                  let hunk_index += 1
                                endif
                                if keep_line
                                  call add(modified_diff, line)
                                endif
                              endfor
                              return join(modified_diff, "\n")."\n"
                            endfunction
                            
                            
    1              0.000001 function! s:write_buffer(bufnr, file)
                              let bufcontents = getbufline(a:bufnr, 1, '$')
                            
                              if bufcontents == [''] && line2byte(1) == -1
                                " Special case: completely empty buffer.
                                " A nearly empty buffer of only a newline has line2byte(1) == 1.
                                call writefile([], a:file)
                                return
                              endif
                            
                              if getbufvar(a:bufnr, '&fileformat') ==# 'dos'
                                if getbufvar(a:bufnr, '&endofline')
                                  call map(bufcontents, 'v:val."\r"')
                                else
                                  for i in range(len(bufcontents) - 1)
                                    let bufcontents[i] = bufcontents[i] . "\r"
                                  endfor
                                endif
                              endif
                            
                              if getbufvar(a:bufnr, '&endofline')
                                call add(bufcontents, '')
                              endif
                            
                              let fenc = getbufvar(a:bufnr, '&fileencoding')
                              if fenc !=# &encoding
                                call map(bufcontents, 'iconv(v:val, &encoding, "'.fenc.'")')
                              endif
                            
                              if getbufvar(a:bufnr, '&bomb')
                                let bufcontents[0]='﻿'.bufcontents[0]
                              endif
                            
                              " The file we are writing to is a temporary file.  Sometimes the parent
                              " directory is deleted outside Vim but, because Vim caches the directory
                              " name at startup and does not check for its existence subsequently, Vim
                              " does not realise.  This causes E482 errors.
                              try
                                call writefile(bufcontents, a:file, 'b')
                              catch /E482/
                                call mkdir(fnamemodify(a:file, ':h'), '', '0700')
                                call writefile(bufcontents, a:file, 'b')
                              endtry
                            endfunction
                            
                            
    1              0.000001 function! s:save_last_seen_change(bufnr) abort
                              call gitgutter#utility#setbufvar(a:bufnr, 'tick', getbufvar(a:bufnr, 'changedtick'))
                            endfunction

FUNCTION  <SNR>98_callback_nvim_stdout()
    Defined: ~/.local/share/nvim/lazy/vim-signify/autoload/sy/repo.vim:16
Called 7 times
Total time:   0.000099
 Self time:   0.000099

count  total (s)   self (s)
    7              0.000033   let self.stdoutbuf[-1] .= a:data[0]
    7              0.000058   call extend(self.stdoutbuf, a:data[1:])

FUNCTION  gitgutter#all()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter.vim:3
Called 7 times
Total time:   0.006486
 Self time:   0.000909

count  total (s)   self (s)
    7              0.000021   let visible = tabpagebuflist()
                            
  110              0.000079   for bufnr in range(1, bufnr('$') + 1)
  103              0.000078     if buflisted(bufnr)
   16              0.000103       let file = expand('#'.bufnr.':p')
   16              0.000014       if !empty(file)
   14              0.000016         if index(visible, bufnr) != -1
    2   0.005515   0.000017           call gitgutter#process_buffer(bufnr, a:force)
   12              0.000019         elseif a:force
    5   0.000103   0.000022           call s:reset_tick(bufnr)
   14              0.000004         endif
   16              0.000003       endif
  103              0.000021     endif
  110              0.000084   endfor

FUNCTION  sy#set_buflocal_autocmds()
    Defined: ~/.local/share/nvim/lazy/vim-signify/autoload/sy.vim:132
Called 2 times
Total time:   0.000098
 Self time:   0.000098

count  total (s)   self (s)
    2              0.000002   augroup signify
    2              0.000025     execute printf('autocmd! * <buffer=%d>', a:bufnr)
                            
    2              0.000006     execute printf('autocmd BufEnter     <buffer=%d> call sy#start()', a:bufnr)
    2              0.000006     execute printf('autocmd WinEnter     <buffer=%d> call sy#start()', a:bufnr)
    2              0.000004     execute printf('autocmd BufWritePost <buffer=%d> call sy#start()', a:bufnr)
                            
    2              0.000005     execute printf('autocmd CursorHold   <buffer=%d> call sy#start()', a:bufnr)
    2              0.000004     execute printf('autocmd CursorHoldI  <buffer=%d> call sy#start()', a:bufnr)
                            
    2              0.000005     execute printf('autocmd FocusGained  <buffer=%d> SignifyRefresh', a:bufnr)
                            
    2              0.000006     execute printf('autocmd CmdwinEnter <buffer=%d> let g:signify_cmdwin_active = 1', a:bufnr)
    2              0.000006     execute printf('autocmd CmdwinLeave <buffer=%d> let g:signify_cmdwin_active = 0', a:bufnr)
                            
    2              0.000006     execute printf('autocmd ShellCmdPost <buffer=%d> call sy#start()', a:bufnr)
                            
    2              0.000002     if exists('##VimResume')
    2              0.000012       execute printf('autocmd VimResume <buffer=%d> call sy#start()', a:bufnr)
    2              0.000001     endif
    2              0.000001   augroup END
                            
    2              0.000003   if exists('#User#SignifyAutocmds')
                                doautocmd <nomodeline> User SignifyAutocmds
    2              0.000000   endif

FUNCTION  <SNR>82_Attach()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:419
Called 2 times
Total time:   0.003416
 Self time:   0.000021

count  total (s)   self (s)
    2              0.000001   try
    2   0.003407   0.000012     return copilot#Client().Attach(a:bufnr)
                              catch
                                call copilot#logger#Exception()
    2              0.000002   endtry

FUNCTION  sy#util#numhl()
    Defined: ~/.local/share/nvim/lazy/vim-signify/autoload/sy/util.vim:209
Called 20 times
Total time:   0.000082
 Self time:   0.000082

count  total (s)   self (s)
   20              0.000013   if !s:use_numhl
                                return ''
   20              0.000004   endif
                            
   20              0.000019   if get(g:, 'signify_number_highlight')
                                return printf('numhl=%s', a:hlgroup)
   20              0.000004   else
   20              0.000008     return 'numhl='
                              endif

FUNCTION  <SNR>105_write_buffer()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/diff.vim:369
Called 3 times
Total time:   0.000204
 Self time:   0.000204

count  total (s)   self (s)
    3              0.000032   let bufcontents = getbufline(a:bufnr, 1, '$')
                            
    3              0.000016   if bufcontents == [''] && line2byte(1) == -1
                                " Special case: completely empty buffer.
                                " A nearly empty buffer of only a newline has line2byte(1) == 1.
                                call writefile([], a:file)
                                return
    3              0.000001   endif
                            
    3              0.000007   if getbufvar(a:bufnr, '&fileformat') ==# 'dos'
                                if getbufvar(a:bufnr, '&endofline')
                                  call map(bufcontents, 'v:val."\r"')
                                else
                                  for i in range(len(bufcontents) - 1)
                                    let bufcontents[i] = bufcontents[i] . "\r"
                                  endfor
                                endif
    3              0.000001   endif
                            
    3              0.000005   if getbufvar(a:bufnr, '&endofline')
    3              0.000005     call add(bufcontents, '')
    3              0.000001   endif
                            
    3              0.000005   let fenc = getbufvar(a:bufnr, '&fileencoding')
    3              0.000003   if fenc !=# &encoding
                                call map(bufcontents, 'iconv(v:val, &encoding, "'.fenc.'")')
    3              0.000001   endif
                            
    3              0.000004   if getbufvar(a:bufnr, '&bomb')
                                let bufcontents[0]='﻿'.bufcontents[0]
    3              0.000001   endif
                            
                              " The file we are writing to is a temporary file.  Sometimes the parent
                              " directory is deleted outside Vim but, because Vim caches the directory
                              " name at startup and does not check for its existence subsequently, Vim
                              " does not realise.  This causes E482 errors.
    3              0.000001   try
    3              0.000072     call writefile(bufcontents, a:file, 'b')
                              catch /E482/
                                call mkdir(fnamemodify(a:file, ':h'), '', '0700')
                                call writefile(bufcontents, a:file, 'b')
    3              0.000002   endtry

FUNCTION  1()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/utility.vim:133
Called 2 times
Total time:   0.025218
 Self time:   0.000058

count  total (s)   self (s)
    2   0.000021   0.000009   let listing = s:strip_trailing_new_line(a:listing)
    2              0.000004   let [status, path] = [listing[0], listing[2:]]
    2              0.000004   if status =~# '[a-z]'
                                call gitgutter#utility#setbufvar(a:buffer, 'path', -3)
    2              0.000001   else
    2   0.000027   0.000009     call gitgutter#utility#setbufvar(a:buffer, 'path', path)
    2              0.000001   endif
                            
    2              0.000005   if type(self.continuation) == type(function('tr'))
    2   0.025145   0.000015     call self.continuation()
                              else
                                call call(self.continuation.function, self.continuation.arguments)
    2              0.000000   endif

FUNCTION  sy#sign#id_next()
    Defined: ~/.local/share/nvim/lazy/vim-signify/autoload/sy/sign.vim:20
Called 39 times
Total time:   0.000069
 Self time:   0.000069

count  total (s)   self (s)
   39              0.000025   let id = a:sy.signid
   39              0.000021   let a:sy.signid += 1
   39              0.000014   return id

FUNCTION  <SNR>105_process_modified()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/diff.vim:304
Called 2 times
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    2              0.000001   let offset = 0
    6              0.000003   while offset < a:to_count
    4              0.000003     let line_number = a:to_line + offset
    4              0.000005     call add(a:modifications, [line_number, 'modified'])
    4              0.000002     let offset += 1
    6              0.000002   endwhile

FUNCTION  <SNR>90_reset_summary()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/hunk.vim:24
Called 4 times
Total time:   0.000053
 Self time:   0.000022

count  total (s)   self (s)
    4   0.000052   0.000021   call gitgutter#utility#setbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  <SNR>29_setup_styledEmmetAbbreviation()
    Defined: ~/.local/share/nvim/lazy/emmet-vim/plugin/emmet.vim:178
Called 4 times
Total time:   0.000044
 Self time:   0.000044

count  total (s)   self (s)
    4              0.000016   if index(['javascript', 'javascriptreact', 'typescript', 'typescriptreact'], &filetype) != -1
                                syntax match styledEmmetAbbreviation "[a-z0-9#+!%]\+" containedin=styledDefinition contained
    4              0.000002   endif

FUNCTION  sy#util#refresh_windows()
    Defined: ~/.local/share/nvim/lazy/vim-signify/autoload/sy/util.vim:26
Called 1 time
Total time:   0.002857
 Self time:   0.000036

count  total (s)   self (s)
    1              0.000002   if exists('*win_getid')
    1              0.000001     let winid = win_getid()
                              else
                                let winnr = winnr()
    1              0.000000   endif
                            
    1              0.000002   if !get(g:, 'signify_cmdwin_active')
    2              0.000003     for bufnr in tabpagebuflist()
    1   0.000010   0.000004       if sy#buffer_is_active(bufnr)
    1   0.002824   0.000010         call sy#start({'bufnr': bufnr})
    1              0.000001       endif
    2              0.000001     endfor
    1              0.000000   endif
                            
    1              0.000001   if exists('winid')
    1              0.000002     call win_gotoid(winid)
                              else
                                execute winnr .'wincmd w'
    1              0.000000   endif

FUNCTION  <SNR>105_process_added()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/diff.vim:287
Called 3 times
Total time:   0.000054
 Self time:   0.000054

count  total (s)   self (s)
    3              0.000002   let offset = 0
   15              0.000009   while offset < a:to_count
   12              0.000009     let line_number = a:to_line + offset
   12              0.000015     call add(a:modifications, [line_number, 'added'])
   12              0.000007     let offset += 1
   15              0.000004   endwhile

FUNCTION  sy#util#get_signs()
    Defined: ~/.local/share/nvim/lazy/vim-signify/autoload/sy/util.vim:237
Called 5 times
Total time:   0.000048
 Self time:   0.000048

count  total (s)   self (s)
    5              0.000046     return sign_getplaced(a:bufnr)[0].signs

FUNCTION  sy#util#escape()
    Defined: ~/.local/share/nvim/lazy/vim-signify/autoload/sy/util.vim:6
Called 5 times
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
    5              0.000006   if exists('+shellslash')
                                let old_ssl = &shellslash
                                if fnamemodify(&shell, ':t') == 'cmd.exe'
                                  set noshellslash
                                else
                                  set shellslash
                                endif
    5              0.000001   endif
                            
    5              0.000008   let path = shellescape(a:path)
                            
    5              0.000004   if exists('old_ssl')
                                let &shellslash = old_ssl
    5              0.000001   endif
                            
    5              0.000002   return path

FUNCTION  sy#highlight#setup()
    Defined: ~/.local/share/nvim/lazy/vim-signify/autoload/sy/highlight.vim:18
Called 1 time
Total time:   0.000054
 Self time:   0.000054

count  total (s)   self (s)
    1              0.000003   highlight default link SignifyLineAdd             DiffAdd
    1              0.000002   highlight default link SignifyLineDelete          DiffDelete
    1              0.000001   highlight default link SignifyLineDeleteFirstLine SignifyLineDelete
    1              0.000001   highlight default link SignifyLineChange          DiffChange
    1              0.000001   highlight default link SignifyLineChangeDelete    SignifyLineChange
                            
    1              0.000001   highlight default link SignifySignAdd             DiffAdd
    1              0.000001   highlight default link SignifySignDelete          DiffDelete
    1              0.000001   highlight default link SignifySignDeleteFirstLine SignifySignDelete
    1              0.000001   highlight default link SignifySignChange          DiffChange
    1              0.000043   highlight default link SignifySignChangeDelete    SignifySignChange

FUNCTION  gitgutter#utility#shellescape()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/utility.vim:82
Called 25 times
Total time:   0.000312
 Self time:   0.000275

count  total (s)   self (s)
   25              0.000179   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
   15              0.000009     return a:arg
   10   0.000069   0.000032   elseif s:winshell()
                                return '"' . substitute(substitute(a:arg, '"', '""', 'g'), '%', '"%"', 'g') . '"'
   10              0.000003   else
   10              0.000019     return shellescape(a:arg)
                              endif

FUNCTION  gitgutter#utility#system()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/utility.vim:101
Called 3 times
Total time:   0.018743
 Self time:   0.000155

count  total (s)   self (s)
    3   0.000061   0.000012   call gitgutter#debug#log(a:cmd, a:000)
                            
    3   0.000482   0.000009   call s:use_known_shell()
    3              0.000003   let prev_error_code = v:shell_error
    3   0.010019   0.000032   silent let output = (a:0 == 0) ? system(a:cmd) : system(a:cmd, a:1)
    3              0.000008   let error_code = v:shell_error
    3   0.007420   0.000029   silent call system('exit ' . prev_error_code)
    3   0.000732   0.000043   call s:restore_shell()
                            
    3              0.000007   return [output, error_code]

FUNCTION  <SNR>98_wrap_cmd()
    Defined: ~/.local/share/nvim/lazy/vim-signify/autoload/sy/repo.vim:476
Called 5 times
Total time:   0.000078
 Self time:   0.000078

count  total (s)   self (s)
    5              0.000008   if has('win32')
                                if has('nvim')
                                  let cmd = &shell =~ '\v%(cmd|powershell|pwsh)' ? a:cmd : ['sh', '-c', a:cmd]
                                else
                                  if &shell =~ 'cmd'
                                    let cmd = join([&shell, &shellcmdflag, '(', a:cmd, ')'])
                                  elseif empty(&shellxquote)
                                    let cmd = join([&shell, &shellcmdflag, &shellquote, a:cmd, &shellquote])
                                  else
                                    let cmd = join([&shell, &shellcmdflag, &shellxquote, a:cmd, &shellxquote])
                                  endif
                                endif
    5              0.000001   else
    5              0.000005     let cmd = ['sh', '-c', a:cmd]
    5              0.000001   endif
    5              0.000012   let options = { 'stdoutbuf': [''], 'vcs': a:vcs, 'bufnr': a:bufnr, }
    5              0.000004   return [cmd, options]

FUNCTION  <SNR>96_get_path()
    Defined: ~/.local/share/nvim/lazy/vim-signify/autoload/sy.vim:161
Called 8 times
Total time:   0.000177
 Self time:   0.000177

count  total (s)   self (s)
    8              0.000139   let path = resolve(fnamemodify(bufname(a:bufnr), ':p'))
    8              0.000014   if has('win32')
                                let path = substitute(path, '\v^(\w):\\\\', '\1:\\', '')
    8              0.000002   endif
    8              0.000006   return path

FUNCTION  <SNR>99_on_exit_nvim()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/async.vim:72
Called 5 times
Total time:   0.027185
 Self time:   0.000234

count  total (s)   self (s)
    5              0.000010   if !a:exit_code
    5   0.027166   0.000215     call self.handler.out(self.buffer, join(self.stdoutbuffer, "\n"))
    5              0.000001   endif

FUNCTION  gitgutter#sign#clear_signs()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/sign.vim:38
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000002   if exists('*sign_unplace')
    1              0.000003     call sign_unplace('gitgutter', {'buffer': a:bufnr})
    1              0.000001     return
                              endif
                            
                            
                              call s:find_current_signs(a:bufnr)
                            
                              let sign_ids = map(values(gitgutter#utility#getbufvar(a:bufnr, 'gitgutter_signs')), 'v:val.id')
                              call s:remove_signs(a:bufnr, sign_ids, 1)
                              call gitgutter#utility#setbufvar(a:bufnr, 'gitgutter_signs', {})

FUNCTION  sy#sign#set_signs()
    Defined: ~/.local/share/nvim/lazy/vim-signify/autoload/sy/sign.vim:230
Called 5 times
Total time:   0.004345
 Self time:   0.000231

count  total (s)   self (s)
    5   0.000049   0.000017   call sy#verbose('sy#sign#set_signs()', a:vcs)
                            
    5              0.000008   if a:sy.stats == [-1, -1, -1]
    2              0.000004     let a:sy.stats = [0, 0, 0]
    5              0.000001   endif
                            
    5              0.000004   if empty(a:diff)
                                call sy#verbose('No changes found.', a:vcs)
                                let a:sy.stats = [0, 0, 0]
                                call sy#sign#remove_all_signs(a:sy.buffer)
                                return
    5              0.000001   endif
                            
    5              0.000007   if get(g:, 'signify_line_highlight')
                                call sy#highlight#line_enable()
    5              0.000001   else
    5   0.000439   0.000118     call sy#highlight#line_disable()
    5              0.000001   endif
                            
    5   0.003780   0.000019   call sy#sign#process_diff(a:sy, a:vcs, a:diff)
                            
    5              0.000011   if exists('#User#Signify')
                                doautocmd <nomodeline> User Signify
    5              0.000001   endif

FUNCTION  <SNR>60_Remove_Matches()
    Defined: /usr/share/nvim/runtime/plugin/matchparen.vim:206
Called 23 times
Total time:   0.000131
 Self time:   0.000131

count  total (s)   self (s)
   23              0.000037   if exists('w:paren_hl_on') && w:paren_hl_on
                                while !empty(w:matchparen_ids)
                                  silent! call remove(w:matchparen_ids, 0)->matchdelete()
                                endwhile
                                let w:paren_hl_on = 0
   23              0.000006   endif

FUNCTION  gitgutter#async#available()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/async.vim:11
Called 5 times
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    5              0.000004   return s:available

FUNCTION  <SNR>60_Highlight_Matching_Pair()
    Defined: /usr/share/nvim/runtime/plugin/matchparen.vim:44
Called 11 times
Total time:   0.000442
 Self time:   0.000388

count  total (s)   self (s)
   11              0.000022   if !exists("w:matchparen_ids")
    1              0.000001     let w:matchparen_ids = []
   11              0.000003   endif
                              " Remove any previous match.
   11   0.000140   0.000086   call s:Remove_Matches()
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
   11              0.000021   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
   11              0.000002   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
   11              0.000013   let c_lnum = line('.')
   11              0.000011   let c_col = col('.')
   11              0.000006   let before = 0
                            
   11              0.000014   let text = getline(c_lnum)
   11              0.000026   let c_before = text->strpart(0, c_col - 1)->slice(-1)
   11              0.000019   let c = text->strpart(c_col - 1)->slice(0, 1)
   11              0.000052   let plist = split(&matchpairs, '.\zs[:,]')
   11              0.000014   let i = index(plist, c)
   11              0.000005   if i < 0
                                " not found, in Insert mode try character before the cursor
   11              0.000015     if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
   11              0.000003     endif
   11              0.000005     if i < 0
                                  " not found, nothing to do
   11              0.000004       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
                              elseif exists("b:ts_highlight") && &syntax != 'on'
                                let s_skip = "match(v:lua.vim.treesitter.get_captures_at_cursor(), '" .. 'string\|character\|singlequote\|escape\|symbol\|comment' .. "') != -1"
                              else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial, and
                                " match "symbol" for lispBarSymbol.
                                let s_skip = 'synstack(".", col("."))' . '->indexof({_, id -> synIDattr(id, "name") =~? ' . '"string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
                                try
                                  execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
                                endtry
                              endif
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if s:has_matchaddpos
                                  call add(w:matchparen_ids, matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10))
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                  call add(w:matchparen_ids, 3)
                                endif
                                let w:paren_hl_on = 1
                              endif

FUNCTION  gitgutter#diff#parse_hunk()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/diff.vim:210
Called 7 times
Total time:   0.000094
 Self time:   0.000094

count  total (s)   self (s)
    7              0.000041   let matches = matchlist(a:line, s:hunk_re)
    7              0.000005   if len(matches) > 0
    7              0.000008     let from_line  = str2nr(matches[1])
    7              0.000010     let from_count = (matches[2] == '') ? 1 : str2nr(matches[2])
    7              0.000008     let to_line    = str2nr(matches[3])
    7              0.000009     let to_count   = (matches[4] == '') ? 1 : str2nr(matches[4])
    7              0.000009     return [from_line, from_count, to_line, to_count]
                              else
                                return []
                              end

FUNCTION  <SNR>98_handle_diff()
    Defined: ~/.local/share/nvim/lazy/vim-signify/autoload/sy/repo.vim:117
Called 5 times
Total time:   0.004902
 Self time:   0.000396

count  total (s)   self (s)
    5   0.000073   0.000025   call sy#verbose('s:handle_diff()', a:options.vcs)
                            
    5              0.000008   if has_key(a:options, 'tempfiles')
                                for f in a:options.tempfiles
                                  call delete(f)
                                endfor
    5              0.000001   endif
                            
    5              0.000011   let sy = getbufvar(a:options.bufnr, 'sy')
    5              0.000004   if empty(sy)
                                call sy#verbose(printf('No b:sy found for %s', bufname(a:options.bufnr)), a:options.vcs)
                                return
    5              0.000009   elseif !empty(sy.updated_by) && sy.updated_by != a:options.vcs
                                call sy#verbose(printf('Signs already got updated by %s.', sy.updated_by), a:options.vcs)
                                return
    5              0.000005   elseif empty(sy.vcs)
    2              0.000004     let g:signify_detecting -= 1
    2              0.000002     let sy.detecting -= 1
    5              0.000001   endif
                            
    5              0.000011   let fenc = getbufvar(a:options.bufnr, '&fenc')
    5              0.000009   let enc  = getbufvar(a:options.bufnr, '&enc')
    5              0.000007   if (fenc != enc) && has('iconv')
                                call map(a:options.stdoutbuf, printf('iconv(v:val, "%s", "%s")', fenc, enc))
    5              0.000001   endif
                            
    5   0.000044   0.000029   let [found_diff, diff] = s:check_diff_{a:options.difftool}(a:exitval, a:options.stdoutbuf)
    5              0.000003   if found_diff
    5              0.000008     if index(sy.vcs, a:options.vcs) == -1
    2              0.000003       let sy.vcs += [a:options.vcs]
    5              0.000001     endif
    5   0.004611   0.000168     call a:options.func(sy, a:options.vcs, diff)
                              else
                                call sy#verbose('No valid diff found. Disabling this VCS.', a:options.vcs)
    5              0.000001   endif
                            
    5              0.000011   call setbufvar(a:options.bufnr, 'sy_job_id_'.a:options.vcs, 0)

FUNCTION  gitgutter#diff#handler()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/diff.vim:167
Called 3 times
Total time:   0.001733
 Self time:   0.000164

count  total (s)   self (s)
    3   0.000088   0.000016   call gitgutter#debug#log(a:diff)
                            
    3              0.000004   if !bufexists(a:bufnr)
                                return
    3              0.000001   endif
                            
    3   0.000307   0.000023   call gitgutter#hunk#set_hunks(a:bufnr, gitgutter#diff#parse_diff(a:diff))
    3   0.000690   0.000021   let modified_lines = gitgutter#diff#process_hunks(a:bufnr, gitgutter#hunk#hunks(a:bufnr))
                            
    3              0.000005   let signs_count = len(modified_lines)
    3              0.000004   if g:gitgutter_max_signs != -1 && signs_count > g:gitgutter_max_signs
                                call gitgutter#utility#warn_once(a:bufnr, printf( 'exceeded maximum number of signs (%d > %d, configured by g:gitgutter_max_signs).', signs_count, g:gitgutter_max_signs), 'max_signs')
                                call gitgutter#sign#clear_signs(a:bufnr)
                            
    3              0.000001   else
    3              0.000004     if g:gitgutter_signs || g:gitgutter_highlight_lines || g:gitgutter_highlight_linenrs
    3   0.000526   0.000027       call gitgutter#sign#update_signs(a:bufnr, modified_lines)
    3              0.000001     endif
    3              0.000001   endif
                            
    3   0.000061   0.000017   call s:save_last_seen_change(a:bufnr)
    3              0.000007   if exists('#User#GitGutter')
                                let g:gitgutter_hook_context = {'bufnr': a:bufnr}
                                execute 'doautocmd' s:nomodeline 'User GitGutter'
                                unlet g:gitgutter_hook_context
    3              0.000001   endif

FUNCTION  sy#buffer_is_active()
    Defined: ~/.local/share/nvim/lazy/vim-signify/autoload/sy.vim:113
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000002   let bufnr = a:0 ? a:1 : bufnr('')
    1              0.000003   return !empty(getbufvar(bufnr, 'sy'))

FUNCTION  <SNR>82_BufferDisabled()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:121
Called 3 times
Total time:   0.000063
 Self time:   0.000063

count  total (s)   self (s)
    3              0.000016   if &buftype =~# '^\%(help\|prompt\|quickfix\|terminal\)$'
    1              0.000001     return 5
    2              0.000001   endif
    2              0.000002   if exists('b:copilot_disabled')
                                return empty(b:copilot_disabled) ? 0 : 3
    2              0.000001   endif
    2              0.000002   if exists('b:copilot_enabled')
                                return empty(b:copilot_enabled) ? 4 : 0
    2              0.000000   endif
    2              0.000007   let short = empty(&l:filetype) ? '.' : split(&l:filetype, '\.', 1)[0]
    2              0.000002   let config = {}
    2              0.000005   if type(get(g:, 'copilot_filetypes')) == v:t_dict
                                let config = g:copilot_filetypes
    2              0.000000   endif
    2              0.000002   if has_key(config, &l:filetype)
                                return empty(config[&l:filetype])
    2              0.000002   elseif has_key(config, short)
                                return empty(config[short])
    2              0.000002   elseif has_key(config, '*')
                                return empty(config['*'])
    2              0.000000   else
    2              0.000003     return get(s:filetype_defaults, short, 1) == 0 ? 2 : 0
                              endif

FUNCTION  <SNR>103_external_sign_present()
    Defined: ~/.local/share/nvim/lazy/vim-signify/autoload/sy/sign.vim:295
Called 78 times
Total time:   0.000130
 Self time:   0.000130

count  total (s)   self (s)
                              " If sign priority is supported, so are multiple signs per line.
                              " Therefore, we can report no external signs present and let
                              " g:signify_priority control whether Sy's signs are shown.
   78              0.000062   if !empty(s:sign_priority)
   78              0.000020     return
                              endif
                              if has_key(a:sy.external, a:line)
                                if has_key(a:sy.internal, a:line)
                                  " Remove Sy signs from lines with other signs.
                                  execute 'sign unplace' a:sy.internal[a:line].id 'buffer='.a:sy.buffer
                                endif
                                return 1
                              endif

FUNCTION  copilot#Client()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:48
Called 15 times
Total time:   0.000117
 Self time:   0.000040

count  total (s)   self (s)
   15   0.000107   0.000030   call s:Start()
   15              0.000007   return s:client

FUNCTION  <SNR>34_use_known_shell()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/utility.vim:205
Called 3 times
Total time:   0.000473
 Self time:   0.000060

count  total (s)   self (s)
    3              0.000005   if has('unix') && &shell !=# 'sh'
    3              0.000013     let [s:shell, s:shellcmdflag, s:shellredir, s:shellpipe, s:shellquote, s:shellxquote] = [&shell, &shellcmdflag, &shellredir, &shellpipe, &shellquote, &shellxquote]
    3   0.000140   0.000012     let &shell = 'sh'
    3   0.000296   0.000012     set shellcmdflag=-c shellredir=>%s\ 2>&1
    3              0.000001   endif
    3              0.000007   if has('win32') && (&shell =~# 'pwsh' || &shell =~# 'powershell')
                                let [s:shell, s:shellcmdflag, s:shellredir, s:shellpipe, s:shellquote, s:shellxquote] = [&shell, &shellcmdflag, &shellredir, &shellpipe, &shellquote, &shellxquote]
                                let &shell = 'cmd.exe'
                                set shellcmdflag=/s\ /c shellredir=>%s\ 2>&1 shellpipe=>%s\ 2>&1 shellquote= shellxquote="
    3              0.000001   endif

FUNCTION  gitgutter#setup_maps()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter.vim:135
Called 7 times
Total time:   0.000660
 Self time:   0.000581

count  total (s)   self (s)
    7              0.000008   if !g:gitgutter_map_keys
                                return
    7              0.000002   endif
                            
                              " Note hasmapto() and maparg() operate on the current buffer.
                            
    7              0.000010   let bufnr = bufnr('')
                            
    7   0.000082   0.000030   if gitgutter#utility#getbufvar(bufnr, 'mapped', 0)
    4              0.000001     return
    3              0.000001   endif
                            
    3              0.000077   if !hasmapto('<Plug>(GitGutterPrevHunk)') && maparg('[c', 'n') ==# ''
                                nmap <buffer> [c <Plug>(GitGutterPrevHunk)
    3              0.000001   endif
    3              0.000046   if !hasmapto('<Plug>(GitGutterNextHunk)') && maparg(']c', 'n') ==# ''
                                nmap <buffer> ]c <Plug>(GitGutterNextHunk)
    3              0.000001   endif
                            
    3              0.000039   if !hasmapto('<Plug>(GitGutterStageHunk)', 'v') && maparg('<Leader>hs', 'x') ==# ''
    3              0.000010     xmap <buffer> <Leader>hs <Plug>(GitGutterStageHunk)
    3              0.000001   endif
    3              0.000047   if !hasmapto('<Plug>(GitGutterStageHunk)', 'n') && maparg('<Leader>hs', 'n') ==# ''
    3              0.000006     nmap <buffer> <Leader>hs <Plug>(GitGutterStageHunk)
    3              0.000001   endif
    3              0.000045   if !hasmapto('<Plug>(GitGutterUndoHunk)') && maparg('<Leader>hu', 'n') ==# ''
    3              0.000006     nmap <buffer> <Leader>hu <Plug>(GitGutterUndoHunk)
    3              0.000001   endif
    3              0.000041   if !hasmapto('<Plug>(GitGutterPreviewHunk)') && maparg('<Leader>hp', 'n') ==# ''
    3              0.000007     nmap <buffer> <Leader>hp <Plug>(GitGutterPreviewHunk)
    3              0.000001   endif
                            
    3              0.000040   if !hasmapto('<Plug>(GitGutterTextObjectInnerPending)') && maparg('ic', 'o') ==# ''
    3              0.000006     omap <buffer> ic <Plug>(GitGutterTextObjectInnerPending)
    3              0.000001   endif
    3              0.000033   if !hasmapto('<Plug>(GitGutterTextObjectOuterPending)') && maparg('ac', 'o') ==# ''
    3              0.000005     omap <buffer> ac <Plug>(GitGutterTextObjectOuterPending)
    3              0.000001   endif
    3              0.000036   if !hasmapto('<Plug>(GitGutterTextObjectInnerVisual)') && maparg('ic', 'x') ==# ''
    3              0.000005     xmap <buffer> ic <Plug>(GitGutterTextObjectInnerVisual)
    3              0.000001   endif
    3              0.000032   if !hasmapto('<Plug>(GitGutterTextObjectOuterVisual)') && maparg('ac', 'x') ==# ''
    3              0.000004     xmap <buffer> ac <Plug>(GitGutterTextObjectOuterVisual)
    3              0.000001   endif
                            
    3   0.000038   0.000012   call gitgutter#utility#setbufvar(bufnr, 'mapped', 1)

FUNCTION  gitgutter#diff#parse_diff()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/diff.vim:199
Called 3 times
Total time:   0.000173
 Self time:   0.000078

count  total (s)   self (s)
    3              0.000004   let hunks = []
   10              0.000020   for line in split(a:diff, '\n')
    7   0.000118   0.000024     let hunk_info = gitgutter#diff#parse_hunk(line)
    7              0.000005     if len(hunk_info) == 4
    7              0.000005       call add(hunks, hunk_info)
    7              0.000001     endif
   10              0.000004   endfor
    3              0.000002   return hunks

FUNCTION  sy#highlight#line_disable()
    Defined: ~/.local/share/nvim/lazy/vim-signify/autoload/sy/highlight.vim:42
Called 5 times
Total time:   0.000225
 Self time:   0.000142

count  total (s)   self (s)
    5   0.000076   0.000050   execute 'sign define SignifyAdd text='. s:sign_add ' texthl=SignifySignAdd linehl= '. sy#util#numhl('SignifySignAdd')
    5   0.000046   0.000027   execute 'sign define SignifyChange text='. s:sign_change ' texthl=SignifySignChange linehl= '. sy#util#numhl('SignifySignChange')
    5   0.000044   0.000026   execute 'sign define SignifyChangeDelete text='. s:sign_change_delete ' texthl=SignifySignChangeDelete linehl= '. sy#util#numhl('SignifySignChangeDelete')
    5   0.000045   0.000026   execute 'sign define SignifyRemoveFirstLine text='. s:sign_delete_first_line ' texthl=SignifySignDeleteFirstLine linehl= '. sy#util#numhl('SignifySignDeleteFirstLine')
    5              0.000005   let g:signify_line_highlight = 0

FUNCTION  <SNR>82_Start()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:34
Called 15 times
Total time:   0.000077
 Self time:   0.000048

count  total (s)   self (s)
   15   0.000068   0.000039   if s:Running() || exists('s:client.startup_error')
   15              0.000005     return
                              endif
                              let s:client = copilot#client#New()

FUNCTION  gitgutter#sign#update_signs()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/sign.vim:57
Called 3 times
Total time:   0.000499
 Self time:   0.000375

count  total (s)   self (s)
    3              0.000013   if exists('*sign_unplace')
                                " Vim is (hopefully) now quick enough to remove all signs then place new ones.
    3              0.000009     call sign_unplace('gitgutter', {'buffer': a:bufnr})
                            
    3   0.000035   0.000014     let modified_lines = s:handle_double_hunk(a:modified_lines)
    3   0.000387   0.000283     let signs = map(copy(modified_lines), '{'. '"buffer":   a:bufnr,'. '"group":    "gitgutter",'. '"name":     s:highlight_name_for_change(v:val[1]),'. '"lnum":     v:val[0],'. '"priority": g:gitgutter_sign_priority'. '}')
                            
    3              0.000005     if exists('*sign_placelist')
    3              0.000040       call sign_placelist(signs)
    3              0.000002       return
                                endif
                            
                                for sign in signs
                                  call sign_place(0, sign.group, sign.name, sign.buffer, {'lnum': sign.lnum, 'priority': sign.priority})
                                endfor
                                return
                              endif
                            
                            
                              " Derive a delta between the current signs and the ones we want.
                              " Remove signs from lines that no longer need a sign.
                              " Upsert the remaining signs.
                            
                              call s:find_current_signs(a:bufnr)
                            
                              let new_gitgutter_signs_line_numbers = map(copy(a:modified_lines), 'v:val[0]')
                              let obsolete_signs = s:obsolete_gitgutter_signs_to_remove(a:bufnr, new_gitgutter_signs_line_numbers)
                            
                              call s:remove_signs(a:bufnr, obsolete_signs, s:remove_all_old_signs)
                              call s:upsert_new_gitgutter_signs(a:bufnr, a:modified_lines)

FUNCTION  sy#sign#get_current_signs()
    Defined: ~/.local/share/nvim/lazy/vim-signify/autoload/sy/sign.vim:27
Called 5 times
Total time:   0.000436
 Self time:   0.000388

count  total (s)   self (s)
    5              0.000006   let a:sy.internal = {}
    5              0.000004   let a:sy.external = {}
                            
    5   0.000073   0.000026   let signlist = sy#util#get_signs(a:sy.buffer)
                            
   44              0.000019   for sign in signlist
   39              0.000065     if sign.name =~# '^Signify'
                                  " Handle ambiguous signs. Assume you have signs on line 3 and 4.
                                  " Removing line 3 would lead to the second sign to be shifted up
                                  " to line 3. Now there are still 2 signs, both one line 3.
   39              0.000042       if has_key(a:sy.internal, sign.lnum)
                                    execute 'sign unplace' a:sy.internal[sign.lnum].id 'buffer='.a:sy.buffer
   39              0.000008       endif
   39              0.000073       let a:sy.internal[sign.lnum] = { 'type': sign.name, 'id': sign.id }
                                else
                                  let a:sy.external[sign.lnum] = sign.id
   39              0.000007     endif
   44              0.000011   endfor

FUNCTION  <SNR>105_is_modified()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/diff.vim:275
Called 4 times
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    4              0.000004   return a:from_count > 0 && a:to_count > 0 && a:from_count == a:to_count

FUNCTION  <SNR>98_initialize_job()
    Defined: ~/.local/share/nvim/lazy/vim-signify/autoload/sy/repo.vim:455
Called 5 times
Total time:   0.000338
 Self time:   0.000041

count  total (s)   self (s)
    5   0.000336   0.000039   return s:wrap_cmd(a:bufnr, a:vcs, s:get_base_cmd(a:bufnr, a:vcs, g:signify_vcs_cmds))

FUNCTION  gitgutter#buffer_disable()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter.vim:97
Called 1 time
Total time:   0.000606
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000002   let bufnr = a:0 ? a:1 : bufnr('')
    1   0.000019   0.000007   call gitgutter#utility#setbufvar(bufnr, 'enabled', 0)
    1   0.000585   0.000003   call s:clear(bufnr)

FUNCTION  <SNR>89_handle_double_hunk()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/sign.vim:212
Called 3 times
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    3              0.000009   if a:modified_lines[0:1] == [[1, 'removed_first_line'], [1, 'removed']]
                                return [[1, 'removed_above_and_below']] + a:modified_lines[2:]
    3              0.000001   endif
                            
    3              0.000002   return a:modified_lines

FUNCTION  gitgutter#utility#filename()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/utility.vim:329
Called 2 times
Total time:   0.000040
 Self time:   0.000006

count  total (s)   self (s)
    2   0.000039   0.000006   return fnamemodify(s:abs_path(a:bufnr, 0), ':t')

FUNCTION  <SNR>105_is_removed()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/diff.vim:271
Called 4 times
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    4              0.000003   return a:from_count > 0 && a:to_count == 0

FUNCTION  <SNR>34_obtain_file_renames()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/utility.vim:289
Called 2 times
Total time:   0.018937
 Self time:   0.000083

count  total (s)   self (s)
    2              0.000001   let renames = {}
    2   0.000096   0.000004   let cmd = gitgutter#git(a:bufnr)
    2   0.006283   0.000012   if gitgutter#utility#git_supports_command_line_config_override()
    2              0.000002     let cmd .= ' -c "core.safecrlf=false"'
    2              0.000001   endif
    2              0.000003   let cmd .= ' diff --diff-filter=R --name-status '.a:base
    2   0.012507   0.000015   let [out, error_code] = gitgutter#utility#system(cmd)
    2              0.000003   if error_code
                                " Assume the problem is the diff base.
                                call gitgutter#utility#warn('g:gitgutter_diff_base ('.a:base.') is invalid')
                                return {}
    2              0.000001   endif
    2              0.000012   for line in split(out, '\n')
                                let fields = split(line)
                                if len(fields) != 3
                                  call gitgutter#utility#warn('gitgutter: unable to list renamed files: '.line)
                                  return {}
                                endif
                                let [original, current] = fields[1:]
                                let renames[current] = original
    2              0.000001   endfor
    2              0.000003   return renames

FUNCTION  gitgutter#hunk#summary()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/hunk.vim:20
Called 9 times
Total time:   0.000080
 Self time:   0.000040

count  total (s)   self (s)
    9   0.000078   0.000038   return gitgutter#utility#getbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  copilot#OnFileType()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:427
Called 3 times
Total time:   0.000100
 Self time:   0.000028

count  total (s)   self (s)
    3   0.000078   0.000015   if empty(s:BufferDisabled()) && &l:modifiable && &l:buflisted
    2   0.000018   0.000009     call copilot#util#Defer(function('s:Attach'), bufnr(''))
    3              0.000001   endif

FUNCTION  gitgutter#hunk#reset()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/hunk.vim:14
Called 1 time
Total time:   0.000026
 Self time:   0.000008

count  total (s)   self (s)
    1   0.000013   0.000005   call gitgutter#utility#setbufvar(a:bufnr, 'hunks', [])
    1   0.000012   0.000003   call s:reset_summary(a:bufnr)

FUNCTION  gitgutter#utility#base_path()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/utility.vim:234
Called 3 times
Total time:   0.019910
 Self time:   0.000321

count  total (s)   self (s)
    3   0.000072   0.000011   let diffbase = gitgutter#utility#get_diff_base(a:bufnr)
                            
                              " If we already know the original path at this diff base, return it.
    3   0.000031   0.000011   let basepath = gitgutter#utility#getbufvar(a:bufnr, 'basepath', '')
    3              0.000002   if !empty(basepath)
                                " basepath is diffbase:path
                                " Note that path can also contain colons.
                                " List destructuring / unpacking where the remaining items are assigned
                                " to a single variable (:help let-unpack) is only available in v8.2.0540.
    1              0.000004     let parts = split(basepath, ':', 1)
    1              0.000001     let base = parts[0]
    1              0.000004     let bpath = join(parts[1:], ':')
                            
    1              0.000001     if base == diffbase
    1   0.000012   0.000004       return gitgutter#utility#shellescape(bpath)
                                endif
    2              0.000000   endif
                            
                              " Obtain buffers' paths.
    2              0.000001   let current_paths = {}
   40              0.000017   for bufnr in range(1, bufnr('$') + 1)
   38   0.000561   0.000109     if gitgutter#utility#has_repo_path(bufnr)
    3   0.000034   0.000011       let current_paths[gitgutter#utility#repo_path(bufnr, 0)] = bufnr
   38              0.000007     endif
   40              0.000011   endfor
                            
                              " Get a list of file renames at the buffer's diff base.
                              " Store the original paths on any corresponding buffers.
                              " If the buffer's file was one of them, return its original path.
    2              0.000001   let op = ''
    2   0.018952   0.000015   let renames = s:obtain_file_renames(a:bufnr, diffbase)
    2              0.000004   for [current, original] in items(renames)
                                if has_key(current_paths, current)
                                  let bufnr = current_paths[current]
                                  let basepath = diffbase.':'.original
                                  call gitgutter#utility#setbufvar(bufnr, 'basepath', basepath)
                            
                                  if bufnr == a:bufnr
                                    let op = original
                                  endif
                                endif
    2              0.000002   endfor
    2              0.000002   if !empty(op)
                                return gitgutter#utility#shellescape(op)
    2              0.000001   endif
                            
                              " Buffer's file was not renamed, so store current path and return it.
    2   0.000052   0.000010   let current_path = gitgutter#utility#repo_path(a:bufnr, 0)
    2              0.000004   let basepath = diffbase.':'.current_path
    2   0.000034   0.000010   call gitgutter#utility#setbufvar(a:bufnr, 'basepath', basepath)
    2   0.000034   0.000011   return gitgutter#utility#shellescape(current_path)

FUNCTION  <SNR>99_on_stderr_nvim()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/async.vim:66
Called 5 times
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    5              0.000008   if a:data != ['']  " With Neovim there is always [''] reported on stderr.
                                call self.handler.err(self.buffer)
    5              0.000001   endif

FUNCTION  sy#util#shell_redirect()
    Defined: ~/.local/share/nvim/lazy/vim-signify/autoload/sy/util.vim:75
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
                              " if shellredir contains a %s it is replaced with the path
                              " otherwise, just append it (from :help shellredir:
                              "   The name of the temporary file can be represented by '%s' if necessary
                              "   (the file name is appended automatically if no %s appears in the value
                              "   of this option)
    1              0.000002   if &shellredir =~# '%s'
    1              0.000003     return substitute(&shellredir, '\C%s', a:path, 'g')
                              else
                                return &shellredir .' '. a:path
                              endif

FUNCTION  <SNR>99_on_stdout_nvim()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/async.vim:56
Called 8 times
Total time:   0.000070
 Self time:   0.000070

count  total (s)   self (s)
    8              0.000017   if empty(self.stdoutbuffer)
    5              0.000009     let self.stdoutbuffer = a:data
    3              0.000001   else
    3              0.000016     let self.stdoutbuffer = self.stdoutbuffer[:-2] + [self.stdoutbuffer[-1] . a:data[0]] + a:data[1:]
    8              0.000002   endif

FUNCTION  gitgutter#utility#setbufvar()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/utility.vim:18
Called 40 times
Total time:   0.000330
 Self time:   0.000330

count  total (s)   self (s)
   40              0.000038   let buffer = +a:buffer
                              " Default value for getbufvar() was introduced in Vim 7.3.831.
   40              0.000057   let ggvars = getbufvar(buffer, 'gitgutter')
   40              0.000047   if type(ggvars) == type('')
    9              0.000007     unlet ggvars
    9              0.000008     let ggvars = {}
    9              0.000017     call setbufvar(buffer, 'gitgutter', ggvars)
   40              0.000010   endif
   40              0.000050   let ggvars[a:varname] = a:val

FUNCTION  <SNR>82_Focus()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:433
Called 7 times
Total time:   0.000430
 Self time:   0.000106

count  total (s)   self (s)
    7   0.000188   0.000056   if s:Running() && copilot#Client().IsAttached(a:bufnr)
    3   0.000227   0.000035     call copilot#Client().Notify('textDocument/didFocus', {'textDocument': {'uri': copilot#Client().Attach(a:bufnr).uri}})
    7              0.000002   endif

FUNCTION  <SNR>82_Running()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:30
Called 22 times
Total time:   0.000051
 Self time:   0.000051

count  total (s)   self (s)
   22              0.000046   return exists('s:client.job') || exists('s:client.client_id')

FUNCTION  <SNR>84_NvimDoNotify()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/client.vim:479
Called 3 times
Total time:   0.000320
 Self time:   0.000320

count  total (s)   self (s)
    3              0.000317   return eval("v:lua.require'_copilot'.rpc_notify(a:client_id, a:method, a:params)")

FUNCTION  <SNR>98_check_diff_git()
    Defined: ~/.local/share/nvim/lazy/vim-signify/autoload/sy/repo.vim:163
Called 5 times
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    5              0.000010   return a:exitval ? [0, []] : [1, a:diff]

FUNCTION  gitgutter#utility#is_active()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/utility.vim:60
Called 8 times
Total time:   0.000866
 Self time:   0.000120

count  total (s)   self (s)
    8   0.000859   0.000113   return gitgutter#utility#getbufvar(a:bufnr, 'enabled') && !pumvisible() && s:is_file_buffer(a:bufnr) && s:exists_file(a:bufnr) && s:not_git_dir(a:bufnr)

FUNCTION  <SNR>105_save_last_seen_change()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/diff.vim:415
Called 3 times
Total time:   0.000044
 Self time:   0.000016

count  total (s)   self (s)
    3   0.000043   0.000015   call gitgutter#utility#setbufvar(a:bufnr, 'tick', getbufvar(a:bufnr, 'changedtick'))

FUNCTION  <SNR>98_get_vcs_path()
    Defined: ~/.local/share/nvim/lazy/vim-signify/autoload/sy/repo.vim:501
Called 5 times
Total time:   0.000055
 Self time:   0.000055

count  total (s)   self (s)
    5              0.000052   return (a:vcs =~# '\v(git|cvs|accurev|tfs|yadm)') ? getbufvar(a:bufnr, 'sy').info.file : getbufvar(a:bufnr, 'sy').info.path

FUNCTION  sy#repo#detect()
    Defined: ~/.local/share/nvim/lazy/vim-signify/autoload/sy/repo.vim:6
Called 2 times
Total time:   0.003460
 Self time:   0.000037

count  total (s)   self (s)
    2              0.000003   let sy = getbufvar(a:bufnr, 'sy')
    4              0.000004   for vcs in s:vcs_list
    2              0.000002     let sy.detecting += 1
    2              0.000003     let g:signify_detecting += 1
    2   0.003439   0.000015     call sy#repo#get_diff(a:bufnr, vcs, function('sy#sign#set_signs'))
    4              0.000004   endfor

FUNCTION  <SNR>84_NvimNotify()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/client.vim:475
Called 3 times
Total time:   0.000037
 Self time:   0.000021

count  total (s)   self (s)
    3   0.000036   0.000020   call self.AfterInitialized(function('s:NvimDoNotify', [self.client_id, a:method, a:params]))

FUNCTION  <SNR>98_callback_nvim_exit()
    Defined: ~/.local/share/nvim/lazy/vim-signify/autoload/sy/repo.vim:22
Called 5 times
Total time:   0.004940
 Self time:   0.000038

count  total (s)   self (s)
    5   0.004935   0.000033   return s:handle_diff(self, a:exitval)

FUNCTION  <SNR>34_exists_file()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/utility.vim:333
Called 7 times
Total time:   0.000293
 Self time:   0.000064

count  total (s)   self (s)
    7   0.000288   0.000059   return filereadable(s:abs_path(a:bufnr, 0))

FUNCTION  <SNR>105_process_modified_and_added()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/diff.vim:313
Called 2 times
Total time:   0.000077
 Self time:   0.000077

count  total (s)   self (s)
    2              0.000001   let offset = 0
   14              0.000007   while offset < a:from_count
   12              0.000007     let line_number = a:to_line + offset
   12              0.000012     call add(a:modifications, [line_number, 'modified'])
   12              0.000006     let offset += 1
   14              0.000003   endwhile
   13              0.000006   while offset < a:to_count
   11              0.000006     let line_number = a:to_line + offset
   11              0.000010     call add(a:modifications, [line_number, 'added'])
   11              0.000005     let offset += 1
   13              0.000003   endwhile

FUNCTION  <SNR>34_restore_shell()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/utility.vim:218
Called 3 times
Total time:   0.000688
 Self time:   0.000075

count  total (s)   self (s)
    3              0.000012   if (has('unix') || has('win32')) && exists('s:shell')
    3   0.000668   0.000054     let [&shell, &shellcmdflag, &shellredir, &shellpipe, &shellquote, &shellxquote] = [s:shell, s:shellcmdflag, s:shellredir, s:shellpipe, s:shellquote, s:shellxquote]
    3              0.000002   endif

FUNCTION  <SNR>105_is_added()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/diff.vim:267
Called 7 times
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    7              0.000006   return a:from_count == 0 && a:to_count > 0

FUNCTION  gitgutter#git()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter.vim:122
Called 11 times
Total time:   0.000524
 Self time:   0.000079

count  total (s)   self (s)
   11              0.000012   let git = g:gitgutter_git_executable
   11              0.000005   if a:0
   10   0.000480   0.000035     let git .= ' -C '.gitgutter#utility#dir(a:1)
   11              0.000003   endif
   11              0.000011   if empty(g:gitgutter_git_args)
   11              0.000005     return git
                              else
                                return git.' '.g:gitgutter_git_args
                              endif

FUNCTION  gitgutter#utility#set_repo_path()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/utility.vim:157
Called 2 times
Total time:   0.003461
 Self time:   0.000199

count  total (s)   self (s)
                              " Values of path:
                              " * non-empty string - path
                              " *               -1 - pending
                              " *               -2 - not tracked by git
                              " *               -3 - assume unchanged
                            
    2   0.000018   0.000007   call gitgutter#utility#setbufvar(a:bufnr, 'path', -1)
    2   0.000161   0.000023   let cmd = gitgutter#git(a:bufnr).' ls-files -v --error-unmatch --full-name -z -- '. gitgutter#utility#shellescape(gitgutter#utility#filename(a:bufnr))
                            
    2   0.000181   0.000133   if g:gitgutter_async && gitgutter#async#available() && !has('vim_starting')
    2              0.000005     let handler = copy(s:set_path_handler)
    2              0.000002     let handler.continuation = a:continuation
    2   0.003085   0.000019     call gitgutter#async#execute(cmd, a:bufnr, handler)
    2              0.000003     return 'async'
                              endif
                            
                              let [listing, error_code] = gitgutter#utility#system(cmd)
                            
                              if error_code
                                call gitgutter#utility#setbufvar(a:bufnr, 'path', -2)
                                return
                              endif
                            
                              let listing = s:strip_trailing_new_line(listing)
                              let [status, path] = [listing[0], listing[2:]]
                              if status =~# '[a-z]'
                                call gitgutter#utility#setbufvar(a:bufnr, 'path', -3)
                              else
                                call gitgutter#utility#setbufvar(a:bufnr, 'path', path)
                              endif

FUNCTION  <SNR>103_add_sign()
    Defined: ~/.local/share/nvim/lazy/vim-signify/autoload/sy/sign.vim:258
Called 78 times
Total time:   0.000895
 Self time:   0.000826

count  total (s)   self (s)
   78              0.000075   call add(a:sy.lines, a:line)
   78              0.000074   let a:sy.signtable[a:line] = 1
                            
   78              0.000074   if has_key(a:sy.internal, a:line)
                                " There is a sign on this line already.
   39              0.000042     if a:type == a:sy.internal[a:line].type
                                  " Keep current sign since the new one is of the same type.
   39              0.000032       return a:sy.internal[a:line].id
                                else
                                  " Update sign by overwriting the ID of the current sign.
                                  let id = a:sy.internal[a:line].id
                                endif
   39              0.000007   endif
                            
   39              0.000024   if !exists('id')
   39   0.000153   0.000084     let id = sy#sign#id_next(a:sy)
   39              0.000008   endif
                            
   39              0.000053   if a:type =~# 'SignifyDelete'
                                execute printf('sign define %s text=%s texthl=SignifySignDelete linehl=%s %s', a:type, a:1, s:delete_highlight[g:signify_line_highlight], sy#util#numhl('SignifySignDelete'))
   39              0.000007   endif
   39              0.000118   execute printf('sign place %d line=%d name=%s %s buffer=%s', id, a:line, a:type, s:sign_priority, a:sy.buffer)
                            
   39              0.000014   return id

FUNCTION  gitbranch#detect()
    Defined: ~/.local/share/nvim/lazy/vim-gitbranch/autoload/gitbranch.vim:49
Called 9 times
Total time:   0.000529
 Self time:   0.000146

count  total (s)   self (s)
    9              0.000018   unlet! b:gitbranch_path
    9              0.000036   let b:gitbranch_pwd = expand('%:p:h')
    9   0.000411   0.000028   let dir = gitbranch#dir(a:path)
    9              0.000006   if dir !=# ''
    9              0.000007     let path = dir . '/HEAD'
    9              0.000031     if filereadable(path)
    9              0.000008       let b:gitbranch_path = path
    9              0.000002     endif
    9              0.000002   endif

FUNCTION  <SNR>33_on_buffilepost()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/plugin/gitgutter.vim:277
Called 1 time
Total time:   0.000624
 Self time:   0.000017

count  total (s)   self (s)
    1              0.000002   if len(s:renaming) > 1
                                if s:renaming[0] != a:bufnr
                                  throw 'gitgutter rename error' s:renaming[0] a:bufnr
                                endif
                                unlet s:renaming[0]
                                return
    1              0.000000   endif
                            
                              " reset cached values
    1   0.000613   0.000006   GitGutterBufferDisable
                            
    1              0.000001   if s:gitgutter_was_enabled
                                GitGutterBufferEnable
    1              0.000000   endif
                            
    1              0.000001   unlet s:renaming
    1              0.000000   unlet s:gitgutter_was_enabled

FUNCTION  gitgutter#async#execute()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/async.vim:16
Called 5 times
Total time:   0.011551
 Self time:   0.011410

count  total (s)   self (s)
    5   0.000251   0.000124   call gitgutter#debug#log('[async] '.a:cmd)
                            
    5              0.000011   let options = {   'stdoutbuffer': [],   'buffer': a:bufnr,   'handler': a:handler }
    5   0.000030   0.000016   let command = s:build_command(a:cmd)
                            
    5              0.000006   if has('nvim')
    5              0.011185     call jobstart(command, extend(options, {   'on_stdout': function('s:on_stdout_nvim'),   'on_stderr': function('s:on_stderr_nvim'),   'on_exit':   function('s:on_exit_nvim') }))
                              else
                                let job = job_start(command, {   'out_cb':   function('s:on_stdout_vim', options),   'err_cb':   function('s:on_stderr_vim', options),   'close_cb': function('s:on_exit_vim', options) })
                                let s:jobs[s:job_id(job)] = 1
    5              0.000003   endif

FUNCTION  sy#start()
    Defined: ~/.local/share/nvim/lazy/vim-signify/autoload/sy.vim:7
Called 8 times
Total time:   0.013640
 Self time:   0.000833

count  total (s)   self (s)
    8              0.000012   if g:signify_locked
                                call sy#verbose('Locked.')
                                return
    8              0.000003   endif
                            
    8              0.000008   if g:signify_detecting > 50
                                call sy#verbose('Too many detection jobs running, deferring detection')
                                return
    8              0.000002   endif
                            
    8              0.000022   let bufnr = a:0 && has_key(a:1, 'bufnr') ? a:1.bufnr : bufnr('')
    8              0.000014   let sy = getbufvar(bufnr, 'sy')
                            
    8              0.000008   if empty(sy)
    2   0.000045   0.000006     let path = s:get_path(bufnr)
    2   0.000051   0.000006     if s:skip(bufnr, path)
                                  call sy#verbose('Skip file: '. path)
                                  return
    2              0.000000     endif
    2   0.000015   0.000005     call sy#verbose('Register new file: '. path)
    2   0.000222   0.000123     let new_sy = { 'path':       path, 'buffer':     bufnr, 'detecting':  0, 'vcs':        [], 'hunks':      [], 'signid':     0x100, 'updated_by': '', 'stats':      [-1, -1, -1], 'info':       {    'dir':  fnamemodify(path, ':p:h'),    'path': sy#util#escape(path),    'file': sy#util#escape(fnamemodify(path, ':t')) }}
    2              0.000004     call setbufvar(bufnr, 'sy', new_sy)
    2   0.000104   0.000006     call sy#set_buflocal_autocmds(bufnr)
    2   0.004014   0.000106     call sy#repo#detect(bufnr)
    6              0.000016   elseif has('vim_starting')
                                call sy#verbose("Don't run Sy more than once during startup.")
                                return
    6              0.000002   else
    6   0.000209   0.000071     let path = s:get_path(bufnr)
    6              0.000027     if !filereadable(path)
                                  call sy#stop()
                                  return
    6              0.000008     elseif empty(sy.vcs)
    2              0.000003       if get(sy, 'retry')
                                    let sy.retry = 0
                                    call sy#verbose('Redetecting VCS.')
                                    call sy#repo#detect(sy.buffer)
    2              0.000001       else
    2              0.000002         if get(sy, 'detecting')
    2   0.000029   0.000008           call sy#verbose('Detection is already in progress.')
                                    else
                                      call sy#verbose('No VCS found. Disabling.')
                                      call sy#stop(sy.buffer)
    2              0.000001         endif
    2              0.000001       endif
    4              0.000001     else
    8              0.000012       for vcs in sy.vcs
    4              0.000010         let job_id = getbufvar(sy.buffer, 'sy_job_id_'. vcs, 0)
    4              0.000007         if type(job_id) != type(0) || job_id > 0
    1   0.000010   0.000003           call sy#verbose('Update is already in progress.', vcs)
    3              0.000001         else
    3   0.000037   0.000011           call sy#verbose('Updating signs.', vcs)
    3   0.008450   0.000036           call sy#repo#get_diff(sy.buffer, vcs, function('sy#sign#set_signs'))
    4              0.000003         endif
    8              0.000009       endfor
    6              0.000002     endif
    8              0.000002   endif

FUNCTION  gitgutter#debug#log()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/debug.vim:70
Called 11 times
Total time:   0.000212
 Self time:   0.000212

count  total (s)   self (s)
   11              0.000011   if g:gitgutter_log
                                if s:new_log_session && gitgutter#async#available()
                                  if exists('*ch_logfile')
                                    call ch_logfile(s:channel_log, 'w')
                                  endif
                                endif
                            
                                if s:new_log_session
                                  let s:start = reltime()
                                  call writefile(['', '========== start log session '.strftime('%d.%m.%Y %H:%M:%S').' =========='], s:log_file, 'a')
                                endif
                            
                                let elapsed = reltimestr(reltime(s:start)).' '
                                call writefile([''], s:log_file, 'a')
                                " callers excluding this function
                                call writefile([elapsed.expand('<sfile>')[:-22].':'], s:log_file, 'a')
                                call writefile([elapsed.s:format_for_log(a:message)], s:log_file, 'a')
                                if a:0 && !empty(a:1)
                                  for msg in a:000
                                    call writefile([elapsed.s:format_for_log(msg)], s:log_file, 'a')
                                  endfor
                                endif
                            
                                let s:new_log_session = 0
   11              0.000003   endif

FUNCTION  <SNR>34_winshell()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/utility.vim:77
Called 10 times
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
   10              0.000032   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash

FUNCTION  <SNR>34_strip_trailing_new_line()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/utility.vim:342
Called 2 times
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    2              0.000011   return substitute(a:line, '[[:cntrl:]]$', '', '')

FUNCTION  <SNR>98_get_base_cmd()
    Defined: ~/.local/share/nvim/lazy/vim-signify/autoload/sy/repo.vim:508
Called 5 times
Total time:   0.000219
 Self time:   0.000093

count  total (s)   self (s)
    5              0.000010   let cmd = a:vcs_cmds[a:vcs]
    5   0.000138   0.000046   let cmd = s:replace(cmd, '%f', s:get_vcs_path(a:bufnr, a:vcs))
    5   0.000036   0.000016   let cmd = s:replace(cmd, '%d', s:difftool)
    5   0.000030   0.000015   let cmd = s:replace(cmd, '%n', s:devnull)
    5              0.000003   return cmd

FUNCTION  sy#verbose()
    Defined: ~/.local/share/nvim/lazy/vim-signify/autoload/sy.vim:119
Called 28 times
Total time:   0.000205
 Self time:   0.000205

count  total (s)   self (s)
   28              0.000025   if &verbose
                                if type(a:msg) == type([])
                                  for msg in a:msg
                                    echomsg printf('[sy%s] %s', (a:0 ? ':'.a:1 : ''), msg)
                                  endfor
                                else
                                  echomsg printf('[sy%s] %s', (a:0 ? ':'.a:1 : ''), a:msg)
                                endif
   28              0.000007   endif

FUNCTION  <SNR>84_NvimAttach()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/client.vim:431
Called 5 times
Total time:   0.003492
 Self time:   0.000926

count  total (s)   self (s)
    5              0.000005   if !bufloaded(a:bufnr)
                                return {'uri': '', 'version': 0}
    5              0.000001   endif
    5   0.003404   0.000838   call luaeval('pcall(vim.lsp.buf_attach_client, _A[1], _A[2])', [a:bufnr, self.id])
    5              0.000071   return luaeval('{uri = vim.uri_from_bufnr(_A), version = vim.lsp.util.buf_versions[_A]}', a:bufnr)

FUNCTION  gitgutter#utility#get_diff_base()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/utility.vim:224
Called 6 times
Total time:   0.000135
 Self time:   0.000135

count  total (s)   self (s)
    6              0.000074   let p = resolve(expand('#'.a:bufnr.':p'))
    6              0.000040   let ml = matchlist(p, '\v^fugitive:/.*/(\x{40,})/')
    6              0.000008   if !empty(ml) && !empty(ml[1])
                                return ml[1].'^'
    6              0.000001   endif
    6              0.000005   return g:gitgutter_diff_base

FUNCTION  sy#sign#process_diff()
    Defined: ~/.local/share/nvim/lazy/vim-signify/autoload/sy/sign.vim:50
Called 5 times
Total time:   0.003761
 Self time:   0.002133

count  total (s)   self (s)
    5              0.000015   let a:sy.signtable             = {}
    5              0.000011   let a:sy.hunks                 = []
    5              0.000008   let [added, modified, deleted] = [0, 0, 0]
                            
    5   0.000465   0.000029   call sy#sign#get_current_signs(a:sy)
                            
                              " Determine where we have to put our signs.
   19              0.000135   for line in filter(a:diff, 'v:val =~ "^@@ "')
   14              0.000011     let a:sy.lines = []
   14              0.000007     let ids        = []
                            
   14   0.000191   0.000053     let [old_line, old_count, new_line, new_count] = sy#sign#parse_hunk(line)
                            
                                " Workaround for non-conventional diff output in older Fossil versions:
                                " https://fossil-scm.org/forum/forumpost/834ce0f1e1
                                " Fixed as of: https://fossil-scm.org/index.html/info/7fd2a3652ea7368a
   14              0.000013     if a:vcs == 'fossil' && new_line == 0
                                  let new_line = old_line - 1 - deleted
   14              0.000003     endif
                            
                                " Pure add:
                            
                                " @@ -5,0 +6,2 @@ this is line 5
                                " +this is line 5
                                " +this is line 5
   14              0.000011     if old_count == 0 && new_count > 0
    6              0.000005       let added += new_count
    6              0.000004       let offset = 0
   30              0.000018       while offset < new_count
   24              0.000017         let line    = new_line + offset
   24              0.000013         let offset += 1
   46   0.000124   0.000081         if s:external_sign_present(a:sy, line) | continue | endif
   24   0.000373   0.000073         call add(ids, s:add_sign(a:sy, line, 'SignifyAdd'))
   30              0.000009       endwhile
                            
                                " Pure delete
                            
                                " @@ -6,2 +5,0 @@ this is line 5
                                " -this is line 6
                                " -this is line 7
    8              0.000006     elseif old_count > 0 && new_count == 0
                                  if s:external_sign_present(a:sy, new_line) | continue | endif
                                  let deleted += old_count
                                  if new_line == 0
                                    call add(ids, s:add_sign(a:sy, 1, 'SignifyRemoveFirstLine'))
                                  elseif s:sign_show_count
                                    if old_count > 99
                                      let text = s:sign_delete . '>'
                                    elseif old_count < 2
                                      let text = s:sign_delete
                                    else
                                      let text = s:sign_delete . old_count
                                    endif
                                    while strwidth(text) > 2
                                      let text = substitute(text, '.', '', '')
                                    endwhile
                                    call add(ids, s:add_sign(a:sy, new_line, 'SignifyDelete'. old_count, text))
                                  else
                                    call add(ids, s:add_sign(a:sy, new_line, 'SignifyDeleteMore', s:sign_delete))
                                  endif
                                " All lines are modified.
    8              0.000008     elseif old_count > 0 && new_count > 0 && old_count == new_count
    4              0.000003       let modified += new_count
    4              0.000002       let offset = 0
   12              0.000006       while offset < new_count
    8              0.000005         let line    = new_line + offset
    8              0.000004         let offset += 1
   16   0.000038   0.000025         if s:external_sign_present(a:sy, line) | continue | endif
    8   0.000110   0.000022         call add(ids, s:add_sign(a:sy, line, 'SignifyChange'))
   12              0.000003       endwhile
                                " Some lines are modified and some new lines are added.
    4              0.000004     elseif old_count > 0 && new_count > 0 && old_count < new_count
    4              0.000003       let modified += old_count
    4              0.000003       let added += new_count - old_count
    4              0.000002       let offset = 0
   28              0.000016       while offset < old_count
   24              0.000016         let line    = new_line + offset
   24              0.000012         let offset += 1
   48   0.000113   0.000074         if s:external_sign_present(a:sy, line) | continue | endif
   24   0.000333   0.000067         call add(ids, s:add_sign(a:sy, line, 'SignifyChange'))
   28              0.000008       endwhile
   26              0.000015       while offset < new_count
   22              0.000014         let line    = new_line + offset
   22              0.000011         let offset += 1
   44   0.000100   0.000065         if s:external_sign_present(a:sy, line) | continue | endif
   22   0.000301   0.000060         call add(ids, s:add_sign(a:sy, line, 'SignifyAdd'))
   26              0.000007       endwhile
                                " Some lines are modified and some lines are deleted.
                                elseif old_count > 0 && new_count > 0 && old_count > new_count
                                  let modified += new_count
                                  let deleted_count = old_count - new_count
                                  let deleted += deleted_count
                            
                                  let prev_line_available = new_line > 1 && !get(a:sy.signtable, new_line - 1, 0)
                                  if prev_line_available
                                    if s:sign_show_count
                                      if deleted_count > 99
                                        let text = s:sign_delete . '>'
                                      elseif deleted_count < 2
                                        let text = s:sign_delete
                                      else
                                        let text = s:sign_delete . deleted_count
                                      endif
                                      while strwidth(text) > 2
                                        let text = substitute(text, '.', '', '')
                                      endwhile
                                      call add(ids, s:add_sign(a:sy, new_line - 1, 'SignifyDelete'. deleted_count, text))
                                    else
                                      call add(ids, s:add_sign(a:sy, new_line - 1, 'SignifyDeleteMore', s:sign_delete))
                                    endif
                                  endif
                            
                                  let offset = 0
                                  while offset < new_count
                                    let line    = new_line + offset
                                    if s:external_sign_present(a:sy, line) | continue | endif
                                    if !prev_line_available && offset == 0
                                      call add(ids, s:add_sign(a:sy, line, 'SignifyChangeDelete'))
                                    else
                                      call add(ids, s:add_sign(a:sy, line, 'SignifyChange'))
                                    endif
                                    let offset += 1
                                  endwhile
   14              0.000003     endif
                            
   14              0.000009     if !empty(ids)
   14              0.000031       call add(a:sy.hunks, { 'ids'  : ids, 'start': a:sy.lines[0], 'end'  : a:sy.lines[-1] })
   14              0.000003     endif
   19              0.000012   endfor
                            
                              " Remove obsoleted signs.
    5              0.000034   for line in filter(keys(a:sy.internal), '!has_key(a:sy.signtable, v:val)')
                                execute 'sign unplace' a:sy.internal[line].id 'buffer='.a:sy.buffer
    5              0.000002   endfor
                            
    5              0.000008   if empty(a:sy.updated_by) && empty(a:sy.hunks)
    3   0.000033   0.000014     call sy#verbose('Successful exit value, but no diff. Keep VCS for time being.', a:vcs)
    3              0.000001     return
    2              0.000000   endif
                            
    2   0.000017   0.000007   call sy#verbose('Signs updated.', a:vcs)
    2              0.000004   let a:sy.updated_by = a:vcs
    2              0.000003   if len(a:sy.vcs) > 1
                                call sy#verbose('Disable all other VCS.', a:vcs)
                                let a:sy.vcs = [a:vcs]
    2              0.000000   endif
                            
    2              0.000003   let a:sy.stats = [added, modified, deleted]

FUNCTION  gitgutter#utility#extension()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/utility.vim:97
Called 3 times
Total time:   0.000075
 Self time:   0.000012

count  total (s)   self (s)
    3   0.000074   0.000011   return fnamemodify(s:abs_path(a:bufnr, 0), ':e')

FUNCTION  <SNR>83_RunDeferred()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/util.vim:12
Called 24 times
Total time:   0.004359
 Self time:   0.000192

count  total (s)   self (s)
   24              0.000044   if empty(s:deferred)
   12              0.000005     return
   12              0.000003   endif
   12              0.000028   let Fn = remove(s:deferred, 0)
   12              0.000045   call timer_start(0, function('s:RunDeferred'))
   12   0.004213   0.000046   call call(Fn, [])

FUNCTION  copilot#OnBufUnload()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:465
Called 6 times
Total time:   0.000001
 Self time:   0.000001

count  total (s)   self (s)

FUNCTION  gitgutter#utility#repo_path()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/utility.vim:125
Called 59 times
Total time:   0.000556
 Self time:   0.000270

count  total (s)   self (s)
   59   0.000479   0.000193   let p = gitgutter#utility#getbufvar(a:bufnr, 'path', '')
   59              0.000060   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  <SNR>105_process_hunk()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/diff.vim:234
Called 7 times
Total time:   0.000588
 Self time:   0.000225

count  total (s)   self (s)
    7              0.000005   let modifications = []
    7              0.000006   let from_line  = a:hunk[0]
    7              0.000005   let from_count = a:hunk[1]
    7              0.000011   let to_line    = a:hunk[2]
    7              0.000005   let to_count   = a:hunk[3]
                            
    7   0.000025   0.000018   if s:is_added(from_count, to_count)
    3   0.000065   0.000011     call s:process_added(modifications, from_count, to_count, to_line)
    3   0.000087   0.000010     call gitgutter#hunk#increment_lines_added(a:bufnr, to_count)
                            
    4   0.000014   0.000010   elseif s:is_removed(from_count, to_count)
                                call s:process_removed(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count)
                            
    4   0.000014   0.000009   elseif s:is_modified(from_count, to_count)
    2   0.000029   0.000008     call s:process_modified(modifications, from_count, to_count, to_line)
    2   0.000048   0.000007     call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
                            
    2   0.000008   0.000005   elseif s:is_modified_and_added(from_count, to_count)
    2   0.000085   0.000008     call s:process_modified_and_added(modifications, from_count, to_count, to_line)
    2   0.000045   0.000006     call gitgutter#hunk#increment_lines_added(a:bufnr, to_count - from_count)
    2   0.000043   0.000006     call gitgutter#hunk#increment_lines_modified(a:bufnr, from_count)
                            
                              elseif s:is_modified_and_removed(from_count, to_count)
                                call s:process_modified_and_removed(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
                                call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count - to_count)
                            
    7              0.000001   endif
    7              0.000003   return modifications

FUNCTION  sy#repo#get_diff()
    Defined: ~/.local/share/nvim/lazy/vim-signify/autoload/sy/repo.vim:73
Called 5 times
Total time:   0.011838
 Self time:   0.011470

count  total (s)   self (s)
    5   0.000083   0.000053   call sy#verbose('sy#repo#get_diff()', a:vcs)
                            
    5              0.000009   let job_id = getbufvar(a:bufnr, 'sy_job_id_'.a:vcs)
                            
    5              0.000009   if getbufvar(a:bufnr, '&modified')
                                let [cmd, options] = s:initialize_buffer_job(a:bufnr, a:vcs)
                                let options.difftool = 'diff'
    5              0.000001   else
    5   0.000360   0.000022     let [cmd, options] = s:initialize_job(a:bufnr, a:vcs)
    5              0.000007     let options.difftool = a:vcs
    5              0.000001   endif
                            
    5              0.000005   let options.func = a:func
                            
    5              0.000006   if has('nvim')
    5              0.000003     if job_id
                                  silent! call jobstop(job_id)
    5              0.000001     endif
    5              0.011227     let job_id = jobstart(cmd, extend(options, { 'cwd':       getbufvar(a:bufnr, 'sy').info.dir, 'on_stdout': function('s:callback_nvim_stdout'), 'on_exit':   function('s:callback_nvim_exit'), }))
    5              0.000025     call setbufvar(a:bufnr, 'sy_job_id_'.a:vcs, job_id)
                              elseif has('patch-8.0.902')
                                if type(job_id) != type(0)
                                  silent! call job_stop(job_id)
                                endif
                                let opts = { 'cwd':      getbufvar(a:bufnr, 'sy').info.dir, 'in_io':    'null', 'out_cb':   function('s:callback_vim_stdout', options), 'close_cb': function('s:callback_vim_close', options), }
                                let job_id = job_start(cmd, opts)
                                call setbufvar(a:bufnr, 'sy_job_id_'.a:vcs, job_id)
                              else
                                let options.stdoutbuf = split(s:run(a:vcs), '\n')
                                call s:handle_diff(options, v:shell_error)
    5              0.000001   endif

FUNCTION  gitgutter#utility#git_supports_command_line_config_override()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/utility.vim:10
Called 5 times
Total time:   0.006287
 Self time:   0.000032

count  total (s)   self (s)
    5              0.000007   if !exists('s:c_flag')
    1   0.006262   0.000007     let [_, error_code] = gitgutter#utility#system(gitgutter#git().' -c foo.bar=baz --version')
    1              0.000002     let s:c_flag = !error_code
    5              0.000001   endif
    5              0.000003   return s:c_flag

FUNCTION  gitgutter#diff#run_diff()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/diff.vim:63
Called 3 times
Total time:   0.029598
 Self time:   0.000359

count  total (s)   self (s)
    3   0.000043   0.000011   if gitgutter#utility#repo_path(a:bufnr, 0) == -1
                                throw 'gitgutter path not set'
    3              0.000001   endif
                            
    3   0.000036   0.000009   if gitgutter#utility#repo_path(a:bufnr, 0) == -2
                                throw 'gitgutter not tracked'
    3              0.000001   endif
                            
    3   0.000034   0.000009   if gitgutter#utility#repo_path(a:bufnr, 0) == -3
                                throw 'gitgutter assume unchanged'
    3              0.000001   endif
                            
                              " Wrap compound commands in parentheses to make Windows happy.
                              " bash doesn't mind the parentheses.
    3              0.000002   let cmd = '('
                            
                              " Append buffer number to temp filenames to avoid race conditions between
                              " writing and reading the files when asynchronously processing multiple
                              " buffers.
                            
                              " Without the buffer number, buff_file would have a race between the
                              " second gitgutter#process_buffer() writing the file (synchronously, below)
                              " and the first gitgutter#process_buffer()'s async job reading it (with
                              " git-diff).
    3              0.000005   let buff_file = s:temp_buffer.'.'.a:bufnr
                            
                              " Add a counter to avoid a similar race with two quick writes of the same buffer.
                              " Use a modulus greater than a maximum reasonable number of visible buffers.
    3              0.000003   let s:counter = (s:counter + 1) % 20
    3              0.000004   let buff_file .= '.'.s:counter
                            
    3   0.000088   0.000013   let extension = gitgutter#utility#extension(a:bufnr)
    3              0.000003   if !empty(extension)
    3              0.000003     let buff_file .= '.'.extension
    3              0.000001   endif
                            
                              " Write buffer to temporary file.
                              " Note: this is synchronous.
    3   0.000221   0.000017   call s:write_buffer(a:bufnr, buff_file)
                            
    3              0.000002   if a:from ==# 'index'
                                " Without the buffer number, from_file would have a race in the shell
                                " between the second process writing it (with git-show) and the first
                                " reading it (with git-diff).
    3              0.000005     let from_file = s:temp_from.'.'.a:bufnr
                            
                                " Add a counter to avoid a similar race with two quick writes of the same buffer.
    3              0.000003     let from_file .= '.'.s:counter
                            
    3              0.000003     if !empty(extension)
    3              0.000003       let from_file .= '.'.extension
    3              0.000001     endif
                            
                                " Write file from index to temporary file.
    3   0.020020   0.000036     let index_name = gitgutter#utility#get_diff_base(a:bufnr).':'.gitgutter#utility#base_path(a:bufnr)
    3   0.000223   0.000022     let cmd .= gitgutter#git(a:bufnr).' --no-pager show --textconv '.index_name.' > '.from_file.' || exit 0) && ('
                            
                              elseif a:from ==# 'working_tree'
                                let from_file = gitgutter#utility#repo_path(a:bufnr, 1)
    3              0.000003   endif
                            
                              " Call git-diff.
    3   0.000150   0.000013   let cmd .= gitgutter#git(a:bufnr).' --no-pager'
    3   0.000034   0.000018   if gitgutter#utility#git_supports_command_line_config_override()
    3              0.000007     let cmd .= ' -c "diff.autorefreshindex=0"'
    3              0.000005     let cmd .= ' -c "diff.noprefix=false"'
    3              0.000005     let cmd .= ' -c "core.safecrlf=false"'
    3              0.000001   endif
    3              0.000011   let cmd .= ' diff --no-ext-diff --no-color -U0 '.g:gitgutter_diff_args.' -- '.from_file.' '.buff_file
                            
                              " Pipe git-diff output into grep.
    3              0.000005   if !a:preserve_full_diff && !empty(g:gitgutter_grep)
    3   0.000061   0.000015     let cmd .= ' | '.g:gitgutter_grep.' '.gitgutter#utility#shellescape('^@@ ')
    3              0.000001   endif
                            
                              " grep exits with 1 when no matches are found; git-diff exits with 1 when
                              " differences are found.  However we want to treat non-matches and
                              " differences as non-erroneous behaviour; so we OR the command with one
                              " which always exits with success (0).
    3              0.000006   let cmd .= ' || exit 0'
                            
    3              0.000006   let cmd .= ')'
                            
    3   0.000018   0.000012   if g:gitgutter_async && gitgutter#async#available()
    3   0.008526   0.000041     call gitgutter#async#execute(cmd, a:bufnr, {   'out': function('gitgutter#diff#handler'),   'err': function('gitgutter#hunk#reset'), })
    3              0.000005     return 'async'
                            
                              else
                                let [diff, error_code] = gitgutter#utility#system(cmd)
                            
                                if error_code
                                  call gitgutter#debug#log(diff)
                                  throw 'gitgutter diff failed'
                                endif
                            
                                return diff
                              endif

FUNCTION  <SNR>33_on_buffilepre()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/plugin/gitgutter.vim:268
Called 1 time
Total time:   0.000034
 Self time:   0.000018

count  total (s)   self (s)
    1              0.000003   if !exists('s:renaming')
    1              0.000005     let s:renaming = []
    1   0.000023   0.000007     let s:gitgutter_was_enabled = gitgutter#utility#getbufvar(a:bufnr, 'enabled')
    1              0.000000   endif
                            
    1              0.000002   let s:renaming += [a:bufnr]

FUNCTION  <SNR>84_NvimIsAttached()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/client.vim:439
Called 7 times
Total time:   0.000052
 Self time:   0.000052

count  total (s)   self (s)
    7              0.000050   return bufloaded(a:bufnr) ? luaeval('vim.lsp.buf_is_attached(_A[1], _A[2])', [a:bufnr, self.id]) : v:false

FUNCTION  <SNR>34_is_file_buffer()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/utility.vim:72
Called 8 times
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    8              0.000022   return empty(getbufvar(a:bufnr, '&buftype'))

FUNCTION  <SNR>34_abs_path()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/utility.vim:314
Called 29 times
Total time:   0.000742
 Self time:   0.000742

count  total (s)   self (s)
   29              0.000445   let p = resolve(expand('#'.a:bufnr.':p'))
                            
                              " Remove extra parts from fugitive's filepaths
   29              0.000232   let p = substitute(substitute(p, '^fugitive:', '', ''), '\v\.git/\x{40,}/', '', '')
                            
   29              0.000036   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  gitgutter#process_buffer()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter.vim:21
Called 8 times
Total time:   0.034796
 Self time:   0.000478

count  total (s)   self (s)
                              " NOTE a:bufnr is not necessarily the current buffer.
                            
    8   0.000105   0.000043   if gitgutter#utility#getbufvar(a:bufnr, 'enabled', -1) == -1
    2   0.000018   0.000006     call gitgutter#utility#setbufvar(a:bufnr, 'enabled', g:gitgutter_enabled)
    8              0.000003   endif
                            
    8   0.000898   0.000032   if gitgutter#utility#is_active(a:bufnr)
                            
    7              0.000013     if has('patch-7.4.1559')
    7              0.000022       let l:Callback = function('gitgutter#process_buffer', [a:bufnr, a:force])
                                else
                                  let l:Callback = {'function': 'gitgutter#process_buffer', 'arguments': [a:bufnr, a:force]}
    7              0.000002     endif
    7   0.003670   0.000037     let how = s:setup_path(a:bufnr, l:Callback)
    7              0.000011     if [how] == ['async']  " avoid string-to-number conversion if how is a number
    2              0.000001       return
    5              0.000001     endif
                            
    5   0.000057   0.000016     if a:force || s:has_fresh_changes(a:bufnr)
                            
    3              0.000002       let diff = 'NOT SET'
    3              0.000002       try
    3   0.029848   0.000143         let diff = gitgutter#diff#run_diff(a:bufnr, g:gitgutter_diff_relative_to, 0)
                                  catch /gitgutter not tracked/
                                    call gitgutter#debug#log('Not tracked: '.gitgutter#utility#file(a:bufnr))
                                  catch /gitgutter assume unchanged/
                                    call gitgutter#debug#log('Assume unchanged: '.gitgutter#utility#file(a:bufnr))
                                  catch /gitgutter diff failed/
                                    call gitgutter#debug#log('Diff failed: '.gitgutter#utility#file(a:bufnr))
                                    call gitgutter#hunk#reset(a:bufnr)
    3              0.000002       endtry
                            
    3              0.000004       if diff != 'async' && diff != 'NOT SET'
                                    call gitgutter#diff#handler(a:bufnr, diff)
    3              0.000001       endif
                            
    5              0.000001     endif
    6              0.000002   endif

FUNCTION  gitgutter#hunk#hunks()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/hunk.vim:10
Called 3 times
Total time:   0.000032
 Self time:   0.000013

count  total (s)   self (s)
    3   0.000030   0.000012   return gitgutter#utility#getbufvar(a:bufnr, 'hunks', [])

FUNCTION  <SNR>1_LoadFTPlugin()
    Defined: /usr/share/nvim/runtime/ftplugin.vim:15
Called 3 times
Total time:   0.007316
 Self time:   0.004173

count  total (s)   self (s)
    3              0.000007     if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
    3              0.000001     endif
                            
    3              0.000006     let s = expand("<amatch>")
    3              0.000003     if s != ""
    3              0.000008       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
    3              0.000001       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
    6              0.000010       for name in split(s, '\.')
                                    " Load Lua ftplugins after Vim ftplugins _per directory_
                                    " TODO(clason): use nvim__get_runtime when supports globs and modeline
                                    " XXX: "[.]" in the first pattern makes it a wildcard on Windows
    3   0.007256   0.004113         exe $'runtime! ftplugin/{name}[.]{{vim,lua}} ftplugin/{name}_*.{{vim,lua}} ftplugin/{name}/*.{{vim,lua}}'
    6              0.000003       endfor
    3              0.000001     endif

FUNCTION  <SNR>98_replace()
    Defined: ~/.local/share/nvim/lazy/vim-signify/autoload/sy/repo.vim:536
Called 15 times
Total time:   0.000071
 Self time:   0.000071

count  total (s)   self (s)
   15              0.000036   let parts = split(a:cmd, a:pat, 1)
   15              0.000031   return join(parts, a:sub)

FUNCTION  gitgutter#utility#getbufvar()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/utility.vim:30
Called 102 times
Total time:   0.000559
 Self time:   0.000559

count  total (s)   self (s)
  102              0.000084   let buffer = +a:buffer
  102              0.000128   let ggvars = getbufvar(buffer, 'gitgutter')
  102              0.000181   if type(ggvars) == type({}) && has_key(ggvars, a:varname)
   56              0.000054     return ggvars[a:varname]
   46              0.000009   endif
   46              0.000015   if a:0
   43              0.000016     return a:1
    3              0.000001   endif

FUNCTION  <SNR>47_Event()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/plugin/copilot.vim:45
Called 16 times
Total time:   0.000333
 Self time:   0.000116

count  total (s)   self (s)
   16              0.000010   try
   16   0.000279   0.000061     call call('copilot#On' . a:type, [])
                              catch
                                call copilot#logger#Exception('autocmd.' . a:type)
   16              0.000008   endtry

FUNCTION  fzf_lua#getwininfo()
    Defined: ~/.local/share/nvim/lazy/fzf-lua/autoload/fzf_lua.vim:21
Called 3 times
Total time:   0.000049
 Self time:   0.000049

count  total (s)   self (s)
    3              0.000025   let info = getwininfo(a:winid)
    3              0.000005   if empty(info)
                                return []
    3              0.000002   endif
    3              0.000006   unlet! info[0].variables
    3              0.000004   return info[0]

FUNCTION  <SNR>80_reset_tick()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter.vim:194
Called 6 times
Total time:   0.000097
 Self time:   0.000034

count  total (s)   self (s)
    6   0.000095   0.000032   call gitgutter#utility#setbufvar(a:bufnr, 'tick', 0)

FUNCTION  <SNR>79_SynSet()
    Defined: /usr/share/nvim/runtime/syntax/synload.vim:27
Called 4 times
Total time:   0.000985
 Self time:   0.000985

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
    4              0.000005   syn clear
    4              0.000005   if exists("b:current_syntax")
                                unlet b:current_syntax
    4              0.000001   endif
                            
    4              0.000008   0verbose let s = expand("<amatch>")
    4              0.000003   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
    4              0.000002   elseif s == "OFF"
                                let s = ""
    4              0.000001   endif
                            
    4              0.000002   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.  Skip empty entries.
    2              0.000003     for name in split(s, '\.')
    1              0.000001       if !empty(name)
                                    " XXX: "[.]" in the first pattern makes it a wildcard on Windows
    1              0.000912         exe $'runtime! syntax/{name}[.]{{vim,lua}} syntax/{name}/*.{{vim,lua}}'
    1              0.000001       endif
    2              0.000001     endfor
    4              0.000001   endif

FUNCTION  <SNR>80_clear()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter.vim:198
Called 1 time
Total time:   0.000582
 Self time:   0.000260

count  total (s)   self (s)
    1   0.000245   0.000143   call gitgutter#sign#clear_signs(a:bufnr)
    1   0.000301   0.000109   call gitgutter#hunk#reset(a:bufnr)
    1   0.000020   0.000003   call s:reset_tick(a:bufnr)
    1   0.000007   0.000002   call gitgutter#utility#setbufvar(a:bufnr, 'path', '')
    1   0.000007   0.000002   call gitgutter#utility#setbufvar(a:bufnr, 'basepath', '')

FUNCTION  gitgutter#utility#has_repo_path()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/utility.vim:114
Called 45 times
Total time:   0.000571
 Self time:   0.000164

count  total (s)   self (s)
   45   0.000563   0.000157   return index(['', -1, -2], gitgutter#utility#repo_path(a:bufnr, 0)) == -1

FUNCTION  gitbranch#dir()
    Defined: ~/.local/share/nvim/lazy/vim-gitbranch/autoload/gitbranch.vim:26
Called 9 times
Total time:   0.000383
 Self time:   0.000383

count  total (s)   self (s)
    9              0.000011   let path = a:path
    9              0.000006   let prev = ''
    9              0.000035   let git_modules = path =~# '/\.git/modules/'
   24              0.000017   while path !=# prev
   24              0.000019     let dir = path . '/.git'
   24              0.000055     let type = getftype(dir)
   24              0.000097     if type ==# 'dir' && isdirectory(dir.'/objects') && isdirectory(dir.'/refs') && getfsize(dir.'/HEAD') > 10
    9              0.000005       return dir
   15              0.000008     elseif type ==# 'file'
                                  let reldir = get(readfile(dir), 0, '')
                                  if reldir =~# '^gitdir: '
                                    return simplify(path . '/' . reldir[8:])
                                  endif
   15              0.000024     elseif git_modules && isdirectory(path.'/objects') && isdirectory(path.'/refs') && getfsize(path.'/HEAD') > 10
                                  return path
   15              0.000003     endif
   15              0.000008     let prev = path
   15              0.000020     let path = fnamemodify(path, ':h')
   15              0.000005   endwhile
                              return ''

FUNCTION  copilot#OnBufEnter()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:439
Called 7 times
Total time:   0.000116
 Self time:   0.000056

count  total (s)   self (s)
    7              0.000007   let bufnr = bufnr('')
    7   0.000105   0.000045   call copilot#util#Defer(function('s:Focus'), bufnr)

FUNCTION  sy#sign#parse_hunk()
    Defined: ~/.local/share/nvim/lazy/vim-signify/autoload/sy/sign.vim:219
Called 14 times
Total time:   0.000138
 Self time:   0.000138

count  total (s)   self (s)
   14              0.000081   let tokens = matchlist(a:diffline, '^@@ -\v(\d+),?(\d*) \+(\d+),?(\d*)')
   14              0.000053   return [ str2nr(tokens[1]), empty(tokens[2]) ? 1 : str2nr(tokens[2]), str2nr(tokens[3]), empty(tokens[4]) ? 1 : str2nr(tokens[4]) ]

FUNCTION  <SNR>89_highlight_name_for_change()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/sign.vim:234
Called 39 times
Total time:   0.000104
 Self time:   0.000104

count  total (s)   self (s)
   39              0.000027   if a:text ==# 'added'
   23              0.000011     return 'GitGutterLineAdded'
   16              0.000009   elseif a:text ==# 'removed'
                                return 'GitGutterLineRemoved'
   16              0.000010   elseif a:text ==# 'removed_first_line'
                                return 'GitGutterLineRemovedFirstLine'
   16              0.000008   elseif a:text ==# 'modified'
   16              0.000008     return 'GitGutterLineModified'
                              elseif a:text ==# 'modified_removed'
                                return 'GitGutterLineModifiedRemoved'
                              elseif a:text ==# 'removed_above_and_below'
                                return 'GitGutterLineRemovedAboveAndBelow'
                              endif

FUNCTION  gitgutter#hunk#increment_lines_modified()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/hunk.vim:34
Called 4 times
Total time:   0.000078
 Self time:   0.000026

count  total (s)   self (s)
    4   0.000041   0.000011   let summary = gitgutter#hunk#summary(a:bufnr)
    4              0.000003   let summary[1] += a:count
    4   0.000033   0.000011   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  gitgutter#utility#dir()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/utility.vim:324
Called 17 times
Total time:   0.000768
 Self time:   0.000124

count  total (s)   self (s)
   17   0.000764   0.000120   return gitgutter#utility#shellescape(fnamemodify(s:abs_path(a:bufnr, 0), ':h'))

FUNCTION  <SNR>33_on_bufenter()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/plugin/gitgutter.vim:236
Called 7 times
Total time:   0.005277
 Self time:   0.000150

count  total (s)   self (s)
    7   0.000686   0.000027   call gitgutter#setup_maps()
                            
                              " To keep vim's start-up fast, do not process the buffer when vim is starting.
                              " Instead process it a short time later.  Normally we would rely on our
                              " CursorHold autocommand to handle this but it turns out CursorHold is not
                              " guaranteed to fire if the user has not typed anything yet; so set up a
                              " timer instead.  The disadvantage is that if CursorHold does fire, the
                              " plugin will do a round of unnecessary work; but since there will not have
                              " been any changes to the buffer since the first round, the second round
                              " will be cheap.
    7              0.000013   if has('vim_starting') && !$VIM_GITGUTTER_TEST
                                if exists('*timer_start') && has('lambda')
                                  call s:next_tick("call gitgutter#process_buffer(+".bufnr('').", 0)")
                                else
                                  call gitgutter#process_buffer(bufnr(''), 0)
                                endif
                                return
    7              0.000001   endif
                            
    7              0.000010   if exists('t:gitgutter_didtabenter') && t:gitgutter_didtabenter
    4              0.000003     let t:gitgutter_didtabenter = 0
    4   0.000605   0.000011     call gitgutter#all(!g:gitgutter_terminal_reports_focus)
    3              0.000001   else
    3   0.003891   0.000017     call gitgutter#process_buffer(bufnr(''), !g:gitgutter_terminal_reports_focus)
    7              0.000003   endif

FUNCTION  <SNR>2_LoadIndent()
    Defined: /usr/share/nvim/runtime/indent.vim:14
Called 3 times
Total time:   0.001384
 Self time:   0.001321

count  total (s)   self (s)
    3              0.000004     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
    3              0.000001     endif
    3              0.000004     let s = expand("<amatch>")
    3              0.000002     if s != ""
    3              0.000002       if exists("b:did_indent")
                            	unlet b:did_indent
    3              0.000001       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
    6              0.000007       for name in split(s, '\.')
                                    " XXX: "[.]" in the pattern makes it a wildcard on Windows
    3   0.001347   0.001285         exe $'runtime! indent/{name}[.]{{vim,lua}}'
    6              0.000002       endfor
    3              0.000001     endif

FUNCTION  <SNR>96_skip()
    Defined: ~/.local/share/nvim/lazy/vim-signify/autoload/sy.vim:170
Called 2 times
Total time:   0.000045
 Self time:   0.000045

count  total (s)   self (s)
    2              0.000010   if getbufvar(a:bufnr, '&diff') || !filereadable(a:path)
                                return 1
    2              0.000000   endif
                            
    2              0.000002   if exists('g:signify_skip_filetype')
                                if has_key(g:signify_skip_filetype, getbufvar(a:bufnr, '&filetype'))
                                  return 1
                                elseif has_key(g:signify_skip_filetype, 'help') && getbufvar(a:bufnr, '&buftype') == 'help'
                                  return 1
                                endif
    2              0.000000   endif
                            
    2              0.000003   if exists('g:signify_skip_filename') && has_key(g:signify_skip_filename, a:path)
                                return 1
    2              0.000000   endif
                            
                              " DEPRECATED: Use g:signify_skip.pattern instead.
    2              0.000002   if exists('g:signify_skip_filename_pattern')
                                for pattern in g:signify_skip_filename_pattern
                                  if a:path =~ pattern
                                    return 1
                                  endif
                                endfor
    2              0.000001   endif
                            
    2              0.000002   if exists('g:signify_skip')
                                if has_key(g:signify_skip, 'pattern')
                                  for pattern in g:signify_skip.pattern
                                    if a:path =~ pattern
                                      return 1
                                    endif
                                  endfor
                                endif
    2              0.000000   endif
                            
    2              0.000001   return 0

FUNCTION  <SNR>34_not_git_dir()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/utility.vim:68
Called 7 times
Total time:   0.000382
 Self time:   0.000058

count  total (s)   self (s)
    7   0.000380   0.000056   return gitgutter#utility#dir(a:bufnr) !~ '[/\\]\.git\($\|[/\\]\)'

FUNCTION  <SNR>80_setup_path()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter.vim:184
Called 7 times
Total time:   0.003633
 Self time:   0.000053

count  total (s)   self (s)
    7   0.000152   0.000033   if gitgutter#utility#has_repo_path(a:bufnr) | return | endif
                            
    2   0.003478   0.000016   return gitgutter#utility#set_repo_path(a:bufnr, a:continuation)

FUNCTION  <SNR>80_has_fresh_changes()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter.vim:190
Called 4 times
Total time:   0.000041
 Self time:   0.000019

count  total (s)   self (s)
    4   0.000037   0.000016   return getbufvar(a:bufnr, 'changedtick') != gitgutter#utility#getbufvar(a:bufnr, 'tick')

FUNCTION  gitgutter#diff#process_hunks()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/diff.vim:225
Called 3 times
Total time:   0.000637
 Self time:   0.000049

count  total (s)   self (s)
    3              0.000003   let modified_lines = []
   10              0.000005   for hunk in a:hunks
    7   0.000614   0.000026     call extend(modified_lines, s:process_hunk(a:bufnr, hunk))
   10              0.000003   endfor
    3              0.000002   return modified_lines

FUNCTION  AnsiEsc#BufReadPost()
    Defined: ~/.local/share/nvim/lazy/vim-plugin-AnsiEsc/autoload/AnsiEsc.vim:2265
Called 2 times
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    2              0.000003   let bn= bufnr("%")
    2              0.000005   if exists("s:AnsiEsc_enabled_{bn}") && s:AnsiEsc_enabled_{bn}
                               call AnsiEsc#AnsiEsc(1)
    2              0.000001   endif

FUNCTION  <SNR>99_build_command()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/async.vim:43
Called 5 times
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    5              0.000007   if has('unix')
    5              0.000005     return ['sh', '-c', a:cmd]
                              endif
                            
                              if has('win32')
                                return has('nvim') ? a:cmd : 'cmd.exe /c '.a:cmd
                              endif
                            
                              throw 'unknown os'

FUNCTION  copilot#util#Defer()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/util.vim:7
Called 12 times
Total time:   0.000085
 Self time:   0.000085

count  total (s)   self (s)
   12              0.000039   call add(s:deferred, function(a:fn, a:000))
   12              0.000040   return timer_start(0, function('s:RunDeferred'))

FUNCTION  <SNR>105_is_modified_and_added()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/diff.vim:279
Called 2 times
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    2              0.000002   return a:from_count > 0 && a:to_count > 0 && a:from_count < a:to_count

FUNCTION  gitgutter#hunk#increment_lines_added()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/hunk.vim:28
Called 5 times
Total time:   0.000115
 Self time:   0.000036

count  total (s)   self (s)
    5   0.000065   0.000015   let summary = gitgutter#hunk#summary(a:bufnr)
    5              0.000004   let summary[0] += a:count
    5   0.000045   0.000016   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  gitgutter#hunk#set_hunks()
    Defined: ~/.local/share/nvim/lazy/vim-gitgutter/autoload/gitgutter/hunk.vim:5
Called 3 times
Total time:   0.000111
 Self time:   0.000031

count  total (s)   self (s)
    3   0.000054   0.000018   call gitgutter#utility#setbufvar(a:bufnr, 'hunks', a:hunks)
    3   0.000054   0.000011   call s:reset_summary(a:bufnr)

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
    8   0.034796   0.000478  gitgutter#process_buffer()
    3   0.029598   0.000359  gitgutter#diff#run_diff()
    5   0.027185   0.000234  <SNR>99_on_exit_nvim()
    2   0.025218   0.000058  1()
    3   0.019910   0.000321  gitgutter#utility#base_path()
    2   0.018937   0.000083  <SNR>34_obtain_file_renames()
    3   0.018743   0.000155  gitgutter#utility#system()
    8   0.013640   0.000833  sy#start()
    5   0.011838   0.011470  sy#repo#get_diff()
    5   0.011551   0.011410  gitgutter#async#execute()
    3   0.007316   0.004173  <SNR>1_LoadFTPlugin()
    7   0.006486   0.000909  gitgutter#all()
    5   0.006287   0.000032  gitgutter#utility#git_supports_command_line_config_override()
    7   0.005277   0.000150  <SNR>33_on_bufenter()
    5   0.004940   0.000038  <SNR>98_callback_nvim_exit()
    5   0.004902   0.000396  <SNR>98_handle_diff()
   24   0.004359   0.000192  <SNR>83_RunDeferred()
    5   0.004345   0.000231  sy#sign#set_signs()
    5   0.003761   0.002133  sy#sign#process_diff()
    7   0.003633   0.000053  <SNR>80_setup_path()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
    5   0.011838   0.011470  sy#repo#get_diff()
    5   0.011551   0.011410  gitgutter#async#execute()
    3   0.007316   0.004173  <SNR>1_LoadFTPlugin()
    5   0.003761   0.002133  sy#sign#process_diff()
    3   0.001384   0.001321  <SNR>2_LoadIndent()
    4              0.000985  <SNR>79_SynSet()
    5   0.003492   0.000926  <SNR>84_NvimAttach()
    7   0.006486   0.000909  gitgutter#all()
    8   0.013640   0.000833  sy#start()
   78   0.000895   0.000826  <SNR>103_add_sign()
   29              0.000742  <SNR>34_abs_path()
    7   0.000660   0.000581  gitgutter#setup_maps()
  102              0.000559  gitgutter#utility#getbufvar()
    8   0.034796   0.000478  gitgutter#process_buffer()
    5   0.004902   0.000396  <SNR>98_handle_diff()
    5   0.000436   0.000388  sy#sign#get_current_signs()
   11   0.000442   0.000388  <SNR>60_Highlight_Matching_Pair()
    9              0.000383  gitbranch#dir()
    3   0.000499   0.000375  gitgutter#sign#update_signs()
    3   0.029598   0.000359  gitgutter#diff#run_diff()

